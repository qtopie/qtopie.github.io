[{"categories":null,"content":"总览 从Java源码到JVM执行，大致分为“编译 -\u0026amp;gt; 类加载 -\u0026amp;gt; 字节码验证与链接 -\u0026amp;gt; 解释/编译执行 -\u0026amp;gt; 运行期优化”几个阶段。\n.java -\u0026amp;gt; javac -\u0026amp;gt; .class -\u0026amp;gt; 类加载/验证/链接/初始化 -\u0026amp;gt; 解释执行 + JIT -\u0026amp;gt; 运行期优化 + GC + - 100% Full flowchart LR A[Java Source .java] --\u0026gt; B[javac Compile] B --\u0026gt; C[Bytecode .class] subgraph L[Class Loading] D[Loading] E[Verification] F[Preparation] G[Resolution] H[Initialization] D --\u0026gt; E --\u0026gt; F --\u0026gt; G --\u0026gt; H end subgraph R[Runtime Execution] I[Interpreter Execute] J{Hot Method?} K[JIT Compile] L2[Machine Code] M[Runtime Optimization] N[GC + Deoptimization] I --\u0026gt; J J -- No --\u0026gt; I J -- Yes --\u0026gt; K --\u0026gt; L2 --\u0026gt; M --\u0026gt; N end C …","date":"2026-02-08","permalink":"https://qtopie.github.io/notes/java/java-app/","summary":"总览 从Java源码到JVM执行，大致分为“编译 -\u0026gt; 类加载 -\u0026gt; 字节码验证与链接 -\u0026gt; 解释/编译执行 -\u0026gt; 运行期优化”几个阶段。\n.java -\u0026gt; javac -\u0026gt; .class -\u0026gt; 类加载/验证/链接/初始化 -\u0026gt; 解释执行 + JIT -\u0026gt; 运行期优化 + GC + - 100% Full flowchart LR A[Java Source .java] --\u003e B[javac Compile] B --\u003e C[Bytecode .class] subgraph L[Class Loading] D[Loading] E[Verification] F[Preparation] G[Resolution] H[Initialization] D --\u003e E --\u003e F --\u003e G --\u003e H end subgraph R[Runtime Execution] I[Interpreter Execute] J{Hot Method?} K[JIT Compile] L2[Machine Code] M[Runtime Optimization] N[GC + Deoptimization] I --\u003e J J -- No --\u003e I J -- Yes --\u003e K --\u003e L2 --\u003e M --\u003e N end C --\u003e D H --\u003e I 主流程 源码编译（javac） 输入：.java源码文件 输出：.class字节码文件 编译内容：语法/类型检查、常量折叠、语法糖解 desugar、生成字节码与调试信息（如行号表） 这一步只是把源码转换为平台无关的字节码，不生成机器码。\n","tags":null,"title":"Java程序是怎么运行的?"},{"categories":["linux","network"],"content":"eBPF介绍 eBPF（Extended Berkeley Packet Filter）允许开发者在不修改内核源码、不加载内核模块的情况下，把小段受控程序安全地运行在内核里。它通过沙盒虚拟机让内核变得可编程，广泛用于网络、安全、可观测性等场景。\n核心工作原理\n事件驱动：挂载在系统调用、网络包收发、Tracepoint 或 kprobe/uprobes 等钩子上。 安全验证：加载前先过 Verifier 检查，避免崩溃、死循环或越界访问。 JIT 编译：通过 JIT 将字节码转成原生指令，性能接近内核代码。 数据交互：通过 Map（键值存储）在内核态与用户态共享数据。 主要应用场景\n网络加速与负载均衡：例如 Cilium 用 eBPF 做高性能容器网络和安全路由。 可观测性：低开销系统调用跟踪、性能剖析、链路监控，无需改应用代码。 运行时安全：拦截异常系统调用，实现细粒度防火墙或策略控制。 优势对比\n特性 eBPF 程序 内核模块 修改内核源码 安全性 Verifier 保底，避免崩溃 代码错误可能导致死机 风险最高 灵活性 动态加载/卸载，无需重启 加载复杂，易引入依赖 需要编译并重启 性能 JIT 后接近原生 高 高 如需开始开发，可参考 ebpf.io 文档，或使用 BCC、libbpf 等工具链。\neBPF动态扩展了哪些内核能力 深度可观测性与性能剖析 …","date":"2026-01-25","permalink":"https://qtopie.github.io/notes/linux/ebpf/","summary":"eBPF介绍 eBPF（Extended Berkeley Packet Filter）允许开发者在不修改内核源码、不加载内核模块的情况下，把小段受控程序安全地运行在内核里。它通过沙盒虚拟机让内核变得可编程，广泛用于网络、安全、可观测性等场景。\n核心工作原理\n事件驱动：挂载在系统调用、网络包收发、Tracepoint 或 kprobe/uprobes 等钩子上。 安全验证：加载前先过 Verifier 检查，避免崩溃、死循环或越界访问。 JIT 编译：通过 JIT 将字节码转成原生指令，性能接近内核代码。 数据交互：通过 Map（键值存储）在内核态与用户态共享数据。 主要应用场景\n网络加速与负载均衡：例如 Cilium 用 eBPF 做高性能容器网络和安全路由。 可观测性：低开销系统调用跟踪、性能剖析、链路监控，无需改应用代码。 运行时安全：拦截异常系统调用，实现细粒度防火墙或策略控制。 优势对比\n特性 eBPF 程序 内核模块 修改内核源码 安全性 Verifier 保底，避免崩溃 代码错误可能导致死机 风险最高 灵活性 动态加载/卸载，无需重启 加载复杂，易引入依赖 需要编译并重启 性能 JIT 后接近原生 高 高 如需开始开发，可参考 ebpf.io 文档，或使用 BCC、libbpf 等工具链。\neBPF动态扩展了哪些内核能力 深度可观测性与性能剖析 (Observability \u0026amp; Profiling) 无侵入跟踪：挂载到 kprobes/uprobes/tracepoints，实时监控函数或系统调用。 低成本性能监控：采集指令周期、内存、热点函数，几乎零额外开销。 内核态聚合：先在内核过滤/统计，只把结果送到用户态，减少数据拷贝。 高性能网络处理 (Networking) XDP 旁路：在网卡驱动层直接处理包，可做 DDoS 防护、负载均衡、防火墙。 容器网络：为 Kubernetes Pod 提供高效路由，绕过大量 iptables 规则。 自定义协议：在内核态解析非标准协议，无需回到用户态再处理。 动态安全控制 (Security) 行为审计：监控异常访问（如读取 /etc/shadow），触发告警或阻断。 细粒度策略：可限制特定进程只能访问某些 IP/目录。 流量脱敏：在内核态做 TLS 卸载或敏感字段脱敏。 现代内核调度与扩展 (Kernel Evolution) 自定义调度：借助 sched_ext，针对 AI 训练、音视频等场景写专用调度策略。 热补丁：无需重启即可挂载 eBPF 程序修补已知逻辑缺陷。 如何使用 eBPF工作流程 + - 100% Full graph TD subgraph User_Space [\"用户态 (User Space)\"] A[\"编写 eBPF 源代码(C / Rust)\"] -- \"LLVM / Clang\" --\u003e B[\"eBPF 字节码(Bytecode)\"] B -- \"bpf 系统调用\" --\u003e C[\"加载并注入内核\"] L[\"eBPF Maps共享存储/键值对\"] --- M[\"用户态控制程序Go / C++ / Rust\"] M -- \"分析数据\" --\u003e N[\"可视化 / 控制面板\"] end subgraph Kernel_Space [\"内核态 (Kernel Space)\"] C --\u003e D{\"验证器 Verifier安全/权限检查\"} D -- \"拒绝\" --\u003e E[\"报错并停止加载\"] D -- \"通过\" --\u003e F[\"JIT 即时编译器\"] F --\u003e G[\"原生机器码Native Machine Code\"] subgraph Hooks [\"事件钩子 (Event Hooks)\"] H[\"网络包 XDP/TC\"] I[\"系统调用 Syscalls\"] J[\"内核函数 Kprobes\"] K[\"用户函数 Uprobes\"] end G -- \"挂载执行\" --\u003e H G -- \"挂载执行\" --\u003e I G -- \"挂载执行\" --\u003e J G -- \"挂载执行\" --\u003e K H \u0026 I \u0026 J \u0026 K -- \"数据交互\" --\u003e L end style D fill:#f96,stroke:#333,stroke-width:2px style G fill:#00d2ff,stroke:#333,stroke-width:2px style L fill:#fff4dd,stroke:#d4a017,stroke-width:2px 一个加速小例子 场景：为局域网内的平板/手机做游戏加速。思路是：数据包进入网关后，如果源 MAC 在“加速名单”且目标 IP 在“游戏服务器列表”，则把流量指派给本地代理端口（示例中用 1080），否则直连。\n","tags":["eBPF"],"title":"eBPF"},{"categories":["lesson"],"content":" 这篇文章不会有详细的教程，你需要跟大模型一起成长\n目标 掌握基础的计算机知识 掌握基础的编程语法 学习如何使用python数据处理和数据可视化 了解如何开发一个工程化的python应用，并对外提供服务 跟大模型一起完成构建一个数据加工/清洗/分析/可视化的项目 基础的计算知识 推荐书籍（以下为大学计算机/软工必修课程) 有兴趣针对性了解即可，这样对专业能更系统的知识理解\n计算机导论 编译原理 计算机组成 编程语言 算法与数据结构 离散数学 计算机网络 操作系统 数据挖掘+机器学习（扫盲即可） 练习题 ","date":"2026-01-13","permalink":"https://qtopie.github.io/posts/lesson/the-tittle-python-book/","summary":" 这篇文章不会有详细的教程，你需要跟大模型一起成长\n目标 掌握基础的计算机知识 掌握基础的编程语法 学习如何使用python数据处理和数据可视化 了解如何开发一个工程化的python应用，并对外提供服务 跟大模型一起完成构建一个数据加工/清洗/分析/可视化的项目 基础的计算知识 推荐书籍（以下为大学计算机/软工必修课程) 有兴趣针对性了解即可，这样对专业能更系统的知识理解\n计算机导论 编译原理 计算机组成 编程语言 算法与数据结构 离散数学 计算机网络 操作系统 数据挖掘+机器学习（扫盲即可） 练习题","tags":["python"],"title":"python也要会"},{"categories":["lesson"],"content":" 这篇文章不会有详细的教程，你需要跟大模型一起成长\n目标 掌握基础的SQL语法 能自主编写简单的SQL查询语句 能看懂复杂的SQL语句 可以跟大模型一起完成复杂的数据查询和分析工作 环境准备 安装VSCode + DuckDB，就可以在本地用SQL操作csv文件了\nhttps://marketplace.visualstudio.com/items?itemName=RandomFractalsInc.duckdb-sql-tools\nusers.csv (用户表文本) user_id,username,phone 1,张三,13800138001 2,李四,13900139002 3,王五,13700137003 orders.csv (订单表文本) order_id,user_id,amount,status 1001,1,250.00,已支付 1002,1,88.50,待付款 1003,2,1200.00,已发货 用DuckDB导入这两个文件就可以查询了\nSQL基础语法 基础数据查询 SELECT username, phone FROM users WHERE username = \u0026amp;#39;张三\u0026amp;#39; 排序 SELECT * FROM orders ORDER BY amount DESC; 关联查询(JOIN) 因为用户信息和订单信息在不同的文件/表里，你需要把它们 …","date":"2026-01-13","permalink":"https://qtopie.github.io/posts/lesson/the-little-sql-book/","summary":" 这篇文章不会有详细的教程，你需要跟大模型一起成长\n目标 掌握基础的SQL语法 能自主编写简单的SQL查询语句 能看懂复杂的SQL语句 可以跟大模型一起完成复杂的数据查询和分析工作 环境准备 安装VSCode + DuckDB，就可以在本地用SQL操作csv文件了\nhttps://marketplace.visualstudio.com/items?itemName=RandomFractalsInc.duckdb-sql-tools\nusers.csv (用户表文本) user_id,username,phone 1,张三,13800138001 2,李四,13900139002 3,王五,13700137003 orders.csv (订单表文本) order_id,user_id,amount,status 1001,1,250.00,已支付 1002,1,88.50,待付款 1003,2,1200.00,已发货 用DuckDB导入这两个文件就可以查询了\nSQL基础语法 基础数据查询 SELECT username, phone FROM users WHERE username = \u0026#39;张三\u0026#39; 排序 SELECT * FROM orders ORDER BY amount DESC; 关联查询(JOIN) 因为用户信息和订单信息在不同的文件/表里，你需要把它们“拼”起来, 比如下面通过user_id拼起来\nSELECT orders.order_id, users.username, orders.amount FROM orders LEFT JOIN users ON orders.user_id = users.user_id; 统计 求和\nSELECT SUM(amount) FROM orders; 分组统计\n","tags":["sql"],"title":"SQL一定要会"},{"categories":null,"content":"Go gRPC 项目 Protobuf 组织与跨项目依赖规范指南 在微服务架构中，Protobuf（proto）文件不仅是数据交换的协议，更是服务之间的契约。优秀的组织方式能显著降低维护成本，避免“依赖地狱”。\n一、 项目内部组织：中心化与版本化 不要将 .proto 文件散落在业务逻辑目录中，建议在项目根目录采用以下结构：\nmy-project/ ├── api/ # 契约根目录 │ └── v1/ # 版本控制（极其重要） │ ├── user.proto │ └── order.proto ├── gen/ # 生成的代码（与定义物理隔离） │ └── go/ │ └── v1/ │ ├── user.pb.go │ └── user_grpc.pb.go ├── buf.yaml # Buf 配置文件（可选，推荐） ├── go.mod └── Makefile # 自动化编译脚本 核心原则 目录版本化：始终使用 v1, v2 目录。这允许你在同一个项目中同时运行多个版本的 API。 go_package 规范：在 .proto 中明确指定完整的导入路径： option go_package = \u0026amp;#34;github.com/org/repo/gen/go/v1;userv1\u0026amp;#34;; 职责分离：api/ 只存定义，gen/ 只存自动生成的代码，业务实现在 …","date":"2026-01-07","permalink":"https://qtopie.github.io/notes/dev/grpc-proto-practices/","summary":"Go gRPC 项目 Protobuf 组织与跨项目依赖规范指南 在微服务架构中，Protobuf（proto）文件不仅是数据交换的协议，更是服务之间的契约。优秀的组织方式能显著降低维护成本，避免“依赖地狱”。\n一、 项目内部组织：中心化与版本化 不要将 .proto 文件散落在业务逻辑目录中，建议在项目根目录采用以下结构：\nmy-project/ ├── api/ # 契约根目录 │ └── v1/ # 版本控制（极其重要） │ ├── user.proto │ └── order.proto ├── gen/ # 生成的代码（与定义物理隔离） │ └── go/ │ └── v1/ │ ├── user.pb.go │ └── user_grpc.pb.go ├── buf.yaml # Buf 配置文件（可选，推荐） ├── go.mod └── Makefile # 自动化编译脚本 核心原则 目录版本化：始终使用 v1, v2 目录。这允许你在同一个项目中同时运行多个版本的 API。 go_package 规范：在 .proto 中明确指定完整的导入路径： option go_package = \u0026#34;github.com/org/repo/gen/go/v1;userv1\u0026#34;; 职责分离：api/ 只存定义，gen/ 只存自动生成的代码，业务实现在 internal/ 或 pkg/。 二、 跨项目依赖：三种实战方案 当项目 B 需要调用项目 A 的 gRPC 接口时，绝对不要手动复制 .proto 文件。\n","tags":null,"title":"Go gRPC 项目Protobuf 组织与跨项目依赖规范指南"},{"categories":["photography"],"content":"XS-20介绍 A 模式 (Aperture Priority) —— 光圈优先模式 含义： 你手动控制光圈，相机自动帮你计算快门速度。 为什么要用： 这是使用 35mm F1.4 的首选模式。因为这支镜头的精髓在于 F1.4 的大光圈。\n操作建议： 想拍背景虚化的糖水片，就拧到 1.4；想拍风景锐利一点，就拧到 5.6 或 8。相机会确保照片亮度正常，你只需要关注“虚化程度”。\nS 模式 (Shutter Priority) —— 快门优先模式 含义： 你手动控制快门速度，相机自动帮你计算光圈。 为什么要用： 当你要拍“动来动去”的东西时（比如宠物、跑动的小孩）。\n操作建议： 如果想凝固瞬间，把快门定在 1/500s 以上；如果想拍出丝滑的流水，就定在 1/15s 甚至更慢。\nP 模式 (Program AE) —— 程序自动模式 含义： 相机自动决定光圈和快门，但允许你调整 ISO、白平衡、胶片模拟等。 为什么要用： 比起完全傻瓜的 AUTO 模式，P 模式能让你保留对“色彩（胶片模拟）”和“亮度（曝光补偿）”的控制权。\n操作建议： 当你只想随手抓拍，不想思考参数，但又想用富士的经典正片（Classic Chrome）色彩时，用 P 模式。\n拍摄技巧 既然你拿到了富士 X-S20 和 35mm F1.4 这样一套兼具性能与审美色彩的设备，理解它的原理能让你不再只是“按快门”，而 …","date":"2026-01-01","permalink":"https://qtopie.github.io/notes/photography/xs20/","summary":"XS-20介绍 A 模式 (Aperture Priority) —— 光圈优先模式 含义： 你手动控制光圈，相机自动帮你计算快门速度。 为什么要用： 这是使用 35mm F1.4 的首选模式。因为这支镜头的精髓在于 F1.4 的大光圈。\n操作建议： 想拍背景虚化的糖水片，就拧到 1.4；想拍风景锐利一点，就拧到 5.6 或 8。相机会确保照片亮度正常，你只需要关注“虚化程度”。\nS 模式 (Shutter Priority) —— 快门优先模式 含义： 你手动控制快门速度，相机自动帮你计算光圈。 为什么要用： 当你要拍“动来动去”的东西时（比如宠物、跑动的小孩）。\n操作建议： 如果想凝固瞬间，把快门定在 1/500s 以上；如果想拍出丝滑的流水，就定在 1/15s 甚至更慢。\nP 模式 (Program AE) —— 程序自动模式 含义： 相机自动决定光圈和快门，但允许你调整 ISO、白平衡、胶片模拟等。 为什么要用： 比起完全傻瓜的 AUTO 模式，P 模式能让你保留对“色彩（胶片模拟）”和“亮度（曝光补偿）”的控制权。\n操作建议： 当你只想随手抓拍，不想思考参数，但又想用富士的经典正片（Classic Chrome）色彩时，用 P 模式。\n拍摄技巧 既然你拿到了富士 X-S20 和 35mm F1.4 这样一套兼具性能与审美色彩的设备，理解它的原理能让你不再只是“按快门”，而是“创作”。\n一、 成像原理：光的“奇幻漂流” 相机的本质其实是一个高度精密的暗盒。\n收集光线（镜头）： 当你按下快门，光线穿过你的 35mm F1.4 镜头。镜头里的玻璃镜片会将发散的光线折射、汇聚。 控制光量（光圈与快门）： * 光圈（你镜头上的环）像眼球的瞳孔，开大（F1.4）进光多，缩小（F16）进光少。 快门像眼皮，开启时间长，进光就多。 记录影像（感光元件）： 光线最终打在 X-S20 内部的那个传感器（CMOS）上。传感器上有数千万个小光敏点，它们把光转换成电信号，最后由处理器转化成你在屏幕上看到的胶片感照片。 二、 拍出“好照片”的四大要素 很多新手纠结于参数，但好的照片往往是以下四个维度的平衡：\n","tags":["travel"],"title":"XS20摄影技巧"},{"categories":["notes"],"content":"深圳到中山旅游攻略 基于小红书热门笔记总结的深圳到中山旅游攻略，涵盖交通、行程规划、美食及景点推荐。\n🚗 交通指南 1. 深中跨市公交 (高性价比) 路线: 深圳前海湾站 ↔ 中山博览中心枢纽 / 中山国际人才港 车次: T01A (博览中心方向), T01B (人才港方向) 票价: 15-18元/人 耗时: 约1小时 服务时间: 06:30 - 21:30 购票: 微信搜索“深巴出行”小程序提前购票 市内交通: 到达中山后，打车前往各景点非常便宜（通常15元以内）。 2. 自驾 (灵活便捷) 路线: 深圳 → 深中通道 → 中山 耗时: 1 - 1.5小时 费用: 高速费约 80-90 元 (单程) 停车: 中山博物馆/纪念堂附近有停车场。 孙文西路步行街可停在中山公园区域。 兴中广场（摩天轮）停车方便。 🗺️ 行程规划推荐 方案一：特种兵一日游 (自驾/早出晚归) 08:00 深圳出发，经深中通道。 09:30 中山市博物馆 (需预约，免费)：了解中山历史文化，停车方便。 10:30 四喜咖啡 (Four Joy Coffee)：博物馆附近，网红打卡点，推荐Dirty、拿铁。 11:00 西山寺：市区制高点，古建筑，清静。 11:40 孙文西路步行街：感受老中山骑楼风情。 伴手礼：咀香园旗舰店 (杏仁饼)。 甜品：众生堂 (双皮奶)。 12:30 午餐：马喜鸽 (石岐乳鸽、白切 …","date":"2026-01-01","permalink":"https://qtopie.github.io/notes/ai/shenzhen-to-zhongshan-guide/","summary":"深圳到中山旅游攻略 基于小红书热门笔记总结的深圳到中山旅游攻略，涵盖交通、行程规划、美食及景点推荐。\n🚗 交通指南 1. 深中跨市公交 (高性价比) 路线: 深圳前海湾站 ↔ 中山博览中心枢纽 / 中山国际人才港 车次: T01A (博览中心方向), T01B (人才港方向) 票价: 15-18元/人 耗时: 约1小时 服务时间: 06:30 - 21:30 购票: 微信搜索“深巴出行”小程序提前购票 市内交通: 到达中山后，打车前往各景点非常便宜（通常15元以内）。 2. 自驾 (灵活便捷) 路线: 深圳 → 深中通道 → 中山 耗时: 1 - 1.5小时 费用: 高速费约 80-90 元 (单程) 停车: 中山博物馆/纪念堂附近有停车场。 孙文西路步行街可停在中山公园区域。 兴中广场（摩天轮）停车方便。 🗺️ 行程规划推荐 方案一：特种兵一日游 (自驾/早出晚归) 08:00 深圳出发，经深中通道。 09:30 中山市博物馆 (需预约，免费)：了解中山历史文化，停车方便。 10:30 四喜咖啡 (Four Joy Coffee)：博物馆附近，网红打卡点，推荐Dirty、拿铁。 11:00 西山寺：市区制高点，古建筑，清静。 11:40 孙文西路步行街：感受老中山骑楼风情。 伴手礼：咀香园旗舰店 (杏仁饼)。 甜品：众生堂 (双皮奶)。 12:30 午餐：马喜鸽 (石岐乳鸽、白切鸡、猪杂粥)。 14:00 岐江公园：工业风遗址公园，适合拍照。 15:00 孙中山故居纪念馆 (5A景区)：必打卡，游览约1.5小时。 17:00 詹园：岭南园林，夕阳时分景色最佳 (门票约50元)。 18:30 幻彩摩天轮：兴中广场，欣赏中山夜景 (门票30-50元)。 19:30 晚餐：大墩荣记食店 (脆皮猪手、炒田螺、椒盐虾、咸骨粥)。 21:00 返程深圳。 方案二：休闲两天一夜 (City Walk + 吃喝) Day 1: 下午到达中山，入住老城区附近酒店。 晚餐：大墩荣记食店。 夜游：幻彩摩天轮 + 岐江桥漫步，吹晚风看夜景。 Day 2: 早茶：爱群食店 (老字号，性价比高，蒸笼堆成山)。 上午：中山市博物馆 -\u0026gt; 四喜咖啡 -\u0026gt; 西山寺。 下午：前往孙中山故居 (推荐) 或 崖口村 (看稻田/海边，视季节而定)。 返程：从中山国际人才港乘公交回深圳。 🍲 美食推荐 石岐乳鸽: 中山必吃，皮脆肉嫩。推荐：马喜鸽、石岐佬。 脆皮猪手/咸骨粥: 大排档风味。推荐：大墩荣记食店。 早茶: 感受广东早茶文化。推荐：爱群食店。 甜品: 众生堂 (双皮奶、姜撞奶)。 伴手礼: 咀香园 (杏仁饼、鸡仔饼)。 💡 小贴士 深中通道体验很好，但周末可能会有拥堵，建议错峰出行。 中山市内交通打车很便宜，非自驾也很方便。 孙文西路步行街部分区域可能在装修，建议提前确认。 崖口村适合看稻浪，如果稻子收割了景色会打折，建议替换为孙中山故居。 注：以上信息整理自小红书热门笔记，具体营业时间及票价请以实际为准。\n","tags":["travel","zhongshan","shenzhen","xiaohongshu"],"title":"深圳到中山旅游攻略 (基于小红书总结)"},{"categories":null,"content":"吉他简谱练习\nstave [tuning=EADGBe] [time=4/4] C9 $4 x $3 x $2 x $3 x | $5 x $4 0h2 $2 x $3 x | G $6 x $4 x $2 x $3 x | $6 x $2 x $6 2 $2 x | C9 $4 x $3 x $2 x $3 x | $5 x $4 0h2 $2 x $3 x | G $6 x $4 x $2 x $3 x | $6 x $4 x/8 $2 x/8 $6 2 $4 x/8 $2 x/8 || stave | Em7:0 $3 v | v/16 ^/16 | C:0 v ^ v ^ | v v ^ | G:0 v v ^ | v ^ v ^ | D v v ^ | stave | Em7:0 $3 v v ^ | C:0 v ^ v ^ | v v ^ | G:0 v v ^ | v ^ v ^ | D v v ^ | ","date":"2025-12-18","permalink":"https://qtopie.github.io/notes/guitar/sunny-day/","summary":"吉他简谱练习\nstave [tuning=EADGBe] [time=4/4] C9 $4 x $3 x $2 x $3 x | $5 x $4 0h2 $2 x $3 x | G $6 x $4 x $2 x $3 x | $6 x $2 x $6 2 $2 x | C9 $4 x $3 x $2 x $3 x | $5 x $4 0h2 $2 x $3 x | G $6 x $4 x $2 x $3 x | $6 x $4 x/8 $2 x/8 $6 2 $4 x/8 $2 x/8 || stave | Em7:0 $3 v | v/16 ^/16 | C:0 v ^ v ^ | v v ^ | G:0 v v ^ | v ^ v ^ | D v v ^ | stave | Em7:0 $3 v v ^ | C:0 v ^ v ^ | v v ^ | G:0 v v ^ | v ^ v ^ | D v v ^ | ","tags":null,"title":"晴天"},{"categories":null,"content":"吉他简谱练习\nstave [tuning=EADGBe] [time=4/4] Em7 $4 x $3 x | $2 x x x x | Dsus2 $4 x $3 x $2 x | Csus2 $5 x $3 x $2 x | G $6 x $3 x $2 x | stave [tuning=EADGBe] [time=4/4] Em7 $4 x $3 x | $2 x x x x | Dsus2 $4 x $3 x $2 x | Csus2 $5 x $3 x $2 x | G $6 x $3 x $2 x || stave [tuning=EADGBe] [time=4/4] Em7 $4 x $3 x $2 x | Dsus2 $4 x $3 x $2 x | Csus2 $5 x $3 x $2 x | G $6 x $3 x $2 x | stave [tuning=EADGBe] [time=4/4] Em7 $4 x $3 x $2 x | Dsus2 $4 x $3 x $2 x | Csus2 $5 x $3 x $2 x | G $6 x $3 x $2 x || 【《第57次取消发送》吉他教学 …","date":"2025-12-18","permalink":"https://qtopie.github.io/notes/guitar/57th-of-cancellation-send/","summary":"吉他简谱练习\nstave [tuning=EADGBe] [time=4/4] Em7 $4 x $3 x | $2 x x x x | Dsus2 $4 x $3 x $2 x | Csus2 $5 x $3 x $2 x | G $6 x $3 x $2 x | stave [tuning=EADGBe] [time=4/4] Em7 $4 x $3 x | $2 x x x x | Dsus2 $4 x $3 x $2 x | Csus2 $5 x $3 x $2 x | G $6 x $3 x $2 x || stave [tuning=EADGBe] [time=4/4] Em7 $4 x $3 x $2 x | Dsus2 $4 x $3 x $2 x | Csus2 $5 x $3 x $2 x | G $6 x $3 x $2 x | stave [tuning=EADGBe] [time=4/4] Em7 $4 x $3 x $2 x | Dsus2 $4 x $3 x $2 x | Csus2 $5 x $3 x $2 x | G $6 x $3 x $2 x || 【《第57次取消发送》吉他教学】https://www.bilibili.com/video/BV1XfnAzwEnG?vd_source=3c404ae4349980e59af7e78f2d24ba86\n","tags":null,"title":"第57次取消发送"},{"categories":null,"content":"深入浅出 JDBC 连接池：从原理到性能调优 在高性能 Java 应用中，数据库连接池（Connection Pool）是优化系统响应速度、保障数据库稳定性的核心组件。\n1. 核心原理：为什么要用池化技术？ 传统的 JDBC 操作（DriverManager.getConnection()）是重量级的。每次请求都要经历：\nTCP 三次握手：网络层建连。 身份验证：数据库层校验用户名密码。 分配资源：数据库为该会话分配内存和进程。 SQL 执行与结果传输。 四次挥手：断开连接。 连接池的价值：\n资源复用：连接在池中常驻，消除建连和销毁的开销。 流量削峰：通过 maxActive 限制并发数，保护数据库不被瞬时请求击垮。 连接健康监测：自动检测死连接并进行剔除或重连。 2. 主流连接池对比：HikariCP vs Druid 目前生产环境下，基本只推荐这两款产品：\nHikariCP (极致的快) 地位：Spring Boot 2.x 默认内置。 默认值：最大连接数 10，最小空闲 10。 黑科技： 字节码精简：优化了代理对象的生成。 FastList：自定义集合，替代 ArrayList，减少数组边界检查。 无锁编程：大量使用 ThreadLocal 缓存连接，减少锁竞争。 Druid (全能监控) 地位：国产之光，阿里开源。 默认值：最大连接数 8，最小空闲 0。 核心优势： 监控视 …","date":"2025-12-10","permalink":"https://qtopie.github.io/notes/java/jdbc-conn-pool/","summary":"深入浅出 JDBC 连接池：从原理到性能调优 在高性能 Java 应用中，数据库连接池（Connection Pool）是优化系统响应速度、保障数据库稳定性的核心组件。\n1. 核心原理：为什么要用池化技术？ 传统的 JDBC 操作（DriverManager.getConnection()）是重量级的。每次请求都要经历：\nTCP 三次握手：网络层建连。 身份验证：数据库层校验用户名密码。 分配资源：数据库为该会话分配内存和进程。 SQL 执行与结果传输。 四次挥手：断开连接。 连接池的价值：\n资源复用：连接在池中常驻，消除建连和销毁的开销。 流量削峰：通过 maxActive 限制并发数，保护数据库不被瞬时请求击垮。 连接健康监测：自动检测死连接并进行剔除或重连。 2. 主流连接池对比：HikariCP vs Druid 目前生产环境下，基本只推荐这两款产品：\nHikariCP (极致的快) 地位：Spring Boot 2.x 默认内置。 默认值：最大连接数 10，最小空闲 10。 黑科技： 字节码精简：优化了代理对象的生成。 FastList：自定义集合，替代 ArrayList，减少数组边界检查。 无锁编程：大量使用 ThreadLocal 缓存连接，减少锁竞争。 Druid (全能监控) 地位：国产之光，阿里开源。 默认值：最大连接数 8，最小空闲 0。 核心优势： 监控视图：内置 StatViewServlet，可直观查看 SQL 执行耗时、慢查询、并发峰值。 防 SQL 注入：内置 WallFilter 防火墙，从连接池层面对 SQL 风险进行过滤。 3. 关键参数与性能计算 连接池配置不是越大越好，而是要寻找**吞吐量（QPS）与响应时间（RT）**的平衡点。\n核心公式 理论单机 QPS 预估：\n","tags":null,"title":"JDBC连接池"},{"categories":null,"content":"方式 1: 使用 Shortcode 方式 2: 使用 Markdown 代码块 \\title \u0026amp;#34;Code Block Tab\u0026amp;#34; \\artist \u0026amp;#34;Test\u0026amp;#34; . . . | 0 1 2 3 | ","date":"2025-12-01","permalink":"https://qtopie.github.io/notes/guitar/guitar-tab/","summary":"方式 1: 使用 Shortcode 方式 2: 使用 Markdown 代码块 \\title \u0026#34;Code Block Tab\u0026#34; \\artist \u0026#34;Test\u0026#34; . . . | 0 1 2 3 | ","tags":null,"title":"AlphaTab 测试"},{"categories":null,"content":" 富爸爸穷爸爸 (二刷) 山海经密码 (三刷) [] 草房子 [] 《一千零一夜》 新华网做了一个人生必读100本书问卷 https://www.xinhuanet.com/book/zhuanti/rsbdbook/#","date":"2025-11-30","permalink":"https://qtopie.github.io/notes/book/2025-book-list/","summary":" 富爸爸穷爸爸 (二刷) 山海经密码 (三刷) [] 草房子 [] 《一千零一夜》 新华网做了一个人生必读100本书问卷 https://www.xinhuanet.com/book/zhuanti/rsbdbook/#\n","tags":null,"title":"2025书单"},{"categories":["guitar"],"content":"吉他怎么调音 吉他调音顺序是将6、5、4、3、2、1六根琴弦的音高， 对应EADGBe。 校定为6弦—E低音E、5弦—A、4弦—D、3弦—G、2弦—B，1弦—E高音E。 从6到1弦分别是E-A-D-G-B-E，即低音3，低音6，中音2，中音5，中音7，高音3。 这是基本调弦标准音，特殊调弦除外，调音器夹到琴头从六弦开始调\n常见吉他和弦 stave [tuning=EADGBe] [time=4/4] | C:0 | G:0 | Am:0 | Em:0 | F:0 | G:0 | C:0 | D:0 | end stave [tuning=EADGBe] [time=4/4] | C:0 | G:0 | Am:0 | Em:0 | Dm:0 | G:0 | C:0 | end Tab + 指法标记示例\nBm $3 4 4h5p3h4 5 $2 3 5 7 7h8p7 5/7 | A $4 7 9 $3 7 6 $5 9 $4 7h9 7 $5 9\\7 5/7 || stave [time=4/4] | C:0 ^1-3 | G:0 v3 | $3 0 2 ^ 3 0 v | Smelly Cat\nstave | E:0 | A:0 | D:0 | A:0 | E:0 | end ","date":"2025-11-30","permalink":"https://qtopie.github.io/notes/guitar/guitar-basic/","summary":"吉他怎么调音 吉他调音顺序是将6、5、4、3、2、1六根琴弦的音高， 对应EADGBe。 校定为6弦—E低音E、5弦—A、4弦—D、3弦—G、2弦—B，1弦—E高音E。 从6到1弦分别是E-A-D-G-B-E，即低音3，低音6，中音2，中音5，中音7，高音3。 这是基本调弦标准音，特殊调弦除外，调音器夹到琴头从六弦开始调\n常见吉他和弦 stave [tuning=EADGBe] [time=4/4] | C:0 | G:0 | Am:0 | Em:0 | F:0 | G:0 | C:0 | D:0 | end stave [tuning=EADGBe] [time=4/4] | C:0 | G:0 | Am:0 | Em:0 | Dm:0 | G:0 | C:0 | end Tab + 指法标记示例\nBm $3 4 4h5p3h4 5 $2 3 5 7 7h8p7 5/7 | A $4 7 9 $3 7 6 $5 9 $4 7h9 7 $5 9\\7 5/7 || stave [time=4/4] | C:0 ^1-3 | G:0 v3 | $3 0 2 ^ 3 0 v | Smelly Cat\n","tags":null,"title":"吉他基础"},{"categories":null,"content":"掌握吉他扫弦（刷的节奏）是初学者的一个重要里程碑。扫弦的节奏感很大程度上依赖于稳定的右手动作和对节拍的理解。\n这里为您提供一套系统的学习步骤和技巧：\n🎸 初学者掌握扫弦节奏的五大步骤 1. 专注右手动作 (无和弦练习) 在开始担心和弦之前，先让您的右手独立稳定下来。\n⚡️ 静音练习（Muting）: 用您的左手轻轻地搭在琴弦上，但不要按实，让所有琴弦发出“闷”或“沙”的声音（这被称为闷音或制音）。 只用您的右手（拨片或手指）进行上下扫弦练习。 目标： 确保您的上下扫弦声音均匀、力度一致，并且动作非常放松。手腕应该是驱动力，而不是手臂。 ⏱️ 使用节拍器 (Metronome): 将节拍器设置为一个非常慢的速度（例如：每分钟 60-80 拍）。 练习一： 每一拍只扫一次（下扫 $\\downarrow$）。 练习二： 每一拍扫两次（下扫 $\\downarrow$ 和上扫 $\\uparrow$）。记住，$\\downarrow$ 在拍子上，$\\uparrow$ 在“and”上（即两拍之间）。 2. 理解基本节奏型 初学者最常用的节奏型是四分音符和八分音符。\n四分音符（每拍一扫）： 数数方式：1 - 2 - 3 - 4 扫弦方向：$\\downarrow$ - (停) - $\\downarrow$ - (停) - $\\downarrow$ - (停) - $\\downarrow$ - (停) …","date":"2025-11-28","permalink":"https://qtopie.github.io/notes/guitar/guitar-strum/","summary":"掌握吉他扫弦（刷的节奏）是初学者的一个重要里程碑。扫弦的节奏感很大程度上依赖于稳定的右手动作和对节拍的理解。\n这里为您提供一套系统的学习步骤和技巧：\n🎸 初学者掌握扫弦节奏的五大步骤 1. 专注右手动作 (无和弦练习) 在开始担心和弦之前，先让您的右手独立稳定下来。\n⚡️ 静音练习（Muting）: 用您的左手轻轻地搭在琴弦上，但不要按实，让所有琴弦发出“闷”或“沙”的声音（这被称为闷音或制音）。 只用您的右手（拨片或手指）进行上下扫弦练习。 目标： 确保您的上下扫弦声音均匀、力度一致，并且动作非常放松。手腕应该是驱动力，而不是手臂。 ⏱️ 使用节拍器 (Metronome): 将节拍器设置为一个非常慢的速度（例如：每分钟 60-80 拍）。 练习一： 每一拍只扫一次（下扫 $\\downarrow$）。 练习二： 每一拍扫两次（下扫 $\\downarrow$ 和上扫 $\\uparrow$）。记住，$\\downarrow$ 在拍子上，$\\uparrow$ 在“and”上（即两拍之间）。 2. 理解基本节奏型 初学者最常用的节奏型是四分音符和八分音符。\n四分音符（每拍一扫）： 数数方式：1 - 2 - 3 - 4 扫弦方向：$\\downarrow$ - (停) - $\\downarrow$ - (停) - $\\downarrow$ - (停) - $\\downarrow$ - (停) 八分音符（每拍两扫）： 数数方式：1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 扫弦方向：$\\downarrow$ $\\uparrow$ $\\downarrow$ $\\uparrow$ $\\downarrow$ $\\uparrow$ $\\downarrow$ $\\uparrow$ ✍️ 建议： 在练习时，务必将数数（1 \u0026amp; 2 \u0026amp;\u0026hellip;）和您的扫弦声音同步说出来。这能帮助您将听觉、视觉和动作联系起来。 3. 掌握基础节奏型（以八分音符为主） 一旦您能稳定地进行“$\\downarrow$ $\\uparrow$ $\\downarrow$ $\\uparrow$”的连贯扫弦，就可以开始学习初学最常用的、带休止或省略的节奏型了。\n","tags":null,"title":"吉他扫弦"},{"categories":null,"content":"G1 G1垃圾回收的过程\n如何实现maxPauseTime\nG1的特点, 优点和缺点\nG1 是 Java HotSpot 虚拟机自 JDK7u4 起提供的服务器端垃圾回收器，目标是替代 CMS，适用于大堆内存、低延迟场景。G1 通过分区、并发和自适应等机制，实现高吞吐量和可预测的停顿时间。\nG1 的主要特点 分区管理（Region）：将堆划分为多个大小相等的 Region，每个 Region 可作为 Eden、Survivor 或 Old 区，灵活管理内存。 分代收集：同时支持年轻代和老年代的垃圾收集。 可预测停顿时间：允许用户设置最大停顿时间目标（如 -XX:MaxGCPauseMillis），G1 会自适应调整回收行为以尽量满足目标。 并发与并行：支持多线程并发标记和回收，减少 Stop-The-World（STW）时间。 垃圾优先：优先回收垃圾最多的 Region，提高回收效率。 整体堆回收：可对整个堆进行回收，避免碎片化。 G1 垃圾回收过程 触发条件 年轻代空间不足时触发 Young GC。 老年代空间不足或达到阈值时触发 Mixed GC 或 Full GC。 显式调用 System.gc() 可能触发 Full GC。 回收阶段 G1 的回收阶段分为两类：Young Only GC 和 Mixed GC。\nYoung Only GC 阶段\n仅回收年轻代（Eden 和 …","date":"2025-06-29","permalink":"https://qtopie.github.io/notes/java/g1/","summary":"G1 G1垃圾回收的过程\n如何实现maxPauseTime\nG1的特点, 优点和缺点\nG1 是 Java HotSpot 虚拟机自 JDK7u4 起提供的服务器端垃圾回收器，目标是替代 CMS，适用于大堆内存、低延迟场景。G1 通过分区、并发和自适应等机制，实现高吞吐量和可预测的停顿时间。\nG1 的主要特点 分区管理（Region）：将堆划分为多个大小相等的 Region，每个 Region 可作为 Eden、Survivor 或 Old 区，灵活管理内存。 分代收集：同时支持年轻代和老年代的垃圾收集。 可预测停顿时间：允许用户设置最大停顿时间目标（如 -XX:MaxGCPauseMillis），G1 会自适应调整回收行为以尽量满足目标。 并发与并行：支持多线程并发标记和回收，减少 Stop-The-World（STW）时间。 垃圾优先：优先回收垃圾最多的 Region，提高回收效率。 整体堆回收：可对整个堆进行回收，避免碎片化。 G1 垃圾回收过程 触发条件 年轻代空间不足时触发 Young GC。 老年代空间不足或达到阈值时触发 Mixed GC 或 Full GC。 显式调用 System.gc() 可能触发 Full GC。 回收阶段 G1 的回收阶段分为两类：Young Only GC 和 Mixed GC。\nYoung Only GC 阶段\n仅回收年轻代（Eden 和 Survivor 区）的 Region。 触发条件：年轻代空间不足。 过程：采用并行回收，通常伴随初始标记（Initial Mark），会发生短暂的 STW（Stop-The-World）暂停。 目标：快速回收短生命周期对象，腾出新生代空间。 Young Only GC 的过程 Young Only GC 主要针对年轻代（Eden 和 Survivor 区）的 Region 进行回收，流程如下：\n","tags":null,"title":"G1 垃圾回收器（Garbage-First, G1 GC）"},{"categories":null,"content":"ZGC 简介 **ZGC（Z Garbage Collector）**是 Java HotSpot 虚拟机自 JDK 11 引入的一款可扩展、低延迟的垃圾回收器，专为大堆内存和对延迟极为敏感的应用场景设计。\n主要特点 超低延迟：GC 停顿时间通常不超过 1~2 毫秒，与堆大小几乎无关（即使 TB 级堆）。 并发回收：大部分垃圾回收工作与应用线程并发进行，极大减少 Stop-The-World（STW）时间。 可扩展性强：支持超大堆（数 TB 级别），适合大数据、在线服务等场景。 Regionless 设计：不像 G1 那样分 Region，ZGC 采用按需分配的内存块（Chunk），简化内存管理。 着色指针（Colored Pointers）：利用对象引用的高位存储元数据，实现高效的并发标记和转移。 工作原理 并发标记：与应用线程并发，标记所有可达对象。 并发重定位：对象在后台被迁移到新内存，引用通过着色指针和读屏障自动修正。 并发清理：回收不可达对象占用的内存。 极短暂停：只有少量阶段（如初始标记、重新标记）会有极短的 STW 停顿。 启用方式 JDK 11+：-XX:+UseZGC JDK 15+ 支持 Windows/macOS 常用参数： -Xmx、-Xms 设置堆大小 -XX:ConcGCThreads 并发 GC 线程数 -XX:MaxGCPauseMillis 期望最 …","date":"2025-06-29","permalink":"https://qtopie.github.io/notes/java/zgc/","summary":"ZGC 简介 **ZGC（Z Garbage Collector）**是 Java HotSpot 虚拟机自 JDK 11 引入的一款可扩展、低延迟的垃圾回收器，专为大堆内存和对延迟极为敏感的应用场景设计。\n主要特点 超低延迟：GC 停顿时间通常不超过 1~2 毫秒，与堆大小几乎无关（即使 TB 级堆）。 并发回收：大部分垃圾回收工作与应用线程并发进行，极大减少 Stop-The-World（STW）时间。 可扩展性强：支持超大堆（数 TB 级别），适合大数据、在线服务等场景。 Regionless 设计：不像 G1 那样分 Region，ZGC 采用按需分配的内存块（Chunk），简化内存管理。 着色指针（Colored Pointers）：利用对象引用的高位存储元数据，实现高效的并发标记和转移。 工作原理 并发标记：与应用线程并发，标记所有可达对象。 并发重定位：对象在后台被迁移到新内存，引用通过着色指针和读屏障自动修正。 并发清理：回收不可达对象占用的内存。 极短暂停：只有少量阶段（如初始标记、重新标记）会有极短的 STW 停顿。 启用方式 JDK 11+：-XX:+UseZGC JDK 15+ 支持 Windows/macOS 常用参数： -Xmx、-Xms 设置堆大小 -XX:ConcGCThreads 并发 GC 线程数 -XX:MaxGCPauseMillis 期望最大停顿时间 适用场景 需要极低 GC 停顿的在线服务 大内存、大对象、大吞吐量应用 金融、电商、广告、实时分析等领域 ZGC 的垃圾回收过程 ZGC 的回收过程高度并发，主要分为以下几个阶段：\n初始标记（Initial Mark）\n标记从 GC Roots 直接可达的对象。 该阶段会有一次极短的 Stop-The-World（STW）暂停。 并发标记（Concurrent Mark）\n","tags":null,"title":"ZGC"},{"categories":null,"content":"基础理论 ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。 CAP：一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）。 BASE：基本可用（Basically Available）、软状态（Soft State）、最终一致性（Eventually Consistent）。 2PC（两阶段提交） 两阶段提交（Two-Phase Commit, 2PC）是一种经典的分布式事务协议，用于确保多个分布式系统中的操作要么全部成功，要么全部失败，保证数据一致性。\n流程 准备阶段（Prepare Phase）\n协调者（Coordinator）向所有参与者（Participant）发送准备提交请求（prepare）。\n参与者执行本地事务操作，但不提交，只写入预提交日志，并锁定相关资源。\n参与者将执行结果（可以提交/不能提交）反馈给协调者。\n提交阶段（Commit Phase）\n如果所有参与者都反馈“可以提交”，协调者向所有参与者发送提交（commit）请求，参与者正式提交本地事务，释放资源。 如果有任何一个参与者反馈“不能提交”或超时未响应，协调者向所有参与者发送回滚（rollback）请求，参与者回滚本地事务，释放资源。 + - …","date":"2025-06-29","permalink":"https://qtopie.github.io/notes/system-design/tcc/","summary":"基础理论 ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。 CAP：一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）。 BASE：基本可用（Basically Available）、软状态（Soft State）、最终一致性（Eventually Consistent）。 2PC（两阶段提交） 两阶段提交（Two-Phase Commit, 2PC）是一种经典的分布式事务协议，用于确保多个分布式系统中的操作要么全部成功，要么全部失败，保证数据一致性。\n流程 准备阶段（Prepare Phase）\n协调者（Coordinator）向所有参与者（Participant）发送准备提交请求（prepare）。\n参与者执行本地事务操作，但不提交，只写入预提交日志，并锁定相关资源。\n参与者将执行结果（可以提交/不能提交）反馈给协调者。\n提交阶段（Commit Phase）\n如果所有参与者都反馈“可以提交”，协调者向所有参与者发送提交（commit）请求，参与者正式提交本地事务，释放资源。 如果有任何一个参与者反馈“不能提交”或超时未响应，协调者向所有参与者发送回滚（rollback）请求，参与者回滚本地事务，释放资源。 + - 100% Full flowchart TD A[事务发起者发起TCC事务] --\u003e B{各参与者Try阶段\n预留资源} B -- 所有Try成功 --\u003e C[各参与者Confirm阶段\n正式提交] C --\u003e D[事务完成] B -- 有Try失败或超时 --\u003e E[各参与者Cancel阶段\n释放资源/回滚] E --\u003e D 优缺点 优点：实现简单，能保证强一致性。 缺点：同步阻塞，性能较低；协调者单点故障会导致参与者长时间锁定资源，存在阻塞和脑裂风险。 2PC 常用于分布式数据库、消息队列等场景。实际生产环境中，通常会用 TCC、SAGA 等更灵活的方案来替代 2PC。\n3PC（三阶段提交） 三阶段提交（Three-Phase Commit, 3PC）是在 2PC 基础上改进的一种分布式事务协议，主要目的是减少协调者单点故障导致的阻塞和脑裂风险。3PC 将提交过程分为三个阶段：\n","tags":null,"title":"分布式事务"},{"categories":null,"content":"堆内存泄漏 长生命周期的对象，持有短生命周期对象的引用，导致后者无法被 GC 回收。\n我们先来简单造一个典型的错误案例。我们有一个内存cache, 然后key是object类型\nimport java.util.HashSet; import java.util.Set; import java.util.concurrent.TimeUnit; /** * 模拟由“可变哈希值”导致的内存泄漏 * 场景：对象存入 HashSet/HashMap 后，修改了参与 hashCode 计算的字段，导致无法被删除。 */ public class MutableKeyLeakDemo { // 1. 静态容器，模拟全局缓存 private static final Set\u0026amp;lt;KeyObject\u0026amp;gt; LEAK_SET = new HashSet\u0026amp;lt;\u0026amp;gt;(); /** * 定义一个“不守规矩”的 Key 对象 */ static class KeyObject { private int id; // 为了让内存占用明显，每个对象携带 50KB 数据 private byte[] payload = new byte[50 * 1024]; public KeyObject(int id) { this.id = id; } // 【致命操作】提供了一个 Setter 修改参与 …","date":"2024-11-23","permalink":"https://qtopie.github.io/notes/java/jvm-memory-leaks/","summary":"堆内存泄漏 长生命周期的对象，持有短生命周期对象的引用，导致后者无法被 GC 回收。\n我们先来简单造一个典型的错误案例。我们有一个内存cache, 然后key是object类型\nimport java.util.HashSet; import java.util.Set; import java.util.concurrent.TimeUnit; /** * 模拟由“可变哈希值”导致的内存泄漏 * 场景：对象存入 HashSet/HashMap 后，修改了参与 hashCode 计算的字段，导致无法被删除。 */ public class MutableKeyLeakDemo { // 1. 静态容器，模拟全局缓存 private static final Set\u0026lt;KeyObject\u0026gt; LEAK_SET = new HashSet\u0026lt;\u0026gt;(); /** * 定义一个“不守规矩”的 Key 对象 */ static class KeyObject { private int id; // 为了让内存占用明显，每个对象携带 50KB 数据 private byte[] payload = new byte[50 * 1024]; public KeyObject(int id) { this.id = id; } // 【致命操作】提供了一个 Setter 修改参与 Hash 计算的字段 public void setId(int id) { this.id = id; } // hashCode 依赖于 id @Override public int hashCode() { return id; } // equals 也依赖于 id @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; KeyObject keyObject = (KeyObject) o; return id == keyObject.id; } } public static void main(String[] args) throws InterruptedException { System.out.println(\u0026#34;=== 应用程序启动 ===\u0026#34;); System.out.println(\u0026#34;请打开 VisualVM 连接... (等待 10 秒)\u0026#34;); TimeUnit.SECONDS.sleep(10); System.out.println(\u0026#34;=== 开始测试：存入 -\u0026gt; 修改 -\u0026gt; 尝试删除 ===\u0026#34;); for (int i = 0; i \u0026lt; 10000; i++) { // A. 创建对象，此时 id = i (比如 0) KeyObject key = new KeyObject(i); // B. 放入 Set // Set 根据 hashCode(0) 把它放到了 \u0026#34;桶A\u0026#34; 里 LEAK_SET.add(key); // C. 【关键泄漏点】修改 id // 此时对象的 id 变成了 99999+i，hashCode 也变了！ key.setId(i + 99999); // D. 尝试删除这个对象 // Set 调用 key.hashCode()，算出的是新 ID 对应的 \u0026#34;桶B\u0026#34;。 // Set 去 \u0026#34;桶B\u0026#34; 里找，当然找不到（因为对象其实还在 \u0026#34;桶A\u0026#34; 里躺着）。 boolean success = LEAK_SET.remove(key); // 验证是否删除失败 if (success) { System.out.println(\u0026#34;删除成功 (这行代码永远不会执行)\u0026#34;); } // 每 500 个打印一次日志，避免刷屏 if (i % 500 == 0) { System.out.println(\u0026#34;尝试删除第 \u0026#34; + i + \u0026#34; 个对象 | 删除结果: \u0026#34; + (success ? \u0026#34;成功\u0026#34; : \u0026#34;失败\u0026#34;) + \u0026#34; | 当前 Set 大小: \u0026#34; + LEAK_SET.size()); TimeUnit.MILLISECONDS.sleep(20); // 稍微停顿，观察内存曲线 } } System.out.println(\u0026#34;=== 循环结束 ===\u0026#34;); // 理论上我们执行了 10000 次 add 和 10000 次 remove，Set 应该是空的。 // 但实际上... System.out.println(\u0026#34;预期 Set 大小: 0\u0026#34;); System.out.println(\u0026#34;实际 Set 大小: \u0026#34; + LEAK_SET.size()); System.out.println(\u0026#34;内存未释放，因为这些对象在 Set 中迷失了。\u0026#34;); // 保持运行以便 Dump synchronized (MutableKeyLeakDemo.class) { MutableKeyLeakDemo.class.wait(); } } } 如何避免这种泄漏？ 铁律： 放入 HashMap/HashSet 的 Key 类，其参与 hashCode 和 equals 计算的字段必须是不可变（Immutable）的（即用 final 修饰）。\n","tags":null,"title":"JVM内存泄漏排查"},{"categories":null,"content":" +--------+ +---------------+ | |--(A)- Authorization Request -\u0026amp;gt;| Resource | | | | Owner | | |\u0026amp;lt;-(B)-- Authorization Grant ---| | | | +---------------+ | | | | +---------------+ | |--(C)-- Authorization Grant --\u0026amp;gt;| Authorization | | Client | | Server | | |\u0026amp;lt;-(D)----- Access Token -------| | | | +---------------+ | | | | +---------------+ | |--(E)----- Access Token ------\u0026amp;gt;| Resource | | | | Server | | |\u0026amp;lt;-(F)--- Protected Resource ---| | +--------+ +---------------+ 相关安全问题 CSRF (Cross Site Request Forgery) CSRF（Cross-site request forgery，跨站请求伪造），也被称为“One Click Attack”或Session …","date":"2024-09-23","permalink":"https://qtopie.github.io/notes/system-design/oauth/","summary":" +--------+ +---------------+ | |--(A)- Authorization Request -\u0026gt;| Resource | | | | Owner | | |\u0026lt;-(B)-- Authorization Grant ---| | | | +---------------+ | | | | +---------------+ | |--(C)-- Authorization Grant --\u0026gt;| Authorization | | Client | | Server | | |\u0026lt;-(D)----- Access Token -------| | | | +---------------+ | | | | +---------------+ | |--(E)----- Access Token ------\u0026gt;| Resource | | | | Server | | |\u0026lt;-(F)--- Protected Resource ---| | +--------+ +---------------+ 相关安全问题 CSRF (Cross Site Request Forgery) CSRF（Cross-site request forgery，跨站请求伪造），也被称为“One Click Attack”或Session Riding，通常缩写为CSRF或者XSRF，是基于客户端操作的请求伪造，是一种对网站的恶意利用。\n","tags":null,"title":"OAuth"},{"categories":null,"content":"线程的状态 参考定义 java.lang.Thread.State\npublic enum State { /** * Thread state for a thread which has not yet started. */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * {@link Object#wait() …","date":"2024-09-11","permalink":"https://qtopie.github.io/notes/java/thread/","summary":"线程的状态 参考定义 java.lang.Thread.State\npublic enum State { /** * Thread state for a thread which has not yet started. */ NEW, /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ RUNNABLE, /** * Thread state for a thread blocked waiting for a monitor lock. * A thread in the blocked state is waiting for a monitor lock * to enter a synchronized block/method or * reenter a synchronized block/method after calling * {@link Object#wait() Object.wait}. */ BLOCKED, /** * Thread state for a waiting thread. * A thread is in the waiting state due to calling one of the * following methods: * \u0026lt;ul\u0026gt; * \u0026lt;li\u0026gt;{@link Object#wait() Object.wait} with no timeout\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link #join() Thread.join} with no timeout\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link LockSupport#park() LockSupport.park}\u0026lt;/li\u0026gt; * \u0026lt;/ul\u0026gt; * * \u0026lt;p\u0026gt;A thread in the waiting state is waiting for another thread to * perform a particular action. * * For example, a thread that has called {@code Object.wait()} * on an object is waiting for another thread to call * {@code Object.notify()} or {@code Object.notifyAll()} on * that object. A thread that has called {@code Thread.join()} * is waiting for a specified thread to terminate. */ WAITING, /** * Thread state for a waiting thread with a specified waiting time. * A thread is in the timed waiting state due to calling one of * the following methods with a specified positive waiting time: * \u0026lt;ul\u0026gt; * \u0026lt;li\u0026gt;{@link #sleep Thread.sleep}\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link Object#wait(long) Object.wait} with timeout\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link #join(long) Thread.join} with timeout\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link LockSupport#parkNanos LockSupport.parkNanos}\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link LockSupport#parkUntil LockSupport.parkUntil}\u0026lt;/li\u0026gt; * \u0026lt;/ul\u0026gt; */ TIMED_WAITING, /** * Thread state for a terminated thread. * The thread has completed execution. */ TERMINATED; } + - 100% Full stateDiagram [*] --\u003e New New --\u003e Runnable : start() Runnable --\u003e Blocked : acquire monitor lock Runnable --\u003e Waiting : wait(), join(), park() Runnable --\u003e Timed Waiting : wait(timeout), join(timeout), parkNanos(timeout) Blocked --\u003e Runnable : obtain monitor lock Waiting --\u003e Runnable : signaled or interrupted Timed Waiting --\u003e Runnable : time elapses Runnable --\u003e Terminated : run() completes waiting vs blocked blocked: 线程试图获取一个被其他线程持有的锁（monitor），但获取失败，导致线程被阻塞 被动进入 blocked 状态的\n","tags":null,"title":"JVM线程分析"},{"categories":null,"content":"缓存的模式 模式 工作方式 优点 缺点 旁路缓存 (Cache-Aside) 读: 应用查缓存，无则查DB并入缓存。写: 直接更新DB。 简单，耦合度低。 首次读取延迟；数据不一致风险（写后立即读到旧缓存）。 读穿 (Read-Through) 读: 应用请求缓存，缓存未命中时自行从DB加载。 应用代码简洁，无需处理DB逻辑。 需缓存提供程序支持；缓存层责任重。 写穿 (Write-Through) 写: 应用写入缓存，缓存立即同步写入DB。 数据强一致性。 写入延迟较高（等待双写完成）。 回写 (Write-Back / Write-Behind) 写: 应用写入缓存后立即返回，缓存异步批量写入DB。 写入性能极高。 缓存崩溃时可能丢失数据；最终一致性。 环绕写 (Write-Around) 写: 直接写入DB，绕过缓存。读: 遵循旁路缓存模式。 避免低频读数据污染缓存；适合写多读少。 读取新写入数据时延迟高（首次必未命中）；不适合写后立即读。 参考 https://hazelcast.com/blog/a-hitchhikers-guide-to-caching-patterns/ ","date":"2024-09-07","permalink":"https://qtopie.github.io/notes/system-design/cache-expiration/","summary":"缓存的模式 模式 工作方式 优点 缺点 旁路缓存 (Cache-Aside) 读: 应用查缓存，无则查DB并入缓存。写: 直接更新DB。 简单，耦合度低。 首次读取延迟；数据不一致风险（写后立即读到旧缓存）。 读穿 (Read-Through) 读: 应用请求缓存，缓存未命中时自行从DB加载。 应用代码简洁，无需处理DB逻辑。 需缓存提供程序支持；缓存层责任重。 写穿 (Write-Through) 写: 应用写入缓存，缓存立即同步写入DB。 数据强一致性。 写入延迟较高（等待双写完成）。 回写 (Write-Back / Write-Behind) 写: 应用写入缓存后立即返回，缓存异步批量写入DB。 写入性能极高。 缓存崩溃时可能丢失数据；最终一致性。 环绕写 (Write-Around) 写: 直接写入DB，绕过缓存。读: 遵循旁路缓存模式。 避免低频读数据污染缓存；适合写多读少。 读取新写入数据时延迟高（首次必未命中）；不适合写后立即读。 参考 https://hazelcast.com/blog/a-hitchhikers-guide-to-caching-patterns/ ","tags":null,"title":"缓存过期"},{"categories":null,"content":"链表反转：深入浅出 链表反转是什么？ 链表反转，顾名思义，就是将一个链表的节点顺序颠倒过来。例如，原本的链表是1-\u0026amp;gt;2-\u0026amp;gt;3-\u0026amp;gt;4，反转后就变成4-\u0026amp;gt;3-\u0026amp;gt;2-\u0026amp;gt;1。\n为什么需要链表反转？ 链表反转是链表操作中一个非常基础且常见的操作，它在很多算法和数据结构中都有应用，比如：\n栈的实现： 链表反转可以用来实现一个栈的数据结构。 队列的实现： 链表反转可以用来实现一个队列的数据结构。 算法优化： 有些算法中，通过链表反转可以优化时间或空间复杂度。 链表反转的实现 迭代法 迭代法是实现链表反转最常用的方法。其核心思想是：\n初始化三个指针： prev: 指向当前节点的前一个节点 curr: 指向当前节点 next: 指向当前节点的后一个节点 遍历链表： 将 curr 的 next 指针指向 prev，实现反转 将 prev 和 curr 指针都向后移动一位 返回新的头节点： 遍历结束后，curr 指向新的头节点 func reverseList(head *ListNode) *ListNode { // 初始化第一个前驱指针指向null, 即为末端 var prev *ListNode for curr:= head; curr != nil; { // 先用临时指针next保存下一个开始位置 next := curr.Next; // 将当前指针指 …","date":"2024-09-07","permalink":"https://qtopie.github.io/notes/codejam/list/reverse-list/","summary":"链表反转：深入浅出 链表反转是什么？ 链表反转，顾名思义，就是将一个链表的节点顺序颠倒过来。例如，原本的链表是1-\u0026gt;2-\u0026gt;3-\u0026gt;4，反转后就变成4-\u0026gt;3-\u0026gt;2-\u0026gt;1。\n为什么需要链表反转？ 链表反转是链表操作中一个非常基础且常见的操作，它在很多算法和数据结构中都有应用，比如：\n栈的实现： 链表反转可以用来实现一个栈的数据结构。 队列的实现： 链表反转可以用来实现一个队列的数据结构。 算法优化： 有些算法中，通过链表反转可以优化时间或空间复杂度。 链表反转的实现 迭代法 迭代法是实现链表反转最常用的方法。其核心思想是：\n初始化三个指针： prev: 指向当前节点的前一个节点 curr: 指向当前节点 next: 指向当前节点的后一个节点 遍历链表： 将 curr 的 next 指针指向 prev，实现反转 将 prev 和 curr 指针都向后移动一位 返回新的头节点： 遍历结束后，curr 指向新的头节点 func reverseList(head *ListNode) *ListNode { // 初始化第一个前驱指针指向null, 即为末端 var prev *ListNode for curr:= head; curr != nil; { // 先用临时指针next保存下一个开始位置 next := curr.Next; // 将当前指针指反转 curr.Next = prev; // 移动指针 prev = curr; curr = next; } return prev; } 递归法 递归法是一种更加优雅的实现方式。其核心思想是：\n","tags":null,"title":"链表反转"},{"categories":["notes"],"content":"我想通过小红书资料做一份旅游攻略，以下是操作步骤。\n首先，使用chrome-devtools-mcp打开小红书，网页版https://www.xiaohongshu.com/explore\n获取登录态, 等待小红书登录页面，等待用户扫码。\n用户扫码登录成功后，页面会刷新\n然后用解析网页内容，找到搜索框，输入关键字\u0026amp;quot;深圳到中山旅游攻略\u0026amp;quot;，点击搜索然后抓取结果。\n最后使用LLM总结网页内容.\n你可以使用chrome-devtools-mcp完成页面抓取","date":"2024-05-23","permalink":"https://qtopie.github.io/notes/ai/rednote-crawler/","summary":"我想通过小红书资料做一份旅游攻略，以下是操作步骤。\n首先，使用chrome-devtools-mcp打开小红书，网页版https://www.xiaohongshu.com/explore\n获取登录态, 等待小红书登录页面，等待用户扫码。\n用户扫码登录成功后，页面会刷新\n然后用解析网页内容，找到搜索框，输入关键字\u0026quot;深圳到中山旅游攻略\u0026quot;，点击搜索然后抓取结果。\n最后使用LLM总结网页内容.\n你可以使用chrome-devtools-mcp完成页面抓取\n","tags":["travel","zhongshan","shenzhen","xiaohongshu"],"title":"深圳到中山旅游攻略 (基于小红书总结)"},{"categories":["iot"],"content":"目标 使用开源软件和米家智能硬件，实现简单的智能家居系统\n采用米家智能硬件的原因是, 小米智能家居做的比较早（也许是起初推广的更好，刚接触智能家居的时候就用的小米）, 另外一点是小米智能硬件确实物美价廉，在国外也很受欢迎，Github上也有很多相关项目.\n环境和设备 RaspberryPi 4 (4GB版本) Ubuntu arm64 树莓派版本 安装HomeAssistant 这里使用Ubuntu而不是Raspbian的一个原因是Ubuntu官方软件包更新更快（比如raspbian当前为3.7而hass需要3.8+版本)， 且自己笔记本一直用Ubuntu，统一发行版使用起来更加方便\nsudo pip3 install homeassistant 如果下载很慢，可以考虑使用pypi镜像源\n编辑/etc/pip.conf (使用豆瓣源）\n[global] index-url = https://pypi.douban.com/simple 设置开机自启动 创建systemd service unit文件 systemctl --user edit --full --force homeassistant.service 加入以下内容\n[Unit] Description=Home Assistant After=network.target [Service] Type=simple …","date":"2021-09-28","permalink":"https://qtopie.github.io/notes/iot/rpi/homeassistant/","summary":"目标 使用开源软件和米家智能硬件，实现简单的智能家居系统\n采用米家智能硬件的原因是, 小米智能家居做的比较早（也许是起初推广的更好，刚接触智能家居的时候就用的小米）, 另外一点是小米智能硬件确实物美价廉，在国外也很受欢迎，Github上也有很多相关项目.\n环境和设备 RaspberryPi 4 (4GB版本) Ubuntu arm64 树莓派版本 安装HomeAssistant 这里使用Ubuntu而不是Raspbian的一个原因是Ubuntu官方软件包更新更快（比如raspbian当前为3.7而hass需要3.8+版本)， 且自己笔记本一直用Ubuntu，统一发行版使用起来更加方便\nsudo pip3 install homeassistant 如果下载很慢，可以考虑使用pypi镜像源\n编辑/etc/pip.conf (使用豆瓣源）\n[global] index-url = https://pypi.douban.com/simple 设置开机自启动 创建systemd service unit文件 systemctl --user edit --full --force homeassistant.service 加入以下内容\n[Unit] Description=Home Assistant After=network.target [Service] Type=simple ExecStart=/home/ubuntu/.local/bin/hass Restart=on-failure RestartSec=5 [Install] WantedBy=default.target 设置用户自动登录 安装raspi-config, 然后配置 1. System Options -\u0026gt; S5 Boot / Auto Login -\u0026gt; B2 Console Autologin\n会生成/etc/systemd/system/getty@tty1.service.d/autologin.conf, 内容如下\n","tags":["homeassistant","raspberrypi"],"title":"树莓派和HomeAssistant"},{"categories":null,"content":"将VIM打造为Go开发利器\n平时一般使用VSCode编程，最近为了更好地刷leetcode，又换回了vim。发现笔记本小屏幕 使用vscode zen-mode沉浸式看代码很爽以后，也喜欢上了使用vim写代码, 快捷键方便、稳 定高效、功能纯粹（极简主义）。研究了一番后，发现其可行性，便整理了一下。\n主要插件 完整列表\nPlug \u0026amp;#39;scrooloose/nerdtree\u0026amp;#39; Plug \u0026amp;#39;preservim/tagbar\u0026amp;#39; Plug \u0026amp;#39;vim-airline/vim-airline\u0026amp;#39; Plug \u0026amp;#39;vim-airline/vim-airline-themes\u0026amp;#39; Plug \u0026amp;#39;fatih/vim-go\u0026amp;#39;, { \u0026amp;#39;do\u0026amp;#39;: \u0026amp;#39;:GoUpdateBinaries\u0026amp;#39; } Plug \u0026amp;#39;Shougo/ddc.vim\u0026amp;#39; Plug \u0026amp;#39;vim-denops/denops.vim\u0026amp;#39; Plug \u0026amp;#39;buoto/gotests-vim\u0026amp;#39; Plug \u0026amp;#39;SirVer/ultisnips\u0026amp;#39; Plug \u0026amp;#39;honza/vim-snippets\u0026amp;#39; vim-go vim-go是目前主要且流行的针对go的vim插件，视频[Hacking …","date":"2021-08-28","permalink":"https://qtopie.github.io/notes/vim/vim-go/","summary":"将VIM打造为Go开发利器\n平时一般使用VSCode编程，最近为了更好地刷leetcode，又换回了vim。发现笔记本小屏幕 使用vscode zen-mode沉浸式看代码很爽以后，也喜欢上了使用vim写代码, 快捷键方便、稳 定高效、功能纯粹（极简主义）。研究了一番后，发现其可行性，便整理了一下。\n主要插件 完整列表\nPlug \u0026#39;scrooloose/nerdtree\u0026#39; Plug \u0026#39;preservim/tagbar\u0026#39; Plug \u0026#39;vim-airline/vim-airline\u0026#39; Plug \u0026#39;vim-airline/vim-airline-themes\u0026#39; Plug \u0026#39;fatih/vim-go\u0026#39;, { \u0026#39;do\u0026#39;: \u0026#39;:GoUpdateBinaries\u0026#39; } Plug \u0026#39;Shougo/ddc.vim\u0026#39; Plug \u0026#39;vim-denops/denops.vim\u0026#39; Plug \u0026#39;buoto/gotests-vim\u0026#39; Plug \u0026#39;SirVer/ultisnips\u0026#39; Plug \u0026#39;honza/vim-snippets\u0026#39; vim-go vim-go是目前主要且流行的针对go的vim插件，视频[Hacking with Andrew and Brad: an HTTP/2 client] (https://www.youtube.com/watch?v=yG-UaBJXZ80)中两位大佬用vim 进行pair编程使用了就是该插件。\nPS: 当时看了这视频后，不禁佩服两位大佬的代码功底，也刷新了使用vim开发实际项目的认知, 原来使用vim写代码 还可以比eclipse/idea/vscode更顺手, 也可以装酷了：》 自己用vim一般也只是用来改改配置，写写简单的脚本，还没尝试过使用它进行正经的项目开发。 虽然以前做过尝试，不过借助vim-go插件和LSP，这成为了真正的可能。\n虽然vim-go原作者已不再参与维护该项目，但已交给社区的另外两人负责，仍然在活跃更新 https://arslan.io/2018/10/09/taking-an-indefinite-sabbatical-from-my-projects/\ngovim govim是一个有意思的vim插件，它尝试使用go语言编写vim插件.\n作为一个后起之秀，它的功能并没有vim-go完善，比如debug功能（这对我来说是一个核心诉求）, 从实际使用体验来看，也不如vim-go稳定。从个人角度而言, vim, go我都喜欢，但使用vim script 编写插件应该有更好的兼容性(vim对go的支持还没有那么的好，对lua和python的支持更佳）, 所以还是选择vim-go插件。\n配置 \u0026#34;.vim/after/ftplugin/go.vim \u0026#34; shortcut like vscode nnoremap \u0026lt;buffer\u0026gt; \u0026lt;silent\u0026gt; \u0026lt;F2\u0026gt; :hide GoRename\u0026lt;CR\u0026gt; nnoremap \u0026lt;buffer\u0026gt; \u0026lt;silent\u0026gt; \u0026lt;F4\u0026gt; :hide GoBuild\u0026lt;CR\u0026gt; nnoremap \u0026lt;buffer\u0026gt; \u0026lt;silent\u0026gt; \u0026lt;F5\u0026gt; :hide GoDebugStart\u0026lt;CR\u0026gt; nnoremap \u0026lt;buffer\u0026gt; \u0026lt;silent\u0026gt; \u0026lt;C-F5\u0026gt; :hide GoRun\u0026lt;CR\u0026gt; nnoremap \u0026lt;buffer\u0026gt; \u0026lt;silent\u0026gt; \u0026lt;S-F11\u0026gt; :hide GoDebugStepOut\u0026lt;CR\u0026gt; nnoremap \u0026lt;buffer\u0026gt; \u0026lt;silent\u0026gt; \u0026lt;F12\u0026gt; :hide GoDebugStop\u0026lt;CR\u0026gt; ","tags":null,"title":"vim-go"},{"categories":null,"content":"This is a testing post for writing markdown with latex\n排列组合 独立重复性事件 \\: n^m 从n个不同物品中取一个物品，每次取一个，取m次的结果（考虑先后顺序）\nn^m = n \\times n \\times n ... \\times n \\tag 1 \\: A_n^n 从n个不同物品中取一个物品，每次取一个, 不放回，取n次(完）的结果.（考虑先后顺序）\n第一次有n个结果， 依据独立性事件，第二次有n-1中结果，以此类推\nA_n^n = n(n-1)(n-2)... \\times 2 \\times 1 \\tag 2 \\: A_n^m 从n个不同物品中取一个物品，每次取一个, 不放回，取m次(可能不取）的结果.（考虑先后顺序），未取到的结果有\\: A_{n-m}^{n-m}种\nA_n^m = \\frac{A_n^n}{A_{n-m}^{n-m}} = n(n-1)(n-2)...(n-m+1) \\tag 3 \\: C_n^m 从n个不同物品中取一个物品，每次取一个, 不放回，取m次(可能不取）的结果.（不考虑先后顺序）\nC_n^m = \\frac{A_n^m}{A_m^m} = \\frac{n!}{m! \\times (n-m)!} \\tag 4 例子 3 * 4 的格子, 从左上走到右下角，只能往下或者往右。\nstart …","date":"2021-07-15","permalink":"https://qtopie.github.io/notes/algorithms/combination-permutation/","summary":"This is a testing post for writing markdown with latex\n排列组合 独立重复性事件 \\: n^m 从n个不同物品中取一个物品，每次取一个，取m次的结果（考虑先后顺序）\nn^m = n \\times n \\times n ... \\times n \\tag 1 \\: A_n^n 从n个不同物品中取一个物品，每次取一个, 不放回，取n次(完）的结果.（考虑先后顺序）\n第一次有n个结果， 依据独立性事件，第二次有n-1中结果，以此类推\nA_n^n = n(n-1)(n-2)... \\times 2 \\times 1 \\tag 2 \\: A_n^m 从n个不同物品中取一个物品，每次取一个, 不放回，取m次(可能不取）的结果.（考虑先后顺序），未取到的结果有\\: A_{n-m}^{n-m}种\nA_n^m = \\frac{A_n^n}{A_{n-m}^{n-m}} = n(n-1)(n-2)...(n-m+1) \\tag 3 \\: C_n^m 从n个不同物品中取一个物品，每次取一个, 不放回，取m次(可能不取）的结果.（不考虑先后顺序）\nC_n^m = \\frac{A_n^m}{A_m^m} = \\frac{n!}{m! \\times (n-m)!} \\tag 4 例子 3 * 4 的格子, 从左上走到右下角，只能往下或者往右。\n","tags":["algorithm"],"title":"排列组合"},{"categories":null,"content":"Based on my experiences on Ubuntu\nSoftware Package Management set up proxy for apt sudo bash -c \u0026amp;#39;cat \u0026amp;lt;\u0026amp;lt; EOF \u0026amp;gt; /etc/apt/apt.conf.d/proxy.conf Acquire { HTTP::proxy \u0026amp;#34;http://127.0.0.1:8118\u0026amp;#34;; HTTPS::proxy \u0026amp;#34;http://127.0.0.1:8118\u0026amp;#34;; } EOF\u0026amp;#39; System Monitoring Basic Info # memory free -m # get process id ps aux | grep \u0026amp;lt;pattern\u0026amp;gt; # view startup command of process ps flww -p [PID] # check cpu usage top -p \u0026amp;lt;pid\u0026amp;gt; # list by threads top -H -p \u0026amp;lt;pid\u0026amp;gt; # disk df -h # networks iostat Performance Testing Network Bindwidth Testing There are two common means to achive …","date":"2021-05-02","permalink":"https://qtopie.github.io/notes/linux/linux-cmd-handbook/","summary":"Based on my experiences on Ubuntu\nSoftware Package Management set up proxy for apt sudo bash -c \u0026#39;cat \u0026lt;\u0026lt; EOF \u0026gt; /etc/apt/apt.conf.d/proxy.conf Acquire { HTTP::proxy \u0026#34;http://127.0.0.1:8118\u0026#34;; HTTPS::proxy \u0026#34;http://127.0.0.1:8118\u0026#34;; } EOF\u0026#39; System Monitoring Basic Info # memory free -m # get process id ps aux | grep \u0026lt;pattern\u0026gt; # view startup command of process ps flww -p [PID] # check cpu usage top -p \u0026lt;pid\u0026gt; # list by threads top -H -p \u0026lt;pid\u0026gt; # disk df -h # networks iostat Performance Testing Network Bindwidth Testing There are two common means to achive this\n","tags":null,"title":"Linux Command-line Handbook"},{"categories":["tool"],"content":"VIM 安装 由于debian发行版维护的vim包还未升级到最新版本，但govim需要较高版本的vim。故选择手动编译安装。这里直接选择最新版本8.2， 对应于最新的git tag版本， 8.2版本有一些实用性的功能。\n环境\nUbuntu 19.10 5.3.0-24-generic x84_64 构建及安装过程 安装构建工具链 sudo apt update \u0026amp;amp;\u0026amp;amp; sudo apt install -y git build-essential 拉取源码 git clone https://github.com/vim/vim.git # 切换到你想构建的tag git checkout v8.2.0369 开始构建 #cd src #make distclean # if you build Vim before ./configure --with-features=huge \\ --enable-multibyte \\ --enable-python3interp=yes \\ --with-python3-config-dir=$(python3-config --configdir) \\ --enable-perlinterp=yes \\ --enable-luainterp=yes \\ --enable-cscope \\ …","date":"2021-04-06","permalink":"https://qtopie.github.io/notes/vim/build-and-install-latest-vim/","summary":"VIM 安装 由于debian发行版维护的vim包还未升级到最新版本，但govim需要较高版本的vim。故选择手动编译安装。这里直接选择最新版本8.2， 对应于最新的git tag版本， 8.2版本有一些实用性的功能。\n环境\nUbuntu 19.10 5.3.0-24-generic x84_64 构建及安装过程 安装构建工具链 sudo apt update \u0026amp;\u0026amp; sudo apt install -y git build-essential 拉取源码 git clone https://github.com/vim/vim.git # 切换到你想构建的tag git checkout v8.2.0369 开始构建 #cd src #make distclean # if you build Vim before ./configure --with-features=huge \\ --enable-multibyte \\ --enable-python3interp=yes \\ --with-python3-config-dir=$(python3-config --configdir) \\ --enable-perlinterp=yes \\ --enable-luainterp=yes \\ --enable-cscope \\ --prefix=/usr/local make VIMRUNTIMEDIR=/usr/local/share/vim/vim82 sudo apt install checkinstall sudo checkinstall checkinstall执行完后，会安装到/usr/local/bin/vim 即可。\n","tags":["vim"],"title":"VIM安装笔记"},{"categories":["diy"],"content":"最近购买了一个树莓派4B 4G内存版，替换了旧的Model3 (强迫症犯了，就为了换成type c口，但因为电源适配问题还是老老实实地又买了官方电源适配器）\n树莓派4B相对3B性能提高不少，但是随之功耗和发热也上去了。 于是给它整了个金属外壳\n但是依旧烫得厉害，可能是我手动overlock了。开风扇的话，又有点吵，晚上影响睡觉。\n所以又买了一些排线和一个电磁继电器来实现自动通过风扇控制CPU等芯片温度。\n主要原理 获取GPU温度 vcgencmd\nvcgencmd measure_temp 获取CPU温度 cpu=$(\u0026amp;lt;/sys/class/thermal/thermal_zone0/temp) echo \u0026amp;#34;$((cpu/1000)) c\u0026amp;#34; 代码实现 网上已经有不少python版本的实现，但作为一个go粉，当然选择用go来实现了，正好练习一下gobot包的使用\npackage main import ( \u0026amp;#34;time\u0026amp;#34; \u0026amp;#34;gobot.io/x/gobot\u0026amp;#34; \u0026amp;#34;gobot.io/x/gobot/drivers/gpio\u0026amp;#34; \u0026amp;#34;gobot.io/x/gobot/platforms/raspi\u0026amp;#34; \u0026amp;#34;io/ioutil\u0026amp;#34; \u0026amp;#34;log\u0026amp;#34; \u0026amp;#34;strconv\u0026amp;#34; …","date":"2020-08-03","permalink":"https://qtopie.github.io/notes/iot/rpi/fan-and-tempature/","summary":"最近购买了一个树莓派4B 4G内存版，替换了旧的Model3 (强迫症犯了，就为了换成type c口，但因为电源适配问题还是老老实实地又买了官方电源适配器）\n树莓派4B相对3B性能提高不少，但是随之功耗和发热也上去了。 于是给它整了个金属外壳\n但是依旧烫得厉害，可能是我手动overlock了。开风扇的话，又有点吵，晚上影响睡觉。\n所以又买了一些排线和一个电磁继电器来实现自动通过风扇控制CPU等芯片温度。\n主要原理 获取GPU温度 vcgencmd\nvcgencmd measure_temp 获取CPU温度 cpu=$(\u0026lt;/sys/class/thermal/thermal_zone0/temp) echo \u0026#34;$((cpu/1000)) c\u0026#34; 代码实现 网上已经有不少python版本的实现，但作为一个go粉，当然选择用go来实现了，正好练习一下gobot包的使用\npackage main import ( \u0026#34;time\u0026#34; \u0026#34;gobot.io/x/gobot\u0026#34; \u0026#34;gobot.io/x/gobot/drivers/gpio\u0026#34; \u0026#34;gobot.io/x/gobot/platforms/raspi\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;strings\u0026#34; ) func main() { low, high := 50, 58 r := raspi.NewAdaptor() sw := gpio.NewDirectPinDriver(r, \u0026#34;18\u0026#34;) work := func() { gobot.Every(5*time.Second, func() { t := readCpuTemp() log.Println(\u0026#34;Temp\u0026#34;, t/1000) if t \u0026lt; low*1000 { sw.Off() } if t \u0026gt; high*1000 { // turn on only ater 7 oclock if h, _, _ := time.Now().Clock(); h \u0026gt; 7 { sw.On() } } }) } robot := gobot.NewRobot(\u0026#34;blinkBot\u0026#34;, []gobot.Connection{r}, []gobot.Device{sw}, work, ) robot.Start() } func readCpuTemp() int { var na = -274150 // set not valid value to -274.15C dat, err := ioutil.ReadFile(\u0026#34;/sys/class/thermal/thermal_zone0/temp\u0026#34;) if err != nil { log.Println(err) return na } s := strings.TrimSuffix(string(dat), \u0026#34;\\n\u0026#34;) t, err := strconv.Atoi(s) if err != nil { log.Println(err) return na } return t } 实现的效果是，当温度高于58度时，启动风扇；温度低于50度时关闭风扇。(风扇一直不停转，大概也只能到45度左右，可能深圳有点热）\n","tags":["raspberrypi","iot"],"title":"自动控制风扇温度"},{"categories":["diy"],"content":"Cloudcone是2017年成立于美国的一家主机供应商。继vultr变得“不靠谱”和低价vm资源经常“售尽”的情况下，我转而使用cloudcone提供的vps服务用于日常学习和开发。\n除了支持按小时计费、提供更换IP服务及支持支付宝/paypal等灵活的支付方式外，我最看重的是，它的价格能做到真正的弹性，即在vm关机状态不计费CPU/内存等费用,比online费用大概减半。\n类似于其他云供应商平台，cloudcone还提供了开放的API来管理云主机。\n这里为了方便使用和合理控制资源，自己便用go写了一个小程序\n代码实现 主要逻辑如下，通过cloudcone 提供的API。每天晚上23左右关机，次日早晨7点左右启动 如果调用失败的话，会再次重试一次。(如果依然不行的话，就当运气不好了:\u0026amp;lt;）\n以下是草稿版本代码\nsecret.go package main var ( // 配置相关信息,这里我填写的是假的啦 serverID = 123456 appSecret = \u0026amp;#34;Q2aQr9323QE233r2\u0026amp;#34; hashCode = \u0026amp;#34;zXqV22222222222222222222222222222222225bL\u0026amp;#34; ) serverID可以在compute菜单控制面板下查看，或查看浏览器url里的参数。\nappSecret和hashCode访问 …","date":"2020-07-18","permalink":"https://qtopie.github.io/posts/diy/cloudcone-save-costs/","summary":"Cloudcone是2017年成立于美国的一家主机供应商。继vultr变得“不靠谱”和低价vm资源经常“售尽”的情况下，我转而使用cloudcone提供的vps服务用于日常学习和开发。\n除了支持按小时计费、提供更换IP服务及支持支付宝/paypal等灵活的支付方式外，我最看重的是，它的价格能做到真正的弹性，即在vm关机状态不计费CPU/内存等费用,比online费用大概减半。\n类似于其他云供应商平台，cloudcone还提供了开放的API来管理云主机。\n这里为了方便使用和合理控制资源，自己便用go写了一个小程序\n代码实现 主要逻辑如下，通过cloudcone 提供的API。每天晚上23左右关机，次日早晨7点左右启动 如果调用失败的话，会再次重试一次。(如果依然不行的话，就当运气不好了:\u0026lt;）\n以下是草稿版本代码\nsecret.go package main var ( // 配置相关信息,这里我填写的是假的啦 serverID = 123456 appSecret = \u0026#34;Q2aQr9323QE233r2\u0026#34; hashCode = \u0026#34;zXqV22222222222222222222222222222222225bL\u0026#34; ) serverID可以在compute菜单控制面板下查看，或查看浏览器url里的参数。\nappSecret和hashCode访问https://app.cloudcone.com/user/api创建即可。\nmain.go /* * cloudcone api https://api.cloudcone.com/ */ package main import ( \u0026#34;context\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/robfig/cron\u0026#34; ) // CloudconeResponse represents the API Response type CloudconeResponse struct { Status int Message string Data interface{} `json:\u0026#34;_data\u0026#34;` } const ( baseAPIURL = \u0026#34;https://api.cloudcone.com/api/v1\u0026#34; ) var ( client = \u0026amp;http.Client{} ) func main() { f, err := os.OpenFile(\u0026#34;app.log\u0026#34;, os.O_RDWR|os.O_CREATE|os.O_APPEND|os.O_TRUNC, 0644) if err != nil { log.Fatalf(\u0026#34;Error while opening file: %v\\n\u0026#34;, err) } defer f.Close() log.SetOutput(f) wg := sync.WaitGroup{} _, cancel := context.WithCancel(context.Background()) c := cron.New() // boot at 07:00 c.AddFunc(\u0026#34;0 0 7 * * *\u0026#34;, func() { log.Println(\u0026#34;booting at time\u0026#34;, time.Now()) if err := boot(); err != nil { log.Println(err) time.Sleep(15 * time.Second) // try again boot() } }) // shutdown at 23:45 c.AddFunc(\u0026#34;0 45 23 * * *\u0026#34;, func() { log.Println(\u0026#34;Shutdown at time\u0026#34;, time.Now()) if err := shutdown(); err != nil { log.Println(err) time.Sleep(15 * time.Second) // try again shutdown() } }) c.Start() wg.Add(1) go func() { defer wg.Done() os.Stdin.Read(make([]byte, 1)) // wait for Enter keystroke c.Stop() cancel() // cancel the associated context }() log.Println(\u0026#34;Running...\u0026#34;) wg.Wait() } func boot() error { // compute/:id/boot endpoint := fmt.Sprintf(\u0026#34;%s/compute/%d/%s\u0026#34;, baseAPIURL, serverID, \u0026#34;boot\u0026#34;) req, err := http.NewRequest(\u0026#34;GET\u0026#34;, endpoint, nil) if err != nil { return err } req.Header.Set(\u0026#34;App-Secret\u0026#34;, appSecret) req.Header.Set(\u0026#34;Hash\u0026#34;, hashCode) resp, err := client.Do(req) if err != nil { return err } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) if err != nil { return err } fmt.Println(string(body)) var dat CloudconeResponse if err := json.Unmarshal(body, \u0026amp;dat); err != nil { return err } if dat.Status != 1 { return errors.New(dat.Message) } log.Println(dat.Message) return nil } func shutdown() error { // compute/:id/shutdown endpoint := fmt.Sprintf(\u0026#34;%s/compute/%d/%s\u0026#34;, baseAPIURL, serverID, \u0026#34;shutdown\u0026#34;) req, err := http.NewRequest(\u0026#34;GET\u0026#34;, endpoint, nil) if err != nil { return err } req.Header.Set(\u0026#34;App-Secret\u0026#34;, appSecret) req.Header.Set(\u0026#34;Hash\u0026#34;, hashCode) resp, err := client.Do(req) if err != nil { return err } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) if err != nil { return err } var dat CloudconeResponse if err := json.Unmarshal(body, \u0026amp;dat); err != nil { return err } if dat.Status != 1 { return errors.New(dat.Message) } log.Println(dat.Message) return nil } 参考 cloudcone中文介绍 ","tags":["cloudcone"],"title":"使用API管理cloudcone主机"},{"categories":null,"content":"Yarn是Facebook、Google等主导开发的新的Javascript包管理器。（相对于npm)\n安装 sudo npm install -g yarn --registry https://registry.npm.taobao.org 这里使用了taobao npm镜像\n配置Angular Cli使用yarn 使用ng命令设置全局使用yarn\nng config -g cli.packageManager yarn 使用 添加依赖\nyarn add \u0026amp;lt;DEP_NAME\u0026amp;gt; # dev yarn add -D \u0026amp;lt;DEP_NAME\u0026amp;gt; 参考工具自带帮助文档\nyarn --help 包下载缓存 可以通过设置环境变量YARN_CACHE_FOLDER来指定缓存目录\nUbuntu下修改~/.bashrc\necho \u0026amp;#39;YARN_CACHE_FOLDER=$HOME/.yarn\u0026amp;#39; \u0026amp;gt;\u0026amp;gt; ~/.bashrc 构建速度简单比较 使用项目tour-of-heroes安装nodejs依赖。\n镜像: https://registry.npm.taobao.org\nNPM (6.14.5) Yarn (1.22.4) real\t0m26.231s real 0m14.048s user\t0m31.685s user\t0m15.415s sys …","date":"2020-06-20","permalink":"https://qtopie.github.io/notes/web/yarn/","summary":"Yarn是Facebook、Google等主导开发的新的Javascript包管理器。（相对于npm)\n安装 sudo npm install -g yarn --registry https://registry.npm.taobao.org 这里使用了taobao npm镜像\n配置Angular Cli使用yarn 使用ng命令设置全局使用yarn\nng config -g cli.packageManager yarn 使用 添加依赖\nyarn add \u0026lt;DEP_NAME\u0026gt; # dev yarn add -D \u0026lt;DEP_NAME\u0026gt; 参考工具自带帮助文档\nyarn --help 包下载缓存 可以通过设置环境变量YARN_CACHE_FOLDER来指定缓存目录\nUbuntu下修改~/.bashrc\necho \u0026#39;YARN_CACHE_FOLDER=$HOME/.yarn\u0026#39; \u0026gt;\u0026gt; ~/.bashrc 构建速度简单比较 使用项目tour-of-heroes安装nodejs依赖。\n镜像: https://registry.npm.taobao.org\nNPM (6.14.5) Yarn (1.22.4) real\t0m26.231s real 0m14.048s user\t0m31.685s user\t0m15.415s sys\t0m5.247s sys\t0m5.666s 可以看到yarn明显要快一些。 类似于npm安装依赖时创建package-lock.json文件，yarn也会创建yarn.lock文件锁定依赖。（这时安装已有包换registry会不生效)\n包下载镜像 SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ PHANTOMJS_CDNURL=https://npm.taobao.org/mirrors/phantomjs/ ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/ 可以自己搭建一个镜像，解决内网防火墙内无法下载包的问题\n使用Caddy反向代理taobao镜像 :8080 { # https://npm.taobao.org/mirrors/node-sass/ route /dist/node-sass/* { reverse_proxy https://cdn.npm.taobao.org { header_up Host {http.reverse_proxy.upstream.hostport} } } # https://npm.taobao.org/mirrors/phantomjs/ reverse_proxy /dist/phantomjs/* https://cdn.npm.taobao.org { header_up Host {http.reverse_proxy.upstream.hostport} } } node-sass 离线安装 下载地址 https://github.com/sass/node-sass/releases\n","tags":null,"title":"Yarn"},{"categories":null,"content":"相对于Linux对容器化开发的良好支持（或者说各个容器化平台和工具对Linux更好的支持），在Windows下对应用进行容器化改造时的本地构建和测试并不是很直接和方便。这里记录一下，针对不同场景的相关实践经验。\n目标 支持docker构建 支持kubernetes容器服务编排 WSL WSL (Windows subsystem for Linux) 是win10新增的一个功能，可以直接在Windows上运行本机Linux命令工具。之前大家一般会去用Cgwin (或MingGw)工具。\nWSL 提供一个名为 Bash.exe 的应用程序，启动该应用程序后，会打开一个运行 Bash shell 的 Windows 控制台。 使用 Bash 可以运行命令行 Linux 工具和应用。\n具体介绍可以参考微软提供的WSL文档。\nWSL1 并没有一个完整的Linux内核，系统调用使用Windows Pico进程使用驱动翻译成NT API模拟成Linux内核的。具体架构可以参考WSL的系统架构。\n最近更新的WSL引入了微软提供的一个完整的Linux内核，增强了文件IO性能及完整的系统调用兼容性。这也意味着我们可以通过WSL2以Linux中的方式运行docker和kubernetes （这里我们使用microk8s)。\nWindows下可直接使用WSL里Linux命令， 如netstat -an …","date":"2020-06-01","permalink":"https://qtopie.github.io/notes/cloud-native/k8s/container-dev-on-win10/","summary":"相对于Linux对容器化开发的良好支持（或者说各个容器化平台和工具对Linux更好的支持），在Windows下对应用进行容器化改造时的本地构建和测试并不是很直接和方便。这里记录一下，针对不同场景的相关实践经验。\n目标 支持docker构建 支持kubernetes容器服务编排 WSL WSL (Windows subsystem for Linux) 是win10新增的一个功能，可以直接在Windows上运行本机Linux命令工具。之前大家一般会去用Cgwin (或MingGw)工具。\nWSL 提供一个名为 Bash.exe 的应用程序，启动该应用程序后，会打开一个运行 Bash shell 的 Windows 控制台。 使用 Bash 可以运行命令行 Linux 工具和应用。\n具体介绍可以参考微软提供的WSL文档。\nWSL1 并没有一个完整的Linux内核，系统调用使用Windows Pico进程使用驱动翻译成NT API模拟成Linux内核的。具体架构可以参考WSL的系统架构。\n最近更新的WSL引入了微软提供的一个完整的Linux内核，增强了文件IO性能及完整的系统调用兼容性。这也意味着我们可以通过WSL2以Linux中的方式运行docker和kubernetes （这里我们使用microk8s)。\nWindows下可直接使用WSL里Linux命令， 如netstat -an | wsl grep :8443, 在pipe后面加上wsl即可\n适用场景 版本要求\nWin10 Version 2004, Build 19041 + （目前需要加入每月更新的预览版计划）\nHyper V支持 （需要Windows支持，同时需要设备支持硬件虚拟化)\n优点 与Windows命令窗口和文件系统无缝集成，开发起来十分方便。在当前窗口输入bash就可以进入Linux下对应的目录；同时还有VSCode Remote WSL的支持。\n安装配置 启用Hyper V和Linux子系统\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux -NoRestart Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform 然后重启\n","tags":null,"title":"win10下的应用容器化开发"},{"categories":null,"content":"这里我们使用helm 3.0+版本, 可以直接使用kube-server api, 不需要在集群安装tiler\n安装 sudo snap install helm --classic Chartmuseum repo: https://github.com/helm/chartmuseum\n本地安装\ncurl -LO https://s3.amazonaws.com/chartmuseum/release/latest/bin/linux/amd64/chartmuseum chmod +x chartmuseum sudo mv chartmuseum /usr/bin/ sudo mkdir /opt/chart \u0026amp;amp;\u0026amp;amp; sudo chown $USER /opt/chart ./chartmuseum --storage=local --storage-local-rootdir=/opt/chart 然后打开http://localhost:8080就可以看到欢迎界面\n创建和使用chart 我们以创建一个nginx chart为例。\n使用helm创建初始化配。\nmkdir app helm create chart 然后可以看到初始化的以下配置\nartificerpi@ky-laptop:~/build/app$ tree chart chart ├── …","date":"2020-05-20","permalink":"https://qtopie.github.io/notes/cloud-native/k8s/helm.zh/","summary":"这里我们使用helm 3.0+版本, 可以直接使用kube-server api, 不需要在集群安装tiler\n安装 sudo snap install helm --classic Chartmuseum repo: https://github.com/helm/chartmuseum\n本地安装\ncurl -LO https://s3.amazonaws.com/chartmuseum/release/latest/bin/linux/amd64/chartmuseum chmod +x chartmuseum sudo mv chartmuseum /usr/bin/ sudo mkdir /opt/chart \u0026amp;\u0026amp; sudo chown $USER /opt/chart ./chartmuseum --storage=local --storage-local-rootdir=/opt/chart 然后打开http://localhost:8080就可以看到欢迎界面\n创建和使用chart 我们以创建一个nginx chart为例。\n使用helm创建初始化配。\nmkdir app helm create chart 然后可以看到初始化的以下配置\nartificerpi@ky-laptop:~/build/app$ tree chart chart ├── charts ├── Chart.yaml ├── templates │ ├── deployment.yaml │ ├── _helpers.tpl │ ├── ingress.yaml │ ├── NOTES.txt │ ├── serviceaccount.yaml │ ├── service.yaml │ └── tests │ └── test-connection.yaml └── values.yaml 3 directories, 9 files 修改chart/Chart.yaml文件，将name字段改为nginx-foo\n","tags":null,"title":"Helm"},{"categories":null,"content":"Jenkins是一款比较经典而优秀的流水线构建工具（平台）。\n为了实现现代化构建方式Run configuration as Code, Jenkins引入了Blue Ocean插件。通过该插件，我们可以使用声明式语法来编写Jenkinsfile，定义流水线构建步骤 https://www.jenkins.io/zh/doc/book/pipeline/jenkinsfile/\n然而在云原生和DevOps越来越流行的今天，传统的Jenkins模式只能满足CI的构建需求。于是Jenkins团队又引入了JenkinsX, 来实现一个现代化的GitOps平台。\nemm, 不吹水了，其实我只想做个笔记,记录下折腾了很久后的才明白的安装步骤\n目标 使用jx工具在microk8s上安装jenkinsx\nhttps://jenkins-x.io/docs/labs/\n因为不喜欢使用helm2在k8s上安装tiller, 所以这里直接跳级到helm3。不过这里就要使用JenkinsX Lab里的jxl工具了。(目前是实验性版本的jenkinsx，意味着要花更多时间折腾)\n结果：暂时弃坑了，直接上tektoncd\n安装 jxl本身使用gitops方式维护JenkinsX集群\njxl 安装 从这个链接下载安装jxl工具 …","date":"2020-04-28","permalink":"https://qtopie.github.io/notes/cloud-native/cicd/jenkinsx.zh/","summary":"Jenkins是一款比较经典而优秀的流水线构建工具（平台）。\n为了实现现代化构建方式Run configuration as Code, Jenkins引入了Blue Ocean插件。通过该插件，我们可以使用声明式语法来编写Jenkinsfile，定义流水线构建步骤 https://www.jenkins.io/zh/doc/book/pipeline/jenkinsfile/\n然而在云原生和DevOps越来越流行的今天，传统的Jenkins模式只能满足CI的构建需求。于是Jenkins团队又引入了JenkinsX, 来实现一个现代化的GitOps平台。\nemm, 不吹水了，其实我只想做个笔记,记录下折腾了很久后的才明白的安装步骤\n目标 使用jx工具在microk8s上安装jenkinsx\nhttps://jenkins-x.io/docs/labs/\n因为不喜欢使用helm2在k8s上安装tiller, 所以这里直接跳级到helm3。不过这里就要使用JenkinsX Lab里的jxl工具了。(目前是实验性版本的jenkinsx，意味着要花更多时间折腾)\n结果：暂时弃坑了，直接上tektoncd\n安装 jxl本身使用gitops方式维护JenkinsX集群\njxl 安装 从这个链接下载安装jxl工具 https://github.com/jenkins-x-labs/jxl/releases\n创建仓库 jxl boot create 这里我们选择minikube，和microk8s应该差不多。(注意不要选择更新本地jx版本，至少这篇文章写的时候这一步还有bug)\n按提示输入完毕就会初始化仓库，把jenkins bot的token记录下来, 我偷懒直接用这个访问github 私有仓库（开起了两步验证，直接使用密码没有办法直接推代码到github)\n这里还有一步是设置secret, 建议使用Hashicorp Vault存储secrets信息。 安装启动 拉取远程配置启动 jxl boot run --git-url https://github.com/artificerpi/environment-jx-dev --git-user artificerpi --git-token \u0026lt;TOKEN\u0026gt; 本地启动 （只是一个测试） cd environment-jx-dev \u0026amp;\u0026amp; jxl boot run -b 目前无法运行起来，报错/secrets/jx-boot/secrets.yaml无法找到，可能是个bug\nerror: failed to load secrets YAML /secrets/jx-boot/secrets.yaml: open /secrets/jx-boot/secrets.yaml: no such file or directory ","tags":null,"title":"JenkinsX"},{"categories":null,"content":"Caddy 简单介绍 Caddy是现代化的web代理服务器，使用Go语言编写，不直接依赖系统底层库。 另外，它很好地支持了https (也最先支持了http3), 而且它使用了现代化流行且安全的配置，几乎不需要额外配置。\n安装使用 我们可以去官网下载2.0版本 https://caddyserver.com/ 我们只需要拿到二进制文件即可。\n下载后放到/usr/local/bin/caddy, 然后编辑Caddyfile\n/etc/Caddyfile\n{ # debug servers { protocol { experimental_http3 } } } www.mwine.science { # redirect www.mwine.science to mwine.science redir https://mwine.science{uri} } mwine.science { root * /var/www/html/mwine.science file_server encode zstd gzip } 配置参考 https://caddyserver.com/docs/caddyfile/options\n这里我将域名mwine.science和www.mwine.science绑定到了同一台服务器，并将www.mwine.science重定向到 …","date":"2020-04-22","permalink":"https://qtopie.github.io/notes/web/caddy/","summary":"Caddy 简单介绍 Caddy是现代化的web代理服务器，使用Go语言编写，不直接依赖系统底层库。 另外，它很好地支持了https (也最先支持了http3), 而且它使用了现代化流行且安全的配置，几乎不需要额外配置。\n安装使用 我们可以去官网下载2.0版本 https://caddyserver.com/ 我们只需要拿到二进制文件即可。\n下载后放到/usr/local/bin/caddy, 然后编辑Caddyfile\n/etc/Caddyfile\n{ # debug servers { protocol { experimental_http3 } } } www.mwine.science { # redirect www.mwine.science to mwine.science redir https://mwine.science{uri} } mwine.science { root * /var/www/html/mwine.science file_server encode zstd gzip } 配置参考 https://caddyserver.com/docs/caddyfile/options\n这里我将域名mwine.science和www.mwine.science绑定到了同一台服务器，并将www.mwine.science重定向到mwine.science\n然后创建一个文件/var/www/html/mwine.science/index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; Hello World ! \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 最后运行起来就可以了 （这里我加上了watch选项，启用根据文件配置动态更新）\n/usr/local/bin/caddy run -config /etc/Caddyfile -watch 或者我们可以将它写成systemd服务，输入命令编辑sudo systemctl edit --force --full caddy.service\n粘贴以下内容\n[Unit] Description=Caddy server daemon Wants=network-online.target After=network.target network-online.target multi-user.target [Service] ExecStart=/usr/local/bin/caddy run --config /etc/Caddyfile Restart=on-failure RestartSec=30 TimeoutStopSec=30 [Install] WantedBy=multi-user.target 酱紫就完成了, 然后你就有了一个http3的网站！\n","tags":["caddy"],"title":"Caddy与http3"},{"categories":["development"],"content":"官方下载安装向导请参考这里https://golang.org/dl/\n这篇文章主要分享加速访问go依赖和资源站点的问题。\n环境 Ubuntu 19.10 x86_64 版本号 go1.14 linux/amd64 下载安装 Go安装文件可以访问国内站点 https://golang.google.cn/dl/\n解压后，移动到/usr/local/go目录，然后在/etc/profile里加入\nexport GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin 使用技巧 goproxy 使用goproxy加速go module下载(解决go get无法下载来自golang.org等站点的依赖包的问题）\n参考https://goproxy.io/zh/, 在go 1.13+下，我们可以使用以下命令在go env设置goproxy\ngo env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.io,direct # 设置不走 proxy 的私有仓库，多个用逗号相隔（可选） go env -w GOPRIVATE=*.corp.example.com 同样推荐使用国内站点https://goproxy.cn/\n文档查看 使用go doc命令可以在终端快速查阅文档, 例如 go doc …","date":"2020-03-18","permalink":"https://qtopie.github.io/notes/go/setup-go/","summary":"官方下载安装向导请参考这里https://golang.org/dl/\n这篇文章主要分享加速访问go依赖和资源站点的问题。\n环境 Ubuntu 19.10 x86_64 版本号 go1.14 linux/amd64 下载安装 Go安装文件可以访问国内站点 https://golang.google.cn/dl/\n解压后，移动到/usr/local/go目录，然后在/etc/profile里加入\nexport GOROOT=/usr/local/go export PATH=$PATH:$GOROOT/bin 使用技巧 goproxy 使用goproxy加速go module下载(解决go get无法下载来自golang.org等站点的依赖包的问题）\n参考https://goproxy.io/zh/, 在go 1.13+下，我们可以使用以下命令在go env设置goproxy\ngo env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.io,direct # 设置不走 proxy 的私有仓库，多个用逗号相隔（可选） go env -w GOPRIVATE=*.corp.example.com 同样推荐使用国内站点https://goproxy.cn/\n文档查看 使用go doc命令可以在终端快速查阅文档, 例如 go doc net.Listen | vim - 参考","tags":["go"],"title":"Go安装"},{"categories":null,"content":"容器化 Containerization 容器是标准化的软件单元。容器化将软件打包成标准化的单元，从而能够以此进行开发，装载和部署。简单地说，通过底层虚拟化，容器化实现应用Write once, run anywhere， 而且是快速地run anywhere，就像docker图标里被鲸鱼背着的集装箱一样。\n容器与虚拟机的对比 容器实现的是操作系统层面的虚拟化，而虚拟机是实现硬件层面的虚拟化。所以对于应用来说，选择容器会更加轻量级，这意味着它将占用更少的资源，能更快的启动和停止，更灵活地分配资源等等。\nPS: 这里并不是说容器一定总比虚拟机好，一般来说，不同的技术方案都有它适应的场景。比如我们需要模拟完整的硬件环境，虚拟机方案显然就更合适了。例如，在办公电脑上，我常常在windows笔记本上使用hyper-v安装一个ubuntu做开发，容器化方案在这里就相形见绌了。\n很多时候，容器和虚拟机被一起使用。比如，你买了一台性能很好的高可用服务器，1TB RAM, 64 core CPU，那么为了更合理的分配和管理资源，你可能首先在这台服务器上建立数个virtualbox虚拟机，然后再在虚拟机操作系统里安装docker。\n容器编排 容器化是我们能更方便地打包和运行应用，但当需要运行成百上千或者更多容器的时候，容器的自动化管理就十分重要了。对于习惯于实现应用自动化的程序员来说，甚至只管理两三 …","date":"2020-01-04","permalink":"https://qtopie.github.io/notes/cloud-native/k8s/k8s-get-started/","summary":"容器化 Containerization 容器是标准化的软件单元。容器化将软件打包成标准化的单元，从而能够以此进行开发，装载和部署。简单地说，通过底层虚拟化，容器化实现应用Write once, run anywhere， 而且是快速地run anywhere，就像docker图标里被鲸鱼背着的集装箱一样。\n容器与虚拟机的对比 容器实现的是操作系统层面的虚拟化，而虚拟机是实现硬件层面的虚拟化。所以对于应用来说，选择容器会更加轻量级，这意味着它将占用更少的资源，能更快的启动和停止，更灵活地分配资源等等。\nPS: 这里并不是说容器一定总比虚拟机好，一般来说，不同的技术方案都有它适应的场景。比如我们需要模拟完整的硬件环境，虚拟机方案显然就更合适了。例如，在办公电脑上，我常常在windows笔记本上使用hyper-v安装一个ubuntu做开发，容器化方案在这里就相形见绌了。\n很多时候，容器和虚拟机被一起使用。比如，你买了一台性能很好的高可用服务器，1TB RAM, 64 core CPU，那么为了更合理的分配和管理资源，你可能首先在这台服务器上建立数个virtualbox虚拟机，然后再在虚拟机操作系统里安装docker。\n容器编排 容器化是我们能更方便地打包和运行应用，但当需要运行成百上千或者更多容器的时候，容器的自动化管理就十分重要了。对于习惯于实现应用自动化的程序员来说，甚至只管理两三个容器就巴不得有一个工具来完成自动化。容器编排就是来解决这个问题的，比较流行的有Google开发并开源的kubernetes, 及docker官方推的docker swarm。前者几乎已经成为业界规范，不过docker swarm对docker集成的更好，如果熟悉docker的话，docker swarm也会更加容易上手。\n容器编排常见的功能 （不想翻译)\nExpose containers by DNS name or IP address. Handle load balancing and traffic distribution for containers. Automatically mount local and cloud-based storage. Allocate specific CPU and RAM resources to containers and then fit them onto nodes. Replace or kill problematic containers without jeopardizing application performance and uptime. Manage sensitive information like password and tokens without rebuilding containers. Change the state of containers and roll back old containers to replace them with new ones. 参考 什么是容器化 容器化的优点 什么是container 安装 docker 安装 不推荐使用系统源或者snap包方式安装docker, 使用的时候会遇到环境或者兼容性的问题。\n","tags":null,"title":"Kubernetes使用入门"},{"categories":["development"],"content":"Eclipse \u0026amp;amp; Gradle 还是从那句老话开始， “工欲善其事，必先利其器”。要想熟练地完成一件事，有个好的工具往往能事半功倍。\n但是很多时候，迷信教条最终会成了造轮子而造轮子的递归循环；选择合适的工具，并掌握它，解决好问题才是正确的方向。\n这里简单说说，我选择Eclispe和Gradle的原因。\nGradle (Gradle VS Maven or Ant); 选择gradle的原因很简单，简单而清晰的语法，强大的脚本语言，快速而稳定的构建。\nEclipse (主要对比Idea, VS Code)\n开源及活跃而广受欢迎的社区 相对于Idea来说，个人使用经验上来看，在大Project上使用（源码多，项目多）更稳定, 且有偏向支持开源社区的因素，故使用Eclipse；VS Code对于小的Project来说还好，功能比Eclipse弱，查看多个文件及源码也不是很方便，大项目会使系统卡顿，但是小项目一般可以使用gradle + vim。 开发环境 当前开发环境\nUbuntu 19.10 x86_64 Gradle 5.6.4 Eclipse (Snap版本) Eclipse Platform Version: 2019-03 (4.11) Build id: I20190307-0500 OS: Linux, v.5.3.0-24-generic, x86_64 / …","date":"2019-12-28","permalink":"https://qtopie.github.io/notes/dev/make-gradle-work-with-eclipse/","summary":"Eclipse \u0026amp; Gradle 还是从那句老话开始， “工欲善其事，必先利其器”。要想熟练地完成一件事，有个好的工具往往能事半功倍。\n但是很多时候，迷信教条最终会成了造轮子而造轮子的递归循环；选择合适的工具，并掌握它，解决好问题才是正确的方向。\n这里简单说说，我选择Eclispe和Gradle的原因。\nGradle (Gradle VS Maven or Ant); 选择gradle的原因很简单，简单而清晰的语法，强大的脚本语言，快速而稳定的构建。\nEclipse (主要对比Idea, VS Code)\n开源及活跃而广受欢迎的社区 相对于Idea来说，个人使用经验上来看，在大Project上使用（源码多，项目多）更稳定, 且有偏向支持开源社区的因素，故使用Eclipse；VS Code对于小的Project来说还好，功能比Eclipse弱，查看多个文件及源码也不是很方便，大项目会使系统卡顿，但是小项目一般可以使用gradle + vim。 开发环境 当前开发环境\nUbuntu 19.10 x86_64 Gradle 5.6.4 Eclipse (Snap版本) Eclipse Platform Version: 2019-03 (4.11) Build id: I20190307-0500 OS: Linux, v.5.3.0-24-generic, x86_64 / gtk 3.24.12 Java version: 1.8.0_171 Eclipse项目配置及依赖管理 我的Java项目管理方案 我不喜欢将IDE文件提交到git代码仓库，在我看来，IDE的作用就是一个文本编辑器，而且从协作角度来看，不同的开发者可能会选择不同的编辑器，所以不需要将IDE文件提交。 而Gradle脚本，不仅作为项目开发中一款重要的工具，而且包含了很多项目配置信息，因此需要提交到git仓库(有时候，如果开发人员和CI使用了统一的或兼容的gradle版本，甚至gradle wrapper都不需要提交)\n生成项目配置 默认Gradle eclipse编译输出目录为bin, 但是gradle构建输出目录为build， 因此需要改配置。\nplugins { id \u0026#39;java\u0026#39; id \u0026#39;eclipse\u0026#39; } eclipse { project.natures \u0026#39;org.eclipse.buildship.core.gradleprojectnature\u0026#39; classpath { downloadJavadoc = true downloadSources = true defaultOutputDir = file(\u0026#39;build/default\u0026#39;) file.whenMerged { entries.each { source -\u0026gt; // This seems kludgy. If the second test is omitted, it fails processing a \u0026#39;Project Dependency\u0026#39; entry if (source.kind == \u0026#39;src\u0026#39; \u0026amp;\u0026amp; source.hasProperty(\u0026#39;output\u0026#39;)) { def outputPath = source.output switch(source.path) { case \u0026#39;src/main/java\u0026#39;: source.output = \u0026#39;build/classes/java/main\u0026#39; break case \u0026#39;src/main/resources\u0026#39;: source.output = \u0026#39;build/resources/main\u0026#39; break case \u0026#39;src/test/java\u0026#39;: source.output = \u0026#39;build/classes/java/test\u0026#39; break case \u0026#39;src/test/resources\u0026#39;: source.output = \u0026#39;build/resources/test\u0026#39; break } } } } } } https://github.com/gradle/gradle/issues/3839\n","tags":["eclispe","java"],"title":"Make Eclipse Great Again"},{"categories":["DIY"],"content":"目标 构建一个可编程控制的流媒体播放服务器，类似于智能音箱，但是没有麦克风收集个人隐私数据。\n整体架构如下\n+ - 100% Full graph LR subgraph 树莓派 Raspberry Pi A[cmus音乐播放器] --\u0026gt; B(PulseAudio Client) end subgraph VoCore C(PulseAudio Server) --\u0026gt; D[音响 / 扬声器] end B --\u0026gt; C Vocore固件支持 Currently 2022/12/3, only openwrt 21.02 is supported. (patch is not working ins 22.03)\nsee https://github.com/Vonger/vocore2\nBecause audio is enabled by kmod+ packages, so I need to build the firmware myself.\nAlsa install alsa-utils packages, then add configuration to init sound card\nin /etc/rc.local file\nalsactl init Adjust volume use alsamixer\nuse amixer …","date":"2019-07-26","permalink":"https://qtopie.github.io/notes/iot/vocore/vocore-network-audio/","summary":"目标 构建一个可编程控制的流媒体播放服务器，类似于智能音箱，但是没有麦克风收集个人隐私数据。\n整体架构如下\n+ - 100% Full graph LR subgraph 树莓派 Raspberry Pi A[cmus音乐播放器] --\u003e B(PulseAudio Client) end subgraph VoCore C(PulseAudio Server) --\u003e D[音响 / 扬声器] end B --\u003e C Vocore固件支持 Currently 2022/12/3, only openwrt 21.02 is supported. (patch is not working ins 22.03)\nsee https://github.com/Vonger/vocore2\nBecause audio is enabled by kmod+ packages, so I need to build the firmware myself.\nAlsa install alsa-utils packages, then add configuration to init sound card\n","tags":["vocore"],"title":"vocore2播放音频-使用路由器听歌？"},{"categories":null,"content":"由于墙挡住了路由器WIFI信号，虽然5G频率的WIFI传输速率很快，但是信号衰减。WIFI无线通信是双方向的，就算路由信号能覆盖到，但考虑到手机或笔记本功率和天线的限制，难保证信号稳定。所以在淘宝上买了一个功能还算强大的无线网卡ComFast 926AC v2，双频WIFI外置双天线。没提前研究，“号称免驱动\u0026amp;quot;，结果拿回来就懵了。\n安装驱动 设备: Comfast 926AC v2 系统： Ubuntu 18.04\n因为是联发科的芯片，通常都是在同一份驱动代码上改改完成的。故从github上寻找了下面两个仓库的代码。\nulli-kroll/mt7612u, jurobystricky/Netgear-A6210 官方驱动\n上面两驱动实际是在官方源码上改写的，但编译后，三个都不能正常工作。\n后来在openwrt/linux项目下发现该设备驱动的相关issue, 并已有大牛正在mt76驱动项目下加入该芯片的支持。故转用mt76的设备。查询linux主仓库代码发现，该驱动已随Linux内核5.0发布。因此直接下载linux 5.0内核包安装就行了。\n# 5.0: https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.0/ …","date":"2019-03-09","permalink":"https://qtopie.github.io/notes/linux/mt7612u-driver/","summary":"由于墙挡住了路由器WIFI信号，虽然5G频率的WIFI传输速率很快，但是信号衰减。WIFI无线通信是双方向的，就算路由信号能覆盖到，但考虑到手机或笔记本功率和天线的限制，难保证信号稳定。所以在淘宝上买了一个功能还算强大的无线网卡ComFast 926AC v2，双频WIFI外置双天线。没提前研究，“号称免驱动\u0026quot;，结果拿回来就懵了。\n安装驱动 设备: Comfast 926AC v2 系统： Ubuntu 18.04\n因为是联发科的芯片，通常都是在同一份驱动代码上改改完成的。故从github上寻找了下面两个仓库的代码。\nulli-kroll/mt7612u, jurobystricky/Netgear-A6210 官方驱动\n上面两驱动实际是在官方源码上改写的，但编译后，三个都不能正常工作。\n后来在openwrt/linux项目下发现该设备驱动的相关issue, 并已有大牛正在mt76驱动项目下加入该芯片的支持。故转用mt76的设备。查询linux主仓库代码发现，该驱动已随Linux内核5.0发布。因此直接下载linux 5.0内核包安装就行了。\n# 5.0: https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.0/ linux-headers-5.0.0-050000_5.0.0-050000.201903032031_all.deb linux-headers-5.0.0-050000-generic_5.0.0-050000.201903032031_amd64.deb linux-image-unsigned-5.0.0-050000-generic_5.0.0-050000.201903032031_amd64.deb linux-modules-5.0.0-050000-generic_5.0.0-050000.201903032031_amd64.deb 手动升级内核后测试能使用, 并支持AP：\niwconfig\nwlx40a5eff2b655 IEEE 802.11 ESSID:off/any Mode:Managed Access Point: Not-Associated Tx-Power=19 dBm Retry short limit:7 RTS thr:off Fragment thr:off Power Management:off 网卡识别为存储设备的问题 mt76还未对这款comfast网卡适配，所以默认会被系统识别为存储设备，可以手动切换过来：\nsudo usb_modeswitch -KW -v 0e8d -p 2870 或者修改/lib/udev/rules.d/40-usb_modeswitch.rules文件自动切换（目前未成功）\n# MT7612U ATTR{idVendor}==\u0026#34;0e8d\u0026#34;, ATTR{idProduct}==\u0026#34;2870\u0026#34;, RUN+=\u0026#34;usb_modeswitch \u0026#39;%b/%k\u0026#39;\u0026#34; USB底座接触不良的问题 一起买的底座有点问题，开始还以为也要装什么驱动。检查后发现是接触不良的问题，因为USB口没有固定住，所以网卡很容易没有插入到底座中。解决办法比较简单，拆卸底座，然后填充底座中空部分，固定住USB接口。\n","tags":["ubuntu","mt7612u"],"title":"Ubuntu下使用MT7612U"},{"categories":[],"content":"Yeah, another CI tool. That\u0026amp;rsquo;s named Drone.\nWe\u0026amp;rsquo;ve been heard of Jenkins, travis-ci and even circle-ci (I have to mention this because there\u0026amp;rsquo;re too much ads on youtube for it), so why would we need another one?\nI\u0026amp;rsquo;ve used Jenkins and travis-ci, but they are not perfect, at least there are some slight drawbacks.\nMy experience on Jenkins Jenkins is stable for production, it has long history and is used widely. But sometimes I find Jenkins is too slow, and configuration is not straightforward. And it\u0026amp;rsquo;s a pain to upgrade to a new pipeline, you have to copy and paste jobs …","date":"2019-03-05","permalink":"https://qtopie.github.io/notes/cloud-native/cicd/drone-ci-with-github/","summary":"Yeah, another CI tool. That\u0026rsquo;s named Drone.\nWe\u0026rsquo;ve been heard of Jenkins, travis-ci and even circle-ci (I have to mention this because there\u0026rsquo;re too much ads on youtube for it), so why would we need another one?\nI\u0026rsquo;ve used Jenkins and travis-ci, but they are not perfect, at least there are some slight drawbacks.\nMy experience on Jenkins Jenkins is stable for production, it has long history and is used widely. But sometimes I find Jenkins is too slow, and configuration is not straightforward. And it\u0026rsquo;s a pain to upgrade to a new pipeline, you have to copy and paste jobs from UI (while accessing is pretty slow). You might able to config jobs with XML config files, but it\u0026rsquo;s still a bit of complicated.\n","tags":[],"title":"Drone CI With Github"},{"categories":[],"content":"Jiri (/jɪəri/ YEER-ee)是谷歌工程师开发的，灵活集成多个git仓库的工具，主要用来管理fuchsia操作系统源码。\n其主要功能类似于git submodule, 但使用方式更加灵活，不需要对原git仓库的行为做任何修改，也可以不用在主仓库不断更新引用。\n安装 推荐从源码编译安装 (需要安装最新版本Go语言构建工具）\ngit clone https://fuchsia.googlesource.com/jiri cd jiri/cmd/jiri/jiri go build # go install sudo mv jiri /usr/local/bin/jiri Manifest manifest (文件名称为foo) \u0026amp;lt;?xml version=\u0026amp;#34;1.0\u0026amp;#34; encoding=\u0026amp;#34;UTF-8\u0026amp;#34;?\u0026amp;gt; \u0026amp;lt;manifest\u0026amp;gt; \u0026amp;lt;projects\u0026amp;gt; \u0026amp;lt;project name=\u0026amp;#34;spring-petclinic-mybatis\u0026amp;#34; remote=\u0026amp;#34;https://github.com/artificerpi/spring-petclinic-mybatis\u0026amp;#34; path=\u0026amp;#34;backend\u0026amp;#34;/\u0026amp;gt; \u0026amp;lt;project …","date":"2018-12-20","permalink":"https://qtopie.github.io/notes/cloud-native/cicd/jiri.zh/","summary":"Jiri (/jɪəri/ YEER-ee)是谷歌工程师开发的，灵活集成多个git仓库的工具，主要用来管理fuchsia操作系统源码。\n其主要功能类似于git submodule, 但使用方式更加灵活，不需要对原git仓库的行为做任何修改，也可以不用在主仓库不断更新引用。\n安装 推荐从源码编译安装 (需要安装最新版本Go语言构建工具）\ngit clone https://fuchsia.googlesource.com/jiri cd jiri/cmd/jiri/jiri go build # go install sudo mv jiri /usr/local/bin/jiri Manifest manifest (文件名称为foo) \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;projects\u0026gt; \u0026lt;project name=\u0026#34;spring-petclinic-mybatis\u0026#34; remote=\u0026#34;https://github.com/artificerpi/spring-petclinic-mybatis\u0026#34; path=\u0026#34;backend\u0026#34;/\u0026gt; \u0026lt;project name=\u0026#34;spring-petclinic-angular\u0026#34; remote=\u0026#34;https://github.com/spring-petclinic/spring-petclinic-angular.git\u0026#34; path=\u0026#34;frontend\u0026#34;/\u0026gt; \u0026lt;/projects\u0026gt; \u0026lt;/manifest\u0026gt; 将此文件放到git仓库根目录下，本地创建目录foo\nmkdir foo \u0026amp;\u0026amp; cd foo jiri init # manifest repos jiri import foo https://github.com/artificerpi/jiri-foo jiri update 更多使用参考下面的文档和help命令\n参考 https://fuchsia.googlesource.com/jiri/ ","tags":[],"title":"Jiri"},{"categories":null,"content":"LaTeX Configuration This site uses KaTeX for rendering mathematics. The configured delimiters are:\nInline: $...$ or \\(...\\) Display: $$...$$ or \\[...\\] Additionally, you can use code blocks for block-level formulas:\nE = mc^2 For vscode, you might want to ensure your preview settings match these delimiters.\nGood memory is not as bad as a pen.\nPermutation $ A_n^n=n\\times(n-1)\\times(n-2)\\times\u0026amp;hellip;\\times2\\times1 $\n$ A_n^m=n\\times(n-1)\\times(n-2)\\times\u0026amp;hellip;\\times(n-m+1) = \\frac{n!}{(n-m)!} $\nCombination $ C_n^m=\\frac{A_n^m}{A_m^m} = \\frac{n!}{m!(n-m)!} $\nC_n^m=C_n^{n-m} $ C_{n+1}^{r+1} = …","date":"2018-12-20","permalink":"https://qtopie.github.io/posts/hugo/math-in-markdown/","summary":"LaTeX Configuration This site uses KaTeX for rendering mathematics. The configured delimiters are:\nInline: $...$ or \\(...\\) Display: $$...$$ or \\[...\\] Additionally, you can use code blocks for block-level formulas:\nE = mc^2 For vscode, you might want to ensure your preview settings match these delimiters.\nGood memory is not as bad as a pen.\nPermutation $ A_n^n=n\\times(n-1)\\times(n-2)\\times\u0026hellip;\\times2\\times1 $\n$ A_n^m=n\\times(n-1)\\times(n-2)\\times\u0026hellip;\\times(n-m+1) = \\frac{n!}{(n-m)!} $\nCombination $ C_n^m=\\frac{A_n^m}{A_m^m} = \\frac{n!}{m!(n-m)!} $\nC_n^m=C_n^{n-m} $ C_{n+1}^{r+1} = C_n^r + C_n^{r+1} $\n","tags":["latex","math"],"title":"Math in Markdown"},{"categories":["diy"],"content":"准备环境 树莓派3B 华为4G模块：HUAWEI ME909s-821 PCIE转USB开发板 5cm天线转接线，SMA公头外螺内孔 吸盘天线全向高增益天线，SMA公头外螺内孔 中国移动4G SIM卡 4G模块技术规格及文档 技术规格 连接 基于海思芯片, 同类比较 SIM7600CE (Qualcomm MDM9206)\n文档 连接 主天线M口\n开始使用 Windows上使用该4G模块需要手动安装驱动，驱动连接\nUbuntu下可以使用modemmanager管理4G模块\n树莓派下使用教程如下。\n查看usb设备是否被识别 lsusb # output: Bus 001 Device 004: ID 12d1:15c1 Huawei Technologies Co., Ltd. Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. SMSC9512/9514 Fast Ethernet Adapter Bus 001 Device 002: ID 0424:9514 Standard Microsystems Corp. SMC9514 Hub Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub 安装拨号软件 sudo apt-get …","date":"2018-12-05","permalink":"https://qtopie.github.io/notes/iot/rpi/rpi-4g-lte-module/","summary":"准备环境 树莓派3B 华为4G模块：HUAWEI ME909s-821 PCIE转USB开发板 5cm天线转接线，SMA公头外螺内孔 吸盘天线全向高增益天线，SMA公头外螺内孔 中国移动4G SIM卡 4G模块技术规格及文档 技术规格 连接 基于海思芯片, 同类比较 SIM7600CE (Qualcomm MDM9206)\n文档 连接 主天线M口\n开始使用 Windows上使用该4G模块需要手动安装驱动，驱动连接\nUbuntu下可以使用modemmanager管理4G模块\n树莓派下使用教程如下。\n查看usb设备是否被识别 lsusb # output: Bus 001 Device 004: ID 12d1:15c1 Huawei Technologies Co., Ltd. Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. SMSC9512/9514 Fast Ethernet Adapter Bus 001 Device 002: ID 0424:9514 Standard Microsystems Corp. SMC9514 Hub Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub 安装拨号软件 sudo apt-get update sudo apt-get install ppp usb-modeswitch wvdial 初始化wvdial配置 sudo wvdialconf /etc/wvdial.conf 修改wvdial配置 [Dialer Defaults] Init1 = ATZ Init2 = ATQ0 V1 E1 S0=0 Init3 = AT+CGDCONT=1,\u0026#34;IP\u0026#34;, \u0026#34;cmnet\u0026#34; Modem Type = Analog Modem Baud = 9600 New PPPD = yes Modem = /dev/ttyUSB0 ISDN = 0 Phone = *99***1# Password = { } Username = { } Auto DNS = on APN和拨号设置参考\n","tags":["raspberrypi","4G LTE"],"title":"树莓派4G模块"},{"categories":null,"content":"Virtualbox with Ubuntu Server Manage Virtualbox in command line\nInstallation sudo apt install virtualbox # or manually # wget https://download.virtualbox.org/virtualbox/5.2.22/virtualbox-5.2_5.2.22-126460~Ubuntu~bionic_amd64.deb # sudo dpkg -i virtualbox*.deb Install extenstion pack sudo apt install virtualbox-ext-pack # or manually # sudo VBoxManage extpack install Oracle_VM_VirtualBox_Extension_Pack-5.2.4-119785.vbox-extpack # check installation VBoxManage list extpacks Create VM Create virtual disk VBoxManage createmedium disk --filename ubuntu-server1.vdi --size 8192 Create virtual machine …","date":"2018-11-27","permalink":"https://qtopie.github.io/notes/linux/vbox-ubuntu-server/","summary":"Virtualbox with Ubuntu Server Manage Virtualbox in command line\nInstallation sudo apt install virtualbox # or manually # wget https://download.virtualbox.org/virtualbox/5.2.22/virtualbox-5.2_5.2.22-126460~Ubuntu~bionic_amd64.deb # sudo dpkg -i virtualbox*.deb Install extenstion pack sudo apt install virtualbox-ext-pack # or manually # sudo VBoxManage extpack install Oracle_VM_VirtualBox_Extension_Pack-5.2.4-119785.vbox-extpack # check installation VBoxManage list extpacks Create VM Create virtual disk VBoxManage createmedium disk --filename ubuntu-server1.vdi --size 8192 Create virtual machine VBoxManage list ostypes | grep -B 1 -A 2 Ubuntu VBoxManage createvm --name ubuntu-server1 --ostype \u0026#34;Ubuntu_64\u0026#34; --register Configure virtual machine # add sata disk VBoxManage storagectl ubuntu-server1 --name SATA --add sata --controller IntelAHCI VBoxManage storageattach ubuntu-server1 --storagectl SATA --port 0 --device 0 --type hdd --medium ubuntu-server1.vdi # mount dvd bootable iso file VBoxManage storagectl ubuntu-server1 --name IDE --add ide VBoxManage storageattach ubuntu-server1 --storagectl IDE --port 0 --device 0 --type dvddrive --medium ~/Downloads/mini.iso VBoxManage modifyvm ubuntu-server1 --ioapic on VBoxManage modifyvm ubuntu-server1 --boot1 dvd --boot2 disk --boot3 none --boot4 none VBoxManage modifyvm ubuntu-server1 --memory 512 --vram 8 VBoxManage modifyvm ubuntu-server1 --nic1 nat Set for VRDE (optional) VBoxManage setproperty vrdeextpack \u0026#34;Oracle VM VirtualBox Extension Pack\u0026#34; # vrde port 5000, 5010, 5011 or 5012 VBoxManage modifyvm ubuntu-server1 --vrde on --vrdeport 5000,5010-5012 Start vm VBoxManage startvm ubuntu-server1 --type headless VBoxManage showvminfo ubuntu-server1 Test it rdesktop -a 16 -N \u0026lt;HOST-IP\u0026gt;:\u0026lt;PORT\u0026gt;\n","tags":null,"title":"Vbox Ubuntu Server"},{"categories":["diy"],"content":"出于各种原因，我们可能会对自己手机上的安卓系统并不满意，而Root是我们DIY自己的安卓机的一把钥匙。\n注意手机Root后并不一定安全，本文仅仅说的是用安全（较为透明公开）的方式自己root你的手机。\n但安全永远是相对的，如果你对手机ROOT后的安全性有较大顾虑，请不要进行该操作。\n对ROOT后的设备，也请远离流氓软件和恶意网站，尽可能使用可信度高的应用与服务。\n预先准备 MagiskManager Twrp APK文件从谷歌商店下载 sdk与fastboot工具 win linux mac 准备一台PC和数据线，能使用开发者模式调试安卓手机 解锁你的手机 打开开发者模式 打开设置 -\u0026amp;gt; 关于手机 -\u0026amp;gt; 软件信息 -\u0026amp;gt; 内部版本号 -\u0026amp;gt; 一直点它\n启用OEM解锁 进入开发者选项，勾选允许OEM解锁。 注意OEM解锁会清空手机数据，如果要进行下去请备份号手机数据。\n另外，解锁后，部分手机开机启动后会有一个源自安卓系统的安全警告画面，若不喜欢也建议不要继续。\n准备Magisk文件 在Magisk的Github发布页面下载apk程序进行安装，按照应用提示，下载最新的Magisk文件\nOEM 解锁 将adb和fastboot加入环境变量\n对windows用户而言，解压缩platform-tools_rx.x.x-windows.zip文件，进入解压缩后的文件夹，根目 …","date":"2018-11-04","permalink":"https://qtopie.github.io/posts/diy/root-your-android-phone/","summary":"出于各种原因，我们可能会对自己手机上的安卓系统并不满意，而Root是我们DIY自己的安卓机的一把钥匙。\n注意手机Root后并不一定安全，本文仅仅说的是用安全（较为透明公开）的方式自己root你的手机。\n但安全永远是相对的，如果你对手机ROOT后的安全性有较大顾虑，请不要进行该操作。\n对ROOT后的设备，也请远离流氓软件和恶意网站，尽可能使用可信度高的应用与服务。\n预先准备 MagiskManager Twrp APK文件从谷歌商店下载 sdk与fastboot工具 win linux mac 准备一台PC和数据线，能使用开发者模式调试安卓手机 解锁你的手机 打开开发者模式 打开设置 -\u0026gt; 关于手机 -\u0026gt; 软件信息 -\u0026gt; 内部版本号 -\u0026gt; 一直点它\n启用OEM解锁 进入开发者选项，勾选允许OEM解锁。 注意OEM解锁会清空手机数据，如果要进行下去请备份号手机数据。\n另外，解锁后，部分手机开机启动后会有一个源自安卓系统的安全警告画面，若不喜欢也建议不要继续。\n准备Magisk文件 在Magisk的Github发布页面下载apk程序进行安装，按照应用提示，下载最新的Magisk文件\nOEM 解锁 将adb和fastboot加入环境变量\n对windows用户而言，解压缩platform-tools_rx.x.x-windows.zip文件，进入解压缩后的文件夹，根目录后下会显示有adb.exe和fastboot.exe等文件。 然后将光标移到文件夹空白处，同时按下Shift键和鼠标右键，点击弹出来的菜单选项，打开命令窗口（后续操作需要在此进行，请不要关闭）。\n检查能PC检测到连入的手机\nadb kill-server \u0026amp;\u0026amp; adb start-server adb devices 重启手机进入download模式\nadb reboot download 解锁bootloader\nfastboot oem unlock fastboot flashing unlock 刷入twrp到Recovery 在download模式中刷入recovery\nfastboot flash recovery twrp.img fastboot reboot recovery 刷入Magisk文件 在上述步骤完成进入recovery后，可以看到twrp的一些管理菜单，选择安装我们刚才下载的magisk zip文件， 完成后重启手机。\n定制自己的ROM（极客，需要熟悉一些计算机程序知识） 推荐一个工具来完成 https://github.com/artificerpi/android_system_extraction_and_repack_tool\n参考 https://twrp.me/htc/htcu11.html ","tags":["root","android"],"title":"怎样安全地Root你的安卓手机"},{"categories":["DIY"],"content":"VoCore 硬币大小的Linux计算机（或者可以DIY的mini路由器）\n技术参数 Target: ramips Subtarget: mt7628 Package architecture: mipsel_24kc OpenWRT techdata 具体参数请看官网介绍 VoCore2 Ultimate 和 openwrt列出的技术数据\nOpenWRT介绍 OpenWRT(与LEDE合并后更名为OpenWrt)是一个适用于嵌入式设备的Linux发行版，最初由Linksys公司推出的WRT-54G无线路由中使用的Linux系统开源而来。相比于路由器原厂固件而言，OpenWRT提供了一个可添加软件包的可写文件系统，这样用户就能自己定制路由器的功能。基于开放的生态和良好的技术社区环境，OpenWRT十分适合喜好DIY的科技粉来定制自己的路由器。\nOpenWRT主要使用opkg来管理软件包，默认使用LuCI作为web交互界面。下面简单列出它们的常用方式，具体使用方法请查阅文档。\nopkg\n# 安装软件包 opkg install \u0026amp;lt;PACKAGE-NAME\u0026amp;gt; # 卸载软件包 opkg remove \u0026amp;lt;PACKAGE-NAME\u0026amp;gt; uci\n# 设置option uci set \u0026amp;lt;OPTION\u0026amp;gt; # 查看option uci show …","date":"2018-07-26","permalink":"https://qtopie.github.io/notes/iot/vocore/my-vocore-playground/","summary":"VoCore 硬币大小的Linux计算机（或者可以DIY的mini路由器）\n技术参数 Target: ramips Subtarget: mt7628 Package architecture: mipsel_24kc OpenWRT techdata 具体参数请看官网介绍 VoCore2 Ultimate 和 openwrt列出的技术数据\nOpenWRT介绍 OpenWRT(与LEDE合并后更名为OpenWrt)是一个适用于嵌入式设备的Linux发行版，最初由Linksys公司推出的WRT-54G无线路由中使用的Linux系统开源而来。相比于路由器原厂固件而言，OpenWRT提供了一个可添加软件包的可写文件系统，这样用户就能自己定制路由器的功能。基于开放的生态和良好的技术社区环境，OpenWRT十分适合喜好DIY的科技粉来定制自己的路由器。\nOpenWRT主要使用opkg来管理软件包，默认使用LuCI作为web交互界面。下面简单列出它们的常用方式，具体使用方法请查阅文档。\nopkg\n# 安装软件包 opkg install \u0026lt;PACKAGE-NAME\u0026gt; # 卸载软件包 opkg remove \u0026lt;PACKAGE-NAME\u0026gt; uci\n# 设置option uci set \u0026lt;OPTION\u0026gt; # 查看option uci show \u0026lt;OPTION\u0026gt; 我的定制 基本设置 Change SSID Name uci set wireless.ap.ssid=\u0026#39;firefly\u0026#39; uci commit # check result uci show wireless.ap.ssid # restart networking service to make reload configuration /etc/init.d/network restart # check network in another machine sudo iw dev wlan0 scan | grep SSID wget ssl opkg install libustream-openssl ca-bundle ca-certificates AP+STA模式 （或者叫无线中继器） 使用固件 vocore2-20180723V 配置信息(仅供参考)：\n","tags":["vocore"],"title":"我的DIY与vocore"},{"categories":null,"content":"Headless setup (no external monitor or keyboard) Updated: according to the Raspibian Documentation, use Raspberry Pi Imagger is strongly recommended\nNetworking Auto connect to wifi create an wpa_supplicant.conf file in boot partition\ncountry=us update_config=1 ctrl_interface=/var/run/wpa_supplicant network={ scan_ssid=1 ssid=\u0026amp;#34;Your-SSID\u0026amp;#34; psk=\u0026amp;#34;replace-with-your-password\u0026amp;#34; priority=100 } Connect to WIFI with CLI Refer to https://www.raspberrypi.org/documentation/configuration/wireless/wireless-cli.md\nEnable SSH Simply create an empty ssh file in the root directory of boot …","date":"2017-10-29","permalink":"https://qtopie.github.io/notes/iot/rpi/setup-my-raspberrypi/","summary":"Headless setup (no external monitor or keyboard) Updated: according to the Raspibian Documentation, use Raspberry Pi Imagger is strongly recommended\nNetworking Auto connect to wifi create an wpa_supplicant.conf file in boot partition\ncountry=us update_config=1 ctrl_interface=/var/run/wpa_supplicant network={ scan_ssid=1 ssid=\u0026#34;Your-SSID\u0026#34; psk=\u0026#34;replace-with-your-password\u0026#34; priority=100 } Connect to WIFI with CLI Refer to https://www.raspberrypi.org/documentation/configuration/wireless/wireless-cli.md\nEnable SSH Simply create an empty ssh file in the root directory of boot partition.\nRefer to https://www.raspberrypi.org/documentation/remote-access/ssh/\nGet IP of your pi With Computer sudo nmap -sP 192.168.21.* # results MAC Address: B8:27:EB:40:A9:D7 (Raspberry Pi Foundation) Nmap scan report for 192.168.31.158 With Android Phone Install connectBot or other terminal app Share the network of your android device with usb network; Enter local mode, use ip neighbor command to get the ip address of your raspberrypi Now you can ssh to your raspberry pi with this ip.\n","tags":null,"title":"My notes on Raspberry Pi"},{"categories":["development"],"content":"WIP\n快速开始 设置个人信息 git config --global user.name \u0026amp;lt;YOUR-NAME\u0026amp;gt; git config --global user.email \u0026amp;lt;YOUR-EMAIL\u0026amp;gt; # 查看个人配置 git config --list 将默认主仓库设置为main BLM运动 git config --global init.defaultbranch main 初始化仓库 mkdir /path/to/your/project cd /path/to/your/project git init # initialize an empty git repo git remote add origin git@repo-url.git Create your first file and push it to the remote repo echo \u0026amp;#34;qtopie.rw\u0026amp;#34; \u0026amp;gt;\u0026amp;gt; contributors.txt git add contributors.txt git commit -m \u0026amp;#39;Initial commit with contributors\u0026amp;#39; git push -u origin master 总结下常用操作\ngit init git add . git commit -m …","date":"2017-07-05","permalink":"https://qtopie.github.io/notes/dev/git-quick-guide/","summary":"WIP\n快速开始 设置个人信息 git config --global user.name \u0026lt;YOUR-NAME\u0026gt; git config --global user.email \u0026lt;YOUR-EMAIL\u0026gt; # 查看个人配置 git config --list 将默认主仓库设置为main BLM运动 git config --global init.defaultbranch main 初始化仓库 mkdir /path/to/your/project cd /path/to/your/project git init # initialize an empty git repo git remote add origin git@repo-url.git Create your first file and push it to the remote repo echo \u0026#34;qtopie.rw\u0026#34; \u0026gt;\u0026gt; contributors.txt git add contributors.txt git commit -m \u0026#39;Initial commit with contributors\u0026#39; git push -u origin master 总结下常用操作\n","tags":["git"],"title":"Git快速手册"},{"categories":["other"],"content":"Introduction Docker, an opensource container management tool based on LXC(Linux container).","date":"2016-11-02","permalink":"https://qtopie.github.io/notes/cloud-native/cicd/dockerfile/","summary":"Introduction Docker, an opensource container management tool based on LXC(Linux container).\n","tags":["other"],"title":"Dockerfile"},{"categories":null,"content":" username:\n^[a-z0-9_-]{3,16}$ // any character of a-z, 0-9, underscore and \u0026amp;lsquo;-\u0026amp;rsquo;\npassword:\nsimilar to username\nemail:\n^([a-z0-9_\\.-]+)@([a-z0-9_\\.-]+)\\.([a-z\\.]{2,6})$\nurl:\n^(https?:\\/\\/)?(\\da-z\\.-]+)\\.([a-z\\.]{2,6})([/\\w\\.-]*)*\\/?$\nnot\n[^]\nabc…\tLetters 123…\tDigits \\d\tAny Digit \\D\tAny Non-digit character .\tAny Character \\.\tPeriod [abc]\tOnly a, b, or c [^abc]\tNot a, b, nor c [a-z]\tCharacters a to z [0-9]\tNumbers 0 to 9 \\w\tAny Alphanumeric character \\W\tAny Non-alphanumeric character {m}\tm Repetitions {m,n}\tm to n Repetitions -\tZero or more repetitions +\tOne or more repetitions ? …","date":"2016-10-25","permalink":"https://qtopie.github.io/notes/web/regex/","summary":" username:\n^[a-z0-9_-]{3,16}$ // any character of a-z, 0-9, underscore and \u0026lsquo;-\u0026rsquo;\npassword:\nsimilar to username\nemail:\n^([a-z0-9_\\.-]+)@([a-z0-9_\\.-]+)\\.([a-z\\.]{2,6})$\nurl:\n^(https?:\\/\\/)?(\\da-z\\.-]+)\\.([a-z\\.]{2,6})([/\\w\\.-]*)*\\/?$\nnot\n[^]\nabc…\tLetters 123…\tDigits \\d\tAny Digit \\D\tAny Non-digit character .\tAny Character \\.\tPeriod [abc]\tOnly a, b, or c [^abc]\tNot a, b, nor c [a-z]\tCharacters a to z [0-9]\tNumbers 0 to 9 \\w\tAny Alphanumeric character \\W\tAny Non-alphanumeric character {m}\tm Repetitions {m,n}\tm to n Repetitions -\tZero or more repetitions +\tOne or more repetitions ?\tOptional character \\s\tAny Whitespace \\S\tAny Non-whitespace character ^…$\tStarts and ends (…)\tCapture Group (a(bc))\tCapture Sub-group (.*)\tCapture all (abc|def)\tMatches abc or def To help you better understand the regular expressions, Visualized with Regexper\n","tags":null,"title":"Regular Expression"},{"categories":["linux"],"content":"History sysVinit upstart systemd ubuntu: sysVinit \u0026amp;ndash;\u0026amp;gt; upstart(6.10+) \u0026amp;ndash;\u0026amp;gt; systemd (15.04+)\nFeatures of Upstart Event Based\nStart System faster (compare with previous method). Dynamically start service when discovering new device Dynamically stop service when device is removed Systemd Systemd is a collection of system management daemons, utilities and libraries which serves as a replacement of System V init daemon. Systemd functions as central management and configuration platform for UNIX like system.\nsystemctl Systemctl is a systemd utility which is responsible for Controlling …","date":"2016-09-15","permalink":"https://qtopie.github.io/notes/linux/systemd-service-unit-file/","summary":"History sysVinit upstart systemd ubuntu: sysVinit \u0026ndash;\u0026gt; upstart(6.10+) \u0026ndash;\u0026gt; systemd (15.04+)\nFeatures of Upstart Event Based\nStart System faster (compare with previous method). Dynamically start service when discovering new device Dynamically stop service when device is removed Systemd Systemd is a collection of system management daemons, utilities and libraries which serves as a replacement of System V init daemon. Systemd functions as central management and configuration platform for UNIX like system.\n","tags":["ubuntu"],"title":"Ubuntu init process"},{"categories":["linux","network"],"content":"Hostapd hostapd is a user space daemon for access point and authentication server.\nPlease follow the guide of Official documentation\nInstallation and configuration Tested on raspbian with raspberry pi 3\nInstall hostapd and configure it sudo apt-get install hostapd -y --force-yes, also sudo apt-get install haveged\nEdit hostapd.conf: /etc/hostapd/hostapd.conf\ninterface=wlan0 ssid=RPi wpa_passphrase=raspberrypi auth_algs=1 wpa=2 wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP channel=10 hw_mode=g There should not be any whitespace at the end of each line\nthen modify file /etc/default/hostapd to let the …","date":"2016-08-30","permalink":"https://qtopie.github.io/notes/linux/hostapd-wifi/","summary":"Hostapd hostapd is a user space daemon for access point and authentication server.\nPlease follow the guide of Official documentation\nInstallation and configuration Tested on raspbian with raspberry pi 3\nInstall hostapd and configure it sudo apt-get install hostapd -y --force-yes, also sudo apt-get install haveged\nEdit hostapd.conf: /etc/hostapd/hostapd.conf\ninterface=wlan0 ssid=RPi wpa_passphrase=raspberrypi auth_algs=1 wpa=2 wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP channel=10 hw_mode=g There should not be any whitespace at the end of each line\nthen modify file /etc/default/hostapd to let the configuration work automatically.\n","tags":["hostapd"],"title":"Wifi with hostapd"},{"categories":["tool"],"content":"本文主要分享如何使用Hugo生成静态站点，并部署到firebase (Hosting服务）上。\nupdated: 2021/9/29\n静态站点 静态站点，相比于动态站点（一般指需要请求后端动态生成网站内容）来说，网站内容已提前渲染好，对搜索引擎更加友好。而且网站内容一般可以直接生成静态的html/css页面, 减少浏览器js渲染，网络传输时也可以充分利用缓存, 这样网页加载也比较快， 使用户体验更好。\n更进一步地，Google和Twitter合作开发了AMP(Accelerated Mobile Pages)技术, 通过限定HTML标签和CSS，以及CDN缓存，提升移动设备(相比于PC端：弱网、低性能）对网站的访问速度。\n本站点就是采用了AMP技术构建, 使用静态站点生成工具根据模板，将markdown文件渲染输出为静态AMP页面。\n生成工具 静态站点生成工具有很多，我主要用过的有以下两个。（目前又换回了Hugo)\nHugo Scully PS, Hugo刚发布不久我就开始使用了，当时对这个新工具很喜欢，它是一个单独的二进制文件, 且渲染很快，模板丰富。但后面想定制一些功能（那时Hugo的文档比较少，仅官网使用文档， 且功能也没现在这么丰富), 但go的语法还是比较复杂的，也没太多时间看源码。因此当Scully出现的时候，我就立即使用了它（因为本人还是一个Angular粉），相比于 …","date":"2016-05-02","permalink":"https://qtopie.github.io/posts/hugo/getting-started-with-hugo/","summary":"本文主要分享如何使用Hugo生成静态站点，并部署到firebase (Hosting服务）上。\nupdated: 2021/9/29\n静态站点 静态站点，相比于动态站点（一般指需要请求后端动态生成网站内容）来说，网站内容已提前渲染好，对搜索引擎更加友好。而且网站内容一般可以直接生成静态的html/css页面, 减少浏览器js渲染，网络传输时也可以充分利用缓存, 这样网页加载也比较快， 使用户体验更好。\n更进一步地，Google和Twitter合作开发了AMP(Accelerated Mobile Pages)技术, 通过限定HTML标签和CSS，以及CDN缓存，提升移动设备(相比于PC端：弱网、低性能）对网站的访问速度。\n本站点就是采用了AMP技术构建, 使用静态站点生成工具根据模板，将markdown文件渲染输出为静态AMP页面。\n生成工具 静态站点生成工具有很多，我主要用过的有以下两个。（目前又换回了Hugo)\nHugo Scully PS, Hugo刚发布不久我就开始使用了，当时对这个新工具很喜欢，它是一个单独的二进制文件, 且渲染很快，模板丰富。但后面想定制一些功能（那时Hugo的文档比较少，仅官网使用文档， 且功能也没现在这么丰富), 但go的语法还是比较复杂的，也没太多时间看源码。因此当Scully出现的时候，我就立即使用了它（因为本人还是一个Angular粉），相比于Hugo，Scully几乎等同于你可以通过编写Angular应用定制你的网站, 因此十分灵活（主要的缺点是主题和应用代码分开进程渲染，调试略麻烦）。但后面发现，我本身写博客主题的时间可能比我写博客还花的多：》，也是该冷静下想想我的初衷是什么了。其实就是为了记录一些知识并分享，因此AMP才是我的需要。所以我决定我的博客主题的核心是简洁并对阅读友好, 而不是增添许多看其来很有趣的功能。\n博客主题 这里列出我用过的博客主题\nHugo\nRobust amp-blog-theme Scully\nmdblog-theme 以下内容主要介绍Hugo使用\n安装和创建站点 目标 在本地电脑安装hugo, 在github上创建私有仓库posts，存放markdown源码及图片等文件； 在github创建私有仓库qtopie.web.app（作为集成仓库）, 对应于站点名称，存放站点配置文件。 创建firebase hosting项目，将站点qtopie.web.app发布到firebase. 仓库创建过程省略\nHugo安装 以在Ubuntu 20.04上为例\nsudo snap install hugo 本地生成站点 初始化git各模块\n// git clone ... ; cd \u0026lt;repo\u0026gt; hugo new site . git submodule add https://github.com/qtopierw/amp-blog-theme.git themes/amp-blog-theme git submodule add git@github.com:\u0026lt;username\u0026gt;/posts.git content/posts 创建.gitignore文件, 并加入public目录\n","tags":["hugo"],"title":"使用Hugo生成静态站点"},{"categories":null,"content":"介绍 Ubuntu是一个以桌面应用为主的Linux操作系统，基于Debian发行版和GNOME桌面环境(17.10又回到gnome)，与Debian的不同在于它每6个月会发布一个新版本。Ubuntu的目标在于为一般用户提供一个最新的、同时又相当稳定的主要由自由软件构建而成的操作系统。Ubuntu具有庞大的社区力量（如askubuntu)，用户可以方便地从社区获得帮助。对于我个人而言，最吸引的是Ubuntu的开放性及活跃的社区,在Ubuntu上做开发也更加得心应手。\n系统安装 以Ubuntu桌面版(amd64)为例\n预先准备 ISO文件 可格式化的U盘 (建议4G以上) 启动盘创建工具Rufus 在Windows上使用Rufus工具，将系统镜像文件写入到U盘。\n安装过程 参考以下步骤完成安装\n重启计算机进入bios设置开机顺序（找到在StartUp选项修改，设置usb优先启动），或重启时直接按F12（或其他FN)或Enter等进入设置（不同主板进入方法可能不同）。\n启动进入了ubuntu安装引导界面，开始安装过程\n-[连接网络]\n说明一下，如果选择安装第三方软件，安装过程耗时较长，如果网速很慢的话，建议先不安装，可安装好系统后在使用时根据系统提示安装。网速快的话就另当别论了。\n[安装类型] 调整分区 此处可以设置管理员账户，建议耐心点一次设置好就ok了\n开始安装 安装完成后，重新启动 …","date":"2014-11-17","permalink":"https://qtopie.github.io/notes/linux/getting-started-with-ubuntu/","summary":"介绍 Ubuntu是一个以桌面应用为主的Linux操作系统，基于Debian发行版和GNOME桌面环境(17.10又回到gnome)，与Debian的不同在于它每6个月会发布一个新版本。Ubuntu的目标在于为一般用户提供一个最新的、同时又相当稳定的主要由自由软件构建而成的操作系统。Ubuntu具有庞大的社区力量（如askubuntu)，用户可以方便地从社区获得帮助。对于我个人而言，最吸引的是Ubuntu的开放性及活跃的社区,在Ubuntu上做开发也更加得心应手。\n系统安装 以Ubuntu桌面版(amd64)为例\n预先准备 ISO文件 可格式化的U盘 (建议4G以上) 启动盘创建工具Rufus 在Windows上使用Rufus工具，将系统镜像文件写入到U盘。\n安装过程 参考以下步骤完成安装\n重启计算机进入bios设置开机顺序（找到在StartUp选项修改，设置usb优先启动），或重启时直接按F12（或其他FN)或Enter等进入设置（不同主板进入方法可能不同）。\n启动进入了ubuntu安装引导界面，开始安装过程\n-[连接网络]\n说明一下，如果选择安装第三方软件，安装过程耗时较长，如果网速很慢的话，建议先不安装，可安装好系统后在使用时根据系统提示安装。网速快的话就另当别论了。\n[安装类型] 调整分区 此处可以设置管理员账户，建议耐心点一次设置好就ok了\n开始安装 安装完成后，重新启动计算机就ok了！\n从旧磁盘迁移Ubuntu 有时由于更换磁盘等原因，我们需要迁移Linux系统到新的磁盘。这里给出一个本人使用过的解决方案。 假设问题： 需要将HDD上装有Ubuntu 18.04的Linux系统迁移到一块空的SSD上。\n在新磁盘上创建分区(这里我只创建了一个root分区，且原系统也只有一个分区) 使用gparted在新磁盘上创建一个root分区,格式为ext4. 或者在终端下使用parted完成该操作。\n将系统文件拷贝到新磁盘的分区(建议在live usb上完成该操作) # 旧的分区在/dev/sda5上， 新磁盘为/dev/sdb dd in=/dev/sda5 of=/dev/sdb1 bs=4M conv=noerror,sync status=progress 拷贝完后，mount新磁盘确认数据已经保存到新磁盘，就可以移走旧磁盘或删除旧系统文件。\n使用live usb安装grub到新磁盘的文件系统 # mount新磁盘分区到 /mnt sudo mount /dev/sdb1 /mnt # mount当前操作系统文件必要目录 for i in sys proc run dev; do sudo mount --bind \u0026#34;/$i\u0026#34; \u0026#34;/mnt/$i\u0026#34;; done # 如果使用的是UEFI系统，也需要将它mount到mnt，这里我的UEFI在/dev/sda1上，可通过磁盘工具查看 sudo mount /dev/sda1 /mnt/boot/efi # chroot sudo chroot /mnt # 更新grub update-grub grub-install /dev/sdb update-grub exit # 重启 sudo reboot 创建swapfile (可选，如果启动时提示无swapfile使用) 首先确认swap文件是否存在 sudo swapon -s\n","tags":null,"title":"开始使用Ubuntu"},{"categories":null,"content":"gemini mcp add -s user chrome-devtools npx chrome-devtools-mcp@latest ","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/ai/gemini-cli/","summary":"gemini mcp add -s user chrome-devtools npx chrome-devtools-mcp@latest ","tags":null,"title":""},{"categories":null,"content":"","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/ai/mcp-notes/","summary":"","tags":null,"title":""},{"categories":null,"content":"","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/ai/svg/","summary":"","tags":null,"title":""},{"categories":null,"content":"Bitwise Operators List Operator Sign example AND \u0026amp;amp; 1 \u0026amp;amp; 1 = 1 OR | 1 | 0 = 1 XOR ^ 1 ^ 0 = 1 left shift \u0026amp;laquo; 1 \u0026amp;laquo; 1 = 2 right shift \u0026amp;raquo; 1 \u0026amp;raquo; 1 = 0 NOT ~ ~10101 = 1010 Application data integrity Reference bitwise-operators-in-c-cpp, GeeksforGeeks ","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/algorithms/bitwise-operators/","summary":"Bitwise Operators List Operator Sign example AND \u0026amp; 1 \u0026amp; 1 = 1 OR | 1 | 0 = 1 XOR ^ 1 ^ 0 = 1 left shift \u0026laquo; 1 \u0026laquo; 1 = 2 right shift \u0026raquo; 1 \u0026raquo; 1 = 0 NOT ~ ~10101 = 1010 Application data integrity Reference bitwise-operators-in-c-cpp, GeeksforGeeks ","tags":null,"title":""},{"categories":null,"content":"链表 链表反转 判断链表是否有环 解法: 指针内存地址Hash, 快慢双指针(追及问题)\n内存地址Hash的思路是将遍历过的记录存储下来, 然后把当前访问的节点与历史节点进行比较.\n快慢双指针: 定义一个慢指针slow, 一个快指针fast, 慢指针走一次时快指针走两次. 根据物理知识, 如果链表有环, 快指针一定会追上慢指针. 而且快指针走的步数一定是慢指针的两倍, 因为快指针每次只能追赶一步, 追上的时候也就在一起了.\n如果fast和slow中间间隔一个,则本次追不上\nfast -\u0026amp;gt; node2 -\u0026amp;gt; slow -\u0026amp;gt; node4 fast和slow相邻的时候,下次追上\nfast -\u0026amp;gt; slow -\u0026amp;gt; node5 怎么找到环开始的点?\n因为快指针走的路是慢指针的两倍, 慢指针走完一圈,恰好回到环开始的地方. 而当两个指针相遇的时候, (先假设快指针恰好多走一圈)\n快慢指针同时走, 慢指针走完终点, 则快指针走完一圈再加上从开头到环入口的路才刚好走完链表的两次遍历.\n所以如果快慢指针相遇时, 从链表开头到环入口的距离和相遇点到环入口的距离相等.\n判断两个链表是否相交及求相交的部分 Reference link1 ","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/algorithms/linked-list.zh/","summary":"链表 链表反转 判断链表是否有环 解法: 指针内存地址Hash, 快慢双指针(追及问题)\n内存地址Hash的思路是将遍历过的记录存储下来, 然后把当前访问的节点与历史节点进行比较.\n快慢双指针: 定义一个慢指针slow, 一个快指针fast, 慢指针走一次时快指针走两次. 根据物理知识, 如果链表有环, 快指针一定会追上慢指针. 而且快指针走的步数一定是慢指针的两倍, 因为快指针每次只能追赶一步, 追上的时候也就在一起了.\n如果fast和slow中间间隔一个,则本次追不上\nfast -\u0026gt; node2 -\u0026gt; slow -\u0026gt; node4 fast和slow相邻的时候,下次追上\nfast -\u0026gt; slow -\u0026gt; node5 怎么找到环开始的点?\n因为快指针走的路是慢指针的两倍, 慢指针走完一圈,恰好回到环开始的地方. 而当两个指针相遇的时候, (先假设快指针恰好多走一圈)\n快慢指针同时走, 慢指针走完终点, 则快指针走完一圈再加上从开头到环入口的路才刚好走完链表的两次遍历.\n所以如果快慢指针相遇时, 从链表开头到环入口的距离和相遇点到环入口的距离相等.\n判断两个链表是否相交及求相交的部分 Reference link1 ","tags":null,"title":""},{"categories":null,"content":"常见计算机算法知识纲要 以下按主题分组梳理常见算法与必备知识，便于快速索引与系统复习。\n核心概念 复杂度分析: 时间/空间、摊还；渐进符号 O/Θ/Ω；常见 O(1)/O(log n)/O(n log n)。 递推与主定理: 分治类递归复杂度估计与解法选择。 正确性证明: 不变式、数学归纳、反证；贪心的交换论证/割性质。 随机化与概率: 随机快速选择/快速排序、哈希冲突的期望分析。 数据结构 线性结构: 数组、链表、栈、队列、双端队列。 哈希结构: 集合/映射、开放定址/拉链法、布隆过滤器。 堆与优先队列: 二叉堆、d 叉堆、斐波那契堆（理论）。 树结构: BST、AVL/红黑树、Trie、线段树、树状数组（Fenwick）。 并查集: 合并-查找，按秩合并 + 路径压缩。 算法范式 分治: 归并排序、快速排序、最近点对。 动态规划: 状态设计、转移、路径还原；子序列/背包/区间/树形/状压。 贪心: 区间调度、哈夫曼编码、活动选择；需可证的贪心选择性质。 回溯与剪枝: 组合/排列/子集、N 皇后、数独；分支限界。 双指针与滑动窗口: 最长子串、最短覆盖、和为定值子数组。 前缀与差分: 前缀和/积、二维前缀、差分与区间更新。 二分（答案/位置）: 单调性判定 + 检验函数。 Meet-in-the-middle: 折半搜索、子集和等。 图论 遍历与连通: BFS/DFS、拓展岛屿/ …","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/algorithms/readme/","summary":"常见计算机算法知识纲要 以下按主题分组梳理常见算法与必备知识，便于快速索引与系统复习。\n核心概念 复杂度分析: 时间/空间、摊还；渐进符号 O/Θ/Ω；常见 O(1)/O(log n)/O(n log n)。 递推与主定理: 分治类递归复杂度估计与解法选择。 正确性证明: 不变式、数学归纳、反证；贪心的交换论证/割性质。 随机化与概率: 随机快速选择/快速排序、哈希冲突的期望分析。 数据结构 线性结构: 数组、链表、栈、队列、双端队列。 哈希结构: 集合/映射、开放定址/拉链法、布隆过滤器。 堆与优先队列: 二叉堆、d 叉堆、斐波那契堆（理论）。 树结构: BST、AVL/红黑树、Trie、线段树、树状数组（Fenwick）。 并查集: 合并-查找，按秩合并 + 路径压缩。 算法范式 分治: 归并排序、快速排序、最近点对。 动态规划: 状态设计、转移、路径还原；子序列/背包/区间/树形/状压。 贪心: 区间调度、哈夫曼编码、活动选择；需可证的贪心选择性质。 回溯与剪枝: 组合/排列/子集、N 皇后、数独；分支限界。 双指针与滑动窗口: 最长子串、最短覆盖、和为定值子数组。 前缀与差分: 前缀和/积、二维前缀、差分与区间更新。 二分（答案/位置）: 单调性判定 + 检验函数。 Meet-in-the-middle: 折半搜索、子集和等。 图论 遍历与连通: BFS/DFS、拓展岛屿/环检测/割点桥。 最短路: Dijkstra、Bellman–Ford、SPFA、Floyd–Warshall。 最小生成树: Kruskal（并查集）、Prim。 拓扑与 DAG: 拓扑排序、DAG DP、关键路径。 流与匹配: 最大流（Edmonds–Karp/Dinic）、二分图匹配（Hungarian/Hopcroft–Karp）。 字符串 模式匹配: KMP、Z-algorithm、Boyer–Moore、Rabin–Karp（滚动哈希）。 字典结构: Trie、Aho–Corasick（多模式）。 后缀结构: 后缀数组/树、LCP、后缀自动机。 其他经典: Manacher（回文）、最小表示法。 数论与计算几何 基础数论: GCD/扩展欧几里得、快速幂、模逆、CRT、筛法。 快速变换: FFT/NTT、多项式卷积、子集/莫比乌斯变换（进阶）。 计算几何: 叉积/方向判断、凸包（Graham/Andrew）、扫描线、线段相交、最近点对。 DP 优化（进阶） 单调队列优化、斜率优化（Convex Hull Trick）、分治优化、Knuth 优化、四边形不等式。 实用模式与选型 建模与归约: 归约到图/匹配/流/区间/背包等标准模型。 不变式与单调性: 为二分/贪心/单调队列提供充分条件。 规模估算经验: n≤1e5 常用 O(n log n)；n≤1e3 可用 O(n^3)；指数/状压配合小规模。 本仓库相关笔记 排序（sort） 堆与优先队列（heap） 选择算法（selection-algorithm） 二分查找（binary） 位运算技巧（bitwise-operators） 组合与排列（combination-permutation） 如需学习路线与题单，我可以按 4 周进度给出实现清单与练习集，并补充链接到上述笔记。\n","tags":null,"title":""},{"categories":null,"content":"Selection Algorithm Median of medians BFPRT Reference http://speople.csail.mit.edu/rivest/pubs/BFPRT73.pdf https://en.wikipedia.org/wiki/Median_of_medians ","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/algorithms/selection-algorithm/","summary":"Selection Algorithm Median of medians BFPRT Reference http://speople.csail.mit.edu/rivest/pubs/BFPRT73.pdf https://en.wikipedia.org/wiki/Median_of_medians ","tags":null,"title":""},{"categories":null,"content":"TimSort \u0026amp;amp; QuickSort(dual-pivot) TimSort Reference https://www.geeksforgeeks.org/timsort/ (simplified version) http://cr.openjdk.java.net/~martin/webrevs/openjdk7/timsort/raw_files/new/src/share/classes/java/util/TimSort.java (OpenJDK version) Dual pivot QuickSort Reference ","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/algorithms/sort/","summary":"TimSort \u0026amp; QuickSort(dual-pivot) TimSort Reference https://www.geeksforgeeks.org/timsort/ (simplified version) http://cr.openjdk.java.net/~martin/webrevs/openjdk7/timsort/raw_files/new/src/share/classes/java/util/TimSort.java (OpenJDK version) Dual pivot QuickSort Reference","tags":null,"title":""},{"categories":null,"content":"https://github.com/jenkinsci/kubernetes-plugin\nwar file is uncompressed under /var/jenkins_home/war\nClass files are random accessed. Not recommmend to mount with s3 (fuse), will make page slow.\nhttps://github.com/jenkinsci/kubernetes-plugin/blob/master/src/main/kubernetes/service-account.yml","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/cloud-native/cicd/jenkins/","summary":"https://github.com/jenkinsci/kubernetes-plugin\nwar file is uncompressed under /var/jenkins_home/war\nClass files are random accessed. Not recommmend to mount with s3 (fuse), will make page slow.\nhttps://github.com/jenkinsci/kubernetes-plugin/blob/master/src/main/kubernetes/service-account.yml\n","tags":null,"title":""},{"categories":null,"content":"Docker config\nhttps://medium.com/better-programming/about-using-docker-config-e967d4a74b83","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/cloud-native/docker/readme/","summary":"Docker config\nhttps://medium.com/better-programming/about-using-docker-config-e967d4a74b83\n","tags":null,"title":""},{"categories":null,"content":"Kubenetes cluster with multipass Reference Simple Guide to use cloud-init Official Cloud-init site ","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/cloud-native/k8s/kube-cluster-with-multipass/","summary":"Kubenetes cluster with multipass Reference Simple Guide to use cloud-init Official Cloud-init site ","tags":null,"title":""},{"categories":null,"content":"Quick Introduction Get started Installation Shared network via service volume sharing https://github.com/ctrox/csi-s3\nIngress Router Traefik\nhttps://docs.traefik.io/","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/cloud-native/k8s/readme/","summary":"Quick Introduction Get started Installation Shared network via service volume sharing https://github.com/ctrox/csi-s3\nIngress Router Traefik\nhttps://docs.traefik.io/\n","tags":null,"title":""},{"categories":null,"content":" vault vs cloud kms ","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/cloud-native/vault/","summary":" vault vs cloud kms ","tags":null,"title":""},{"categories":null,"content":"Quick guide for vitess addons microk8s enable dns hostpath-storage ingress\npull images behind firewall\nhttps_proxy=socks5://192.168.50.1:1080 microk8s.ctr image pull registry.k8s.io/ingress-nginx/controller:v1.5.1 check resources\n# list crd mkctl get crd # list all resource names mkctl api-resources --verbs=list -o name # list viteness cluster kind resource mkctl get VitessCluster Reference https://vitess.io/docs/16.0/get-started/operator/ ","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/cloud-native/vitess/setup/","summary":"Quick guide for vitess addons microk8s enable dns hostpath-storage ingress\npull images behind firewall\nhttps_proxy=socks5://192.168.50.1:1080 microk8s.ctr image pull registry.k8s.io/ingress-nginx/controller:v1.5.1 check resources\n# list crd mkctl get crd # list all resource names mkctl api-resources --verbs=list -o name # list viteness cluster kind resource mkctl get VitessCluster Reference https://vitess.io/docs/16.0/get-started/operator/ ","tags":null,"title":""},{"categories":null,"content":"Vitess vitess是Google开发的可伸缩、可靠的、兼容MySQL的云原生分布式数据库。\nvitess最初由谷歌开发来支持youtube, 而youtube已成为全球第二大网站，有海量的视频上传和用户访问, 足以说明该方案的可靠性。\n为什么要分库分表? 通常情况下，单库单表的方式就可以支撑绝大多数场景。\n如果流量较高，使用读写分离的方式也可以缓解数据库压力（一般读的流量比写高很多）。\n但如果记录有千万以上（或根据实际业务情况判断），当单机容量不够或单节点读写出现性能瓶颈时，就可以考虑分库分表来拆分流量了。\n分库分表方案 通常分库分表有Embedded-SDK模式和Proxy模式。\nEmbedded SDK模式的优点是，其部署架构更加简单，且去中心化。\n代表性的方案如sharding-jdbc, mycat等.\nProxy模式则对应用提供了类似标准JDBC或者DB SQL连接的方式，给应用开发者的感觉就是直接连数据库一样，基本不用关注实现细节。而且Proxy模式比较容易定制监控/自动扩缩容方案，因此运维成本一般较低。以及在代理层实现连接复用提高io性能。\n代表性的方案如vitess, sharding-proxy\n从另一个角度考虑，如果数据库要支持多个语言访问，Embedded-SDK模式就需要新的支持该语言的SDK；而Proxy模式则不用，只用标准JDBC连接即可。 …","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/cloud-native/vitess/vitess-intro/","summary":"Vitess vitess是Google开发的可伸缩、可靠的、兼容MySQL的云原生分布式数据库。\nvitess最初由谷歌开发来支持youtube, 而youtube已成为全球第二大网站，有海量的视频上传和用户访问, 足以说明该方案的可靠性。\n为什么要分库分表? 通常情况下，单库单表的方式就可以支撑绝大多数场景。\n如果流量较高，使用读写分离的方式也可以缓解数据库压力（一般读的流量比写高很多）。\n但如果记录有千万以上（或根据实际业务情况判断），当单机容量不够或单节点读写出现性能瓶颈时，就可以考虑分库分表来拆分流量了。\n分库分表方案 通常分库分表有Embedded-SDK模式和Proxy模式。\nEmbedded SDK模式的优点是，其部署架构更加简单，且去中心化。\n代表性的方案如sharding-jdbc, mycat等.\nProxy模式则对应用提供了类似标准JDBC或者DB SQL连接的方式，给应用开发者的感觉就是直接连数据库一样，基本不用关注实现细节。而且Proxy模式比较容易定制监控/自动扩缩容方案，因此运维成本一般较低。以及在代理层实现连接复用提高io性能。\n代表性的方案如vitess, sharding-proxy\n从另一个角度考虑，如果数据库要支持多个语言访问，Embedded-SDK模式就需要新的支持该语言的SDK；而Proxy模式则不用，只用标准JDBC连接即可。\nVitess特性 Vitess架构 类似于Kubernetes, Viteness的组件分为Control Plane（控制切面）和Data Plane(数据切面两部分)。\n一般Control Plane承载元数据存储、调度和管理、监控等功能，而Data Plane直接对上游提供服务，承载业务流量。\n名称 说明 VTGate Vitess网关，将流量路由到VTTablet VTTablet 一个tablet由一个mysqld进程和一个对应的vttablet进程组成，一般运行在一个机器上。 VTAdmin Vitess Web管理界面 vtctld 用来访HTTP服务器，通常用来诊断集群的状态；也为vtctlclient提供服务 vtorc vtorc即（Vitess Orchestration), 根据https://github.com/openark/orchestrator改写。主要实现mysql实例集群的复制和高可用 其他比较重要的概念\n名称 说明 Keyspace keyspace是一个逻辑上的数据库。如果不使用sharding, 它会直接映射到数据库名称; 使用sharding时，它会映射到多个mysql分库。 Shard Shard是keyspace的子集，通常是一个MySQL主库和多个MySQL从库 VSchema VSchema用来定义如何分库分表，即如何数据如何存储在keyspaces和shards。 通在路由查询和重新分片的时候用到 Cell Cell是一组servers的集合，通常是在一个可用区(availability zone)里面，与其他的cell冗灾。每一个cell有自己的拓扑服务，如上面的架构图。 TODO 多个cell的场景\n本地运行官方示例 Vitess官方提供了Vitess Operator for Kubernetes 教程，通过Kubernetes起一个近似生产环境的集群。\n","tags":null,"title":""},{"categories":null,"content":"Design Principles Dependency Injection (DI) With dependency injection, objects accept dependencies in their constructors. The core principle is to separate behaviour from dependency resolution.\nCompared with Direct constructor calls:\ndirect constructor calls Dependency Injection direct, compile-time dependency dependencies injection problems for modularity and testability dependencies are not hidden in codes See Motivation of guice.\nSample: https://github.com/google/guice/wiki/GettingStarted\n(Inversion of Control) IoC 参考维基百科 控制反转： 早在2004年，Martin Fowler就提出了“哪些方面的控制被反转了？”这个问题。他总结出是依赖对象的获得被反转了，因为 …","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/design-patterns/design-principles/","summary":"Design Principles Dependency Injection (DI) With dependency injection, objects accept dependencies in their constructors. The core principle is to separate behaviour from dependency resolution.\nCompared with Direct constructor calls:\ndirect constructor calls Dependency Injection direct, compile-time dependency dependencies injection problems for modularity and testability dependencies are not hidden in codes See Motivation of guice.\nSample: https://github.com/google/guice/wiki/GettingStarted\n(Inversion of Control) IoC 参考维基百科 控制反转： 早在2004年，Martin Fowler就提出了“哪些方面的控制被反转了？”这个问题。他总结出是依赖对象的获得被反转了，因为大多数应用程序都是由两个或是更多的类通过彼此的合作来实现企业逻辑，这使得每个对象都需要获取与其合作的对象（也就是它所依赖的对象）的引用。如果这个获取过程要靠自身实现，那么这将导致代码高度耦合并且难以维护和调试。\nCommon implementation methods Dependency Injection Dependency Lookup (ServiceReistry) AOP In computing, aspect-oriented programming (AOP) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. It does so by adding additional behavior to existing code (an advice) without modifying the code itself, instead separately specifying which code is modified via a \u0026quot;pointcut\u0026quot; specification, such as \u0026quot;log all function calls when the function's name begins with 'set'\u0026quot;. This allows behaviors that are not central to the business logic (such as logging) to be added to a program without cluttering the code, core to the functionality. AOP forms a basis for aspect-oriented software development.\n","tags":null,"title":""},{"categories":null,"content":"供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。\nhttps://blog.csdn.net/yanbober/article/details/45497881\njava prev and next traverse https://docs.oracle.com/javase/8/docs/api/java/util/ListIterator.html","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/design-patterns/iterator/","summary":"供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。\nhttps://blog.csdn.net/yanbober/article/details/45497881\njava prev and next traverse https://docs.oracle.com/javase/8/docs/api/java/util/ListIterator.html\n","tags":null,"title":""},{"categories":null,"content":"ASUS Router with Merlin Firmware AiMesh Devices\nRT-AX82U (Master) ZenWifi XD4 (RT-AX56-XD4) Firmware https://github.com/gnuton/asuswrt-merlin.ng\njffs partition User Scripts: /jffs/scripts https://github.com/RMerl/asuswrt-merlin.ng/wiki/User-scripts\nRun scripts on boot /jffs/scripts/post-mount\n#!/bin/sh if [ $1 == \u0026amp;#34;/tmp/mnt/usb\u0026amp;#34; ] \u0026amp;amp;\u0026amp;amp; [ -e \u0026amp;#34;/mnt/usb/scripts/startup.sh\u0026amp;#34; ]; then bash -c \u0026amp;#34;/mnt/usb/scripts/startup.sh\u0026amp;#34; fi content of usb-mount-hook.sh Test whether file exists, then execute script if found\n#!/bin/bash if [ -e \u0026amp;#34;/mnt/usb/scripts/startup.sh\u0026amp;#34; ]; then …","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/iot/asus-router/merlin-firmware/","summary":"ASUS Router with Merlin Firmware AiMesh Devices\nRT-AX82U (Master) ZenWifi XD4 (RT-AX56-XD4) Firmware https://github.com/gnuton/asuswrt-merlin.ng\njffs partition User Scripts: /jffs/scripts https://github.com/RMerl/asuswrt-merlin.ng/wiki/User-scripts\nRun scripts on boot /jffs/scripts/post-mount\n#!/bin/sh if [ $1 == \u0026#34;/tmp/mnt/usb\u0026#34; ] \u0026amp;\u0026amp; [ -e \u0026#34;/mnt/usb/scripts/startup.sh\u0026#34; ]; then bash -c \u0026#34;/mnt/usb/scripts/startup.sh\u0026#34; fi content of usb-mount-hook.sh Test whether file exists, then execute script if found\n","tags":null,"title":""},{"categories":null,"content":"树莓派5G NR上网折腾记 背景 每年春节回老家过年的时候，都需要解决上网的问题。基本需求是, 需要通过路由器为家里的电视、手机等设备提供一个可靠的网络覆盖，\n而且网络的质量需要满足要求。因为平时不在老家住，开通宽带一般需要按年计费，不太划算。所以之前也尝试过买流量卡, 一个月可能\n有几十G流量，然后使用树莓派和4G模块上网，共享网络给路由器满足需求。2020年春节期间隔离在家，不得不在家办公一个月,\n还开通过电信宽带。当时用的是电信129元十全十美套餐，绑定银行卡优惠30元（当时没想着长期用，就没绑定 ：\u0026amp;lt; ), 因为合约期两年\n后面出去打工后就没管了，送的三张卡也没有用。后面却发现欠费好几百，考虑可能影响到个人征信，因此又补缴了费用。相当于没有使用\n却给电信捐款， 略坑。 因此一直在调研其他的方案，来满足春节短期的上网需求。\n由于宽带一般都需要长期开通，成本才会降低。而且在人口密集的城市和乡村地区，宽带价格差异很大。基层业务人员服务也不够好,\n一不小心又会掉进坑里。所以宽带不是一个好的选择。\n5G网络的全国覆盖已经比较广了，其实4G+的网速(150Mbps~300Mbps)已经可以满足绝大多数上网场景的需求。\n而且国内的电信运营商, 如果设备支持5G的话，就算使用的是4G套餐，也会支持5G的网络。虽然会被限速，但网速依然会提升不少，延迟也相对较低。\n毕竟5G设备已经安装在 …","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/iot/rpi/portable-5g/","summary":"树莓派5G NR上网折腾记 背景 每年春节回老家过年的时候，都需要解决上网的问题。基本需求是, 需要通过路由器为家里的电视、手机等设备提供一个可靠的网络覆盖，\n而且网络的质量需要满足要求。因为平时不在老家住，开通宽带一般需要按年计费，不太划算。所以之前也尝试过买流量卡, 一个月可能\n有几十G流量，然后使用树莓派和4G模块上网，共享网络给路由器满足需求。2020年春节期间隔离在家，不得不在家办公一个月,\n还开通过电信宽带。当时用的是电信129元十全十美套餐，绑定银行卡优惠30元（当时没想着长期用，就没绑定 ：\u0026lt; ), 因为合约期两年\n后面出去打工后就没管了，送的三张卡也没有用。后面却发现欠费好几百，考虑可能影响到个人征信，因此又补缴了费用。相当于没有使用\n却给电信捐款， 略坑。 因此一直在调研其他的方案，来满足春节短期的上网需求。\n由于宽带一般都需要长期开通，成本才会降低。而且在人口密集的城市和乡村地区，宽带价格差异很大。基层业务人员服务也不够好,\n一不小心又会掉进坑里。所以宽带不是一个好的选择。\n5G网络的全国覆盖已经比较广了，其实4G+的网速(150Mbps~300Mbps)已经可以满足绝大多数上网场景的需求。\n而且国内的电信运营商, 如果设备支持5G的话，就算使用的是4G套餐，也会支持5G的网络。虽然会被限速，但网速依然会提升不少，延迟也相对较低。\n毕竟5G设备已经安装在那里，不用的话也会浪费。\n所以树莓派+5G上网模块就是一个好的选择。 剩下要做的事情就是选择一个可靠且实惠的5G上网模块和套餐资费了。\n这里不进行比较，我选择的方案就是 Rapsberrry Pi 3 + RM500U-CN + 天际通卡.\n作为一个树莓派粉，设备我当然有了，而且每一代都有(还是在低位入手的）, 暂时不计成本。\nRM500U-CN 大概需要 900块。\n天际通卡一年资费500多，但有按月的套餐99/月， 一个月的流量2000GB。非常适合我的需求。\n虽然整体成本要1000+, 比一年的100M宽带价格 800左右并没有便宜多少。 但是设备是买到是我自己的，我还可以继续折腾，\n从物品和精神上也都保值呢。\n这比开通了宽带但是没有使用依然扣费划算不少，可能只是心理舒坦 :\u0026gt;\nRM500-CN RM500U-CN是一款相对物美价廉的产品，微雪电子对其定制了扩展版和外壳天线等，简单的组装一下就可以比的上商业产品的质量。\nRM500U-CN商品链接\n天际通卡 天际通14001号码的卡支持SA网络， 14000的不支持。可以通过卡后面的号码区分。\n为了保证能买到14001卡, 我从闲鱼上找卖家购买并确认。 一般来说，华为移动路由设备送的卡是14001卡。 我买的那张卡, 应该是闲鱼卖家从回收的华为设备里单独拿出来卖的； 一个技巧是, 确认这个卡没有人使用，自己可以实名认证，防止用别人的卡充值后被别人挂失找回，造成不必要的经济损失\n组装 组装教程 https://www.waveshare.net/w/upload/8/8b/PI4-CASE-4G-5G-M.2-Assembly-cn.jpg\n实际上按照从底部往上组装的顺序比较容易。\n因为我们用的是RM500U-CN, 是通过usb(不是gpio）共享扩展版的网络到树莓派，所以需要插好A-to-A的USB接口.\n调试和使用 这里推荐安装ubuntu-server 20.04, 经测试可以运行。而且ubuntu对树莓派本身也有良好的支持，是raspbian的近亲。\n安装好ubuntu-server后，根据waveshare提供的补丁，添加USB设备描述符(vendor ID/product ID)\n","tags":null,"title":""},{"categories":null,"content":"AQS Java AQS（AbstractQueuedSynchronizer）是Java并发包（java.util.concurrent）中的一个基础同步框架。它为实现锁和其他同步器（如Semaphore、CountDownLatch、ReentrantLock等）提供了一个通用的底层机制。\n核心特点：\n基于FIFO队列：AQS通过一个基于FIFO的等待队列管理线程的同步状态。 独占与共享模式：支持独占（如ReentrantLock）和共享（如Semaphore）两种资源获取方式。 状态管理：通过一个int类型的state变量表示同步状态，子类通过继承AQS并重写相关方法实现自定义同步器。 阻塞与唤醒：AQS负责线程的阻塞与唤醒，简化了同步器的实现。 常见用法： 实现自定义锁或同步器时，继承AQS并实现tryAcquire、tryRelease等方法。 AQS极大地简化了Java并发工具的开发，是Java并发包的核心基础\n数据结构 Node abstract static class Node { volatile Node prev; // initially attached via casTail volatile Node next; // visibly nonnull when signallable Thread waiter; // visibly nonnull …","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/java/aqs/","summary":"AQS Java AQS（AbstractQueuedSynchronizer）是Java并发包（java.util.concurrent）中的一个基础同步框架。它为实现锁和其他同步器（如Semaphore、CountDownLatch、ReentrantLock等）提供了一个通用的底层机制。\n核心特点：\n基于FIFO队列：AQS通过一个基于FIFO的等待队列管理线程的同步状态。 独占与共享模式：支持独占（如ReentrantLock）和共享（如Semaphore）两种资源获取方式。 状态管理：通过一个int类型的state变量表示同步状态，子类通过继承AQS并重写相关方法实现自定义同步器。 阻塞与唤醒：AQS负责线程的阻塞与唤醒，简化了同步器的实现。 常见用法： 实现自定义锁或同步器时，继承AQS并实现tryAcquire、tryRelease等方法。 AQS极大地简化了Java并发工具的开发，是Java并发包的核心基础\n数据结构 Node abstract static class Node { volatile Node prev; // initially attached via casTail volatile Node next; // visibly nonnull when signallable Thread waiter; // visibly nonnull when enqueued volatile int status; // written by owner, atomic bit ops by others } CLH队列 CLH队列（Craig, Landin, and Hagersten队列）是一种基于链表的自旋锁队列，AQS的同步队列就是基于CLH队列实现的。\n特点：\nCLH队列是一个虚链表，节点代表等待获取锁的线程。 每个线程在本地保存一个前驱节点，通过前驱节点的状态判断自己是否可以获取锁。 线程入队时会自旋等待前驱节点释放锁，减少了竞争和CPU资源浪费。 在AQS中的应用：\nAQS通过CLH队列实现线程的有序排队和唤醒。 线程获取锁失败时，会被包装成一个Node节点加入队列尾部。 只有队列头节点的下一个节点才有资格被唤醒尝试获取锁，保证了公平性。 CLH队列的设计让AQS能够高效地管理大量线程的同步等待。\n","tags":null,"title":""},{"categories":null,"content":"参考 Java Monitor ","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/java/monitor/","summary":"参考 Java Monitor ","tags":null,"title":""},{"categories":null,"content":"The Little Linux Command Line Book CPU top\nMemory virtual memory swapfile\nfree command\nI/O ","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/linux/the-little-linux-cmd-book/","summary":"The Little Linux Command Line Book CPU top\nMemory virtual memory swapfile\nfree command\nI/O","tags":null,"title":""},{"categories":null,"content":"QUIC 需要 HTTP/3 的主要原因是为了解决 HTTP/1.1 和 HTTP/2 在使用 TCP 协议时遇到的性能瓶颈和限制，尤其是在存在丢包和网络切换的情况下。\n以下是需要 HTTP/3 的几个关键原因：\n解决 TCP 的队头阻塞 (Head-of-Line Blocking - HOLB) 问题：\nHTTP/1.1 的 HOLB: 在 HTTP/1.1 中，即使开启了 Pipelining（尽管实际应用中问题很多），在一个连接上，前一个请求的响应必须完全接收后，下一个请求的响应才能开始发送。如果中间某个请求或响应被阻塞，后续的所有请求都会被延迟。 HTTP/2 的 TCP HOLB: HTTP/2 通过多路复用（Multiplexing）解决了应用层的 HOLB，允许在同一个 TCP 连接上同时发送多个请求和接收多个响应。然而，HTTP/2 仍然运行在 TCP 协议之上。TCP 是一个保证可靠和有序传输的协议，它要求数据包按顺序到达。如果在传输过程中，某个 TCP 数据包丢失了，TCP 会暂停整个连接的数据传输，直到丢失的数据包被重传并正确插入到序列中。这意味着，即使丢失的数据包只影响到 HTTP/2 连接中的某一个流（Stream），整个连接上的所有其他流都会被这个丢包事件阻塞，等待重传完成。这就是 TCP 层的队头阻塞，它极大地影响了 HTTP/2 在丢包环境下的性能 …","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/web/quic/","summary":"QUIC 需要 HTTP/3 的主要原因是为了解决 HTTP/1.1 和 HTTP/2 在使用 TCP 协议时遇到的性能瓶颈和限制，尤其是在存在丢包和网络切换的情况下。\n以下是需要 HTTP/3 的几个关键原因：\n解决 TCP 的队头阻塞 (Head-of-Line Blocking - HOLB) 问题：\nHTTP/1.1 的 HOLB: 在 HTTP/1.1 中，即使开启了 Pipelining（尽管实际应用中问题很多），在一个连接上，前一个请求的响应必须完全接收后，下一个请求的响应才能开始发送。如果中间某个请求或响应被阻塞，后续的所有请求都会被延迟。 HTTP/2 的 TCP HOLB: HTTP/2 通过多路复用（Multiplexing）解决了应用层的 HOLB，允许在同一个 TCP 连接上同时发送多个请求和接收多个响应。然而，HTTP/2 仍然运行在 TCP 协议之上。TCP 是一个保证可靠和有序传输的协议，它要求数据包按顺序到达。如果在传输过程中，某个 TCP 数据包丢失了，TCP 会暂停整个连接的数据传输，直到丢失的数据包被重传并正确插入到序列中。这意味着，即使丢失的数据包只影响到 HTTP/2 连接中的某一个流（Stream），整个连接上的所有其他流都会被这个丢包事件阻塞，等待重传完成。这就是 TCP 层的队头阻塞，它极大地影响了 HTTP/2 在丢包环境下的性能。 HTTP/3 (基于 QUIC) 的解决方案： HTTP/3 使用了基于 UDP 的 QUIC 协议。QUIC 在应用层实现了类似 TCP 的可靠传输、流量控制和拥塞控制，但它是基于“流”来管理的。每个 HTTP 请求都被分配到一个独立的 QUIC 流。即使一个流中的数据包丢失，只会阻塞该流的传输，而同一连接上的其他流可以继续独立地传输数据，不会受到影响。这彻底解决了 TCP 层的 HOLB 问题，显著提升了在丢包率较高或网络不稳定的环境下的性能。 更快的连接建立：\n","tags":null,"title":""},{"categories":null,"content":"Fuchsia https://fuchsia.dev/fuchsia-src/get-started\nUsing mirror https://fuchsia.fsf.org.cn/#intro\nget tools mkdir fuchsia \u0026amp;amp;\u0026amp;amp; cd fuchsia curl --location --create-dirs --output .jiri_root/bin/cipd https://fuchsia.fsf.org.cn/bootstrap/cipd-linux-amd64 curl --location --create-dirs --output .jiri_root/bin/jiri https://fuchsia.fsf.org.cn/bootstrap/jiri-linux-amd64 chmod +x .jiri_root/bin/jiri .jiri_root/bin/jiri export PATH=${PATH}:${PWD}/.jiri_root/bin Download from mirror mkdir -p build \u0026amp;amp;\u0026amp;amp; echo \u0026amp;#34;internal_access = false\u0026amp;#34; \u0026amp;gt;build/cipd.gni jiri init -keep-git-hooks=true …","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/fuchsia/get-started/","summary":"Fuchsia https://fuchsia.dev/fuchsia-src/get-started\nUsing mirror https://fuchsia.fsf.org.cn/#intro\nget tools mkdir fuchsia \u0026amp;\u0026amp; cd fuchsia curl --location --create-dirs --output .jiri_root/bin/cipd https://fuchsia.fsf.org.cn/bootstrap/cipd-linux-amd64 curl --location --create-dirs --output .jiri_root/bin/jiri https://fuchsia.fsf.org.cn/bootstrap/jiri-linux-amd64 chmod +x .jiri_root/bin/jiri .jiri_root/bin/jiri export PATH=${PATH}:${PWD}/.jiri_root/bin Download from mirror mkdir -p build \u0026amp;\u0026amp; echo \u0026#34;internal_access = false\u0026#34; \u0026gt;build/cipd.gni jiri init -keep-git-hooks=true jiri import -name=integration flower https://fuchsia.fsf.org.cn/git/fuchsia-integration jiri update -v echo \u0026#34;have_firmware = false\u0026#34; \u0026gt;zircon/prebuilt/config.gni Switch back to official repos rm -rf integration jiri .jiri_manifest .jiri_root rm -rf integration jiri .jiri_manifest .jiri_root curl -s https://fuchsia.googlesource.com/jiri/+/master/scripts/bootstrap_jiri?format=TEXT | base64 --decode | bash -s ${PWD} jiri init -keep-git-hooks=true jiri import -name=integration flower https://fuchsia.googlesource.com/integration jiri update -v proxy export https_proxy=127.0.0.1:8118 use curl with socks5 proxy\n","tags":null,"title":"Build and Try Fuchsia"},{"categories":null,"content":"google ip address range\nhttps://www.gstatic.com/ipranges/goog.json\ngithub ip address range https://api.github.com/meta\n参考 https://support.google.com/a/answer/10026322?hl=en https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/about-githubs-ip-addresses ","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/dev/google-ip-address/","summary":"google ip address range\nhttps://www.gstatic.com/ipranges/goog.json\ngithub ip address range https://api.github.com/meta\n参考 https://support.google.com/a/answer/10026322?hl=en https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/about-githubs-ip-addresses ","tags":null,"title":"Google IP地址范围"},{"categories":null,"content":"xrdp Connect to Ubuntu Desktop remotely with xrdp\nEnvironment Win10 with hyper-v support Ubuntu Desktop 20.04 Install Ubuntu 20.04 on win10-hyperv Download Ubuntu Desktop 20.04 from here\nSearch Hyper-V on win10 start menu and create a virtual machine with the ISO file you just downloaded\nFollow the installation guide provided by ubuntu iso media, and setup the OS\nIt\u0026amp;rsquo;s recommended to use internal NAT network, so create a virtual network switch if necessary.\nSetup Open a terminal to install some softwares and do the setup stuffs.\n# install xrdp and vnc server sudo apt update \u0026amp;amp;\u0026amp;amp; …","date":"0001-01-01","permalink":"https://qtopie.github.io/notes/linux/remote-desktop-with-xrdp/","summary":"xrdp Connect to Ubuntu Desktop remotely with xrdp\nEnvironment Win10 with hyper-v support Ubuntu Desktop 20.04 Install Ubuntu 20.04 on win10-hyperv Download Ubuntu Desktop 20.04 from here\nSearch Hyper-V on win10 start menu and create a virtual machine with the ISO file you just downloaded\nFollow the installation guide provided by ubuntu iso media, and setup the OS\nIt\u0026rsquo;s recommended to use internal NAT network, so create a virtual network switch if necessary.\n","tags":null,"title":"xrdp"}]