<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  链表反转：深入浅出
  #


  链表反转是什么？
  #

链表反转，顾名思义，就是将一个链表的节点顺序颠倒过来。例如，原本的链表是1->2->3->4，反转后就变成4->3->2->1。

  为什么需要链表反转？
  #

链表反转是链表操作中一个非常基础且常见的操作，它在很多算法和数据结构中都有应用，比如：

栈的实现： 链表反转可以用来实现一个栈的数据结构。
队列的实现： 链表反转可以用来实现一个队列的数据结构。
算法优化： 有些算法中，通过链表反转可以优化时间或空间复杂度。


  链表反转的实现
  #


  迭代法
  #

迭代法是实现链表反转最常用的方法。其核心思想是：

初始化三个指针：

prev: 指向当前节点的前一个节点
curr: 指向当前节点
next: 指向当前节点的后一个节点


遍历链表：

将 curr 的 next 指针指向 prev，实现反转
将 prev 和 curr 指针都向后移动一位


返回新的头节点： 遍历结束后，curr 指向新的头节点

func reverseList(head *ListNode) *ListNode {
    // 初始化第一个前驱指针指向null, 即为末端
    var prev *ListNode

    for curr:= head; curr != nil; {
        // 先用临时指针next保存下一个开始位置
        next := curr.Next;
        // 将当前指针指反转
        curr.Next = prev;

        // 移动指针
        prev = curr;
        curr = next;
    }

    return prev;
}

  递归法
  #

递归法是一种更加优雅的实现方式。其核心思想是："><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://qtopie.github.io/notes/codejam/list/reverse-list/"><meta property="og:site_name" content="Blog | qtopierw"><meta property="og:title" content="链表反转"><meta property="og:description" content="链表反转：深入浅出 # 链表反转是什么？ # 链表反转，顾名思义，就是将一个链表的节点顺序颠倒过来。例如，原本的链表是1->2->3->4，反转后就变成4->3->2->1。
为什么需要链表反转？ # 链表反转是链表操作中一个非常基础且常见的操作，它在很多算法和数据结构中都有应用，比如：
栈的实现： 链表反转可以用来实现一个栈的数据结构。 队列的实现： 链表反转可以用来实现一个队列的数据结构。 算法优化： 有些算法中，通过链表反转可以优化时间或空间复杂度。 链表反转的实现 # 迭代法 # 迭代法是实现链表反转最常用的方法。其核心思想是：
初始化三个指针： prev: 指向当前节点的前一个节点 curr: 指向当前节点 next: 指向当前节点的后一个节点 遍历链表： 将 curr 的 next 指针指向 prev，实现反转 将 prev 和 curr 指针都向后移动一位 返回新的头节点： 遍历结束后，curr 指向新的头节点 func reverseList(head *ListNode) *ListNode { // 初始化第一个前驱指针指向null, 即为末端 var prev *ListNode for curr:= head; curr != nil; { // 先用临时指针next保存下一个开始位置 next := curr.Next; // 将当前指针指反转 curr.Next = prev; // 移动指针 prev = curr; curr = next; } return prev; } 递归法 # 递归法是一种更加优雅的实现方式。其核心思想是："><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2024-09-07T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-07T00:00:00+00:00"><title>链表反转 | Blog | qtopierw</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://qtopie.github.io/notes/codejam/list/reverse-list/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.6b0a5247a29534ab597c09c6ba111855ef60594896512109921af15ed6e3e547.js integrity="sha256-awpSR6KVNKtZfAnGuhEYVe9gWUiWUSEJkhrxXtbj5Uc=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Blog | qtopierw</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>链表反转</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#链表反转深入浅出>链表反转：深入浅出</a><ul><li><a href=#链表反转是什么>链表反转是什么？</a></li><li><a href=#为什么需要链表反转>为什么需要链表反转？</a></li><li><a href=#链表反转的实现>链表反转的实现</a></li><li><a href=#链表反转的复杂度分析>链表反转的复杂度分析</a></li><li><a href=#总结>总结</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h2 id=链表反转深入浅出>链表反转：深入浅出
<a class=anchor href=#%e9%93%be%e8%a1%a8%e5%8f%8d%e8%bd%ac%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba>#</a></h2><h3 id=链表反转是什么>链表反转是什么？
<a class=anchor href=#%e9%93%be%e8%a1%a8%e5%8f%8d%e8%bd%ac%e6%98%af%e4%bb%80%e4%b9%88>#</a></h3><p>链表反转，顾名思义，就是将一个链表的节点顺序颠倒过来。例如，原本的链表是1->2->3->4，反转后就变成4->3->2->1。</p><h3 id=为什么需要链表反转>为什么需要链表反转？
<a class=anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e9%93%be%e8%a1%a8%e5%8f%8d%e8%bd%ac>#</a></h3><p>链表反转是链表操作中一个非常基础且常见的操作，它在很多算法和数据结构中都有应用，比如：</p><ul><li><strong>栈的实现：</strong> 链表反转可以用来实现一个栈的数据结构。</li><li><strong>队列的实现：</strong> 链表反转可以用来实现一个队列的数据结构。</li><li><strong>算法优化：</strong> 有些算法中，通过链表反转可以优化时间或空间复杂度。</li></ul><h3 id=链表反转的实现>链表反转的实现
<a class=anchor href=#%e9%93%be%e8%a1%a8%e5%8f%8d%e8%bd%ac%e7%9a%84%e5%ae%9e%e7%8e%b0>#</a></h3><h4 id=迭代法>迭代法
<a class=anchor href=#%e8%bf%ad%e4%bb%a3%e6%b3%95>#</a></h4><p>迭代法是实现链表反转最常用的方法。其核心思想是：</p><ol><li><strong>初始化三个指针：</strong><ul><li><code>prev</code>: 指向当前节点的前一个节点</li><li><code>curr</code>: 指向当前节点</li><li><code>next</code>: 指向当前节点的后一个节点</li></ul></li><li><strong>遍历链表：</strong><ul><li>将 <code>curr</code> 的 <code>next</code> 指针指向 <code>prev</code>，实现反转</li><li>将 <code>prev</code> 和 <code>curr</code> 指针都向后移动一位</li></ul></li><li><strong>返回新的头节点：</strong> 遍历结束后，<code>curr</code> 指向新的头节点</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#069;font-weight:700>func</span> <span style=color:#c0f>reverseList</span>(head <span style=color:#555>*</span>ListNode) <span style=color:#555>*</span>ListNode {
</span></span><span style=display:flex><span>    <span style=color:#09f;font-style:italic>// 初始化第一个前驱指针指向null, 即为末端</span>
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>var</span> prev <span style=color:#555>*</span>ListNode
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>for</span> curr<span style=color:#555>:=</span> head; curr <span style=color:#555>!=</span> <span style=color:#069;font-weight:700>nil</span>; {
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic>// 先用临时指针next保存下一个开始位置</span>
</span></span><span style=display:flex><span>        next <span style=color:#555>:=</span> curr.Next;
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic>// 将当前指针指反转</span>
</span></span><span style=display:flex><span>        curr.Next = prev;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic>// 移动指针</span>
</span></span><span style=display:flex><span>        prev = curr;
</span></span><span style=display:flex><span>        curr = next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> prev;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=递归法>递归法
<a class=anchor href=#%e9%80%92%e5%bd%92%e6%b3%95>#</a></h4><p>递归法是一种更加优雅的实现方式。其核心思想是：</p><ol><li><strong>递归终止条件：</strong> 当链表为空或只有一个节点时，直接返回。</li><li><strong>递归过程：</strong><ul><li>递归反转链表的后半部分</li><li>将链表的后半部分的头节点的 <code>next</code> 指向当前节点</li><li>将当前节点的 <code>next</code> 指向 <code>nullptr</code></li></ul></li></ol><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c++ data-lang=c++><span style=display:flex><span>ListNode<span style=color:#555>*</span> <span style=color:#c0f>reverseList</span>(ListNode<span style=color:#555>*</span> head) {
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>if</span> (head <span style=color:#555>==</span> <span style=color:#069;font-weight:700>nullptr</span> <span style=color:#555>||</span> head<span style=color:#555>-&gt;</span>next <span style=color:#555>==</span> <span style=color:#069;font-weight:700>nullptr</span>) {
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>return</span> head;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ListNode<span style=color:#555>*</span> newHead <span style=color:#555>=</span> reverseList(head<span style=color:#555>-&gt;</span>next);
</span></span><span style=display:flex><span>    head<span style=color:#555>-&gt;</span>next<span style=color:#555>-&gt;</span>next <span style=color:#555>=</span> head;
</span></span><span style=display:flex><span>    head<span style=color:#555>-&gt;</span>next <span style=color:#555>=</span> <span style=color:#069;font-weight:700>nullptr</span>;
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> newHead;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=链表反转的复杂度分析>链表反转的复杂度分析
<a class=anchor href=#%e9%93%be%e8%a1%a8%e5%8f%8d%e8%bd%ac%e7%9a%84%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90>#</a></h3><ul><li><strong>时间复杂度：</strong> O(n)，其中 n 是链表的长度。无论迭代法还是递归法，都需要遍历链表一次。</li><li><strong>空间复杂度：</strong><ul><li><strong>迭代法：</strong> O(1)，只需要常数个额外空间。</li><li><strong>递归法：</strong> O(n)，递归调用栈的深度最大为 n。</li></ul></li></ul><h3 id=总结>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h3><p>链表反转是一个基础且重要的链表操作。通过迭代法和递归法，我们可以实现链表的反转。在选择实现方式时，可以根据具体情况和个人偏好来决定。</p><p><strong>想了解更多关于链表反转的细节吗？</strong> 欢迎提出更多的问题，例如：</p><ul><li>链表反转的具体应用场景有哪些？</li><li>链表反转的优化方法有哪些？</li><li>如何用其他编程语言实现链表反转？</li></ul><p><strong>我也很乐意为你提供更详细的解释和示例代码。</strong></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#链表反转深入浅出>链表反转：深入浅出</a><ul><li><a href=#链表反转是什么>链表反转是什么？</a></li><li><a href=#为什么需要链表反转>为什么需要链表反转？</a></li><li><a href=#链表反转的实现>链表反转的实现</a></li><li><a href=#链表反转的复杂度分析>链表反转的复杂度分析</a></li><li><a href=#总结>总结</a></li></ul></li></ul></nav></div></aside></main></body></html>