<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Make Eclipse Great Again | 1001問</title><link rel=stylesheet href=/css/main.min.62cae6038d6e603968789c1ad4892241dbe7709916726790d4f747b44676acb4.css integrity="sha256-YsrmA41uYDloeJwa1IkiQdvncJkWcmeQ1PdHtEZ2rLQ=" crossorigin=anonymous><link rel=stylesheet href=/css/page.min.04e6588a59b5cdf8e6830d05e505feda61acd4ff9befb3bdd33fe3e121fc9184.css integrity="sha256-BOZYilm1zfjmgw0F5QX+2mGs1P+b77O90z/j4SH8kYQ=" crossorigin=anonymous></head><body><header><nav><a href=/><h1>1001問</h1></a><div id=react-search class=search-root aria-label="Site Search"></div></nav></header><main><div class=sidebar><section class=toc><h2>Table Of Contents</h2><nav id=TableOfContents><ul><li><a href=#开发环境>开发环境</a></li><li><a href=#eclipse项目配置及依赖管理>Eclipse项目配置及依赖管理</a><ul><li><a href=#我的java项目管理方案>我的Java项目管理方案</a></li><li><a href=#gradle-buildship插件>Gradle BuildShip插件</a></li><li><a href=#刷新依赖>刷新依赖</a></li><li><a href=#自动刷新>自动刷新</a></li></ul></li><li><a href=#掌握必要的快捷键>掌握必要的快捷键</a></li></ul></nav></section></div><article><div class=metadata><h1>Make Eclipse Great Again</h1><time datetime=2019-12-28T18:07:28+08:00>December 28, 2019</time><div class=taxonomy><span id=post-categories><ul><li><strong>Categories</strong>:&nbsp;</li><li class=category-item><a href=https://qtopie.github.io/categories/development>development</a></li></ul></span><span id=post-tags><ul><li><strong>Tags</strong>:&nbsp;</li><li class=tag-item><a href=https://qtopie.github.io/tags/eclispe><em>eclispe</em></a></li><li class=tag-item><a href=https://qtopie.github.io/tags/java><em>java</em></a></li></ul></span></div></div><h1 id=eclipse--gradle>Eclipse & Gradle</h1><p>还是从那句老话开始， “工欲善其事，必先利其器”。要想熟练地完成一件事，有个好的工具往往能事半功倍。</p><blockquote><p><em>但是很多时候，迷信教条最终会成了造轮子而造轮子的递归循环；选择合适的工具，并掌握它，解决好问题才是正确的方向。</em></p></blockquote><p>这里简单说说，我选择Eclispe和Gradle的原因。</p><ul><li><p>Gradle (Gradle VS Maven or Ant); 选择gradle的原因很简单，简单而清晰的语法，强大的脚本语言，快速而稳定的构建。</p></li><li><p>Eclipse (主要对比Idea, VS Code)</p><ul><li>开源及活跃而广受欢迎的社区</li><li>相对于Idea来说，个人使用经验上来看，在大Project上使用（源码多，项目多）更稳定, 且有偏向支持开源社区的因素，故使用Eclipse；VS Code对于小的Project来说还好，功能比Eclipse弱，查看多个文件及源码也不是很方便，大项目会使系统卡顿，但是小项目一般可以使用gradle + vim。</li></ul></li></ul><h2 id=开发环境>开发环境</h2><p>当前开发环境</p><ul><li>Ubuntu 19.10 x86_64</li><li>Gradle 5.6.4</li><li>Eclipse (Snap版本)</li></ul><pre tabindex=0><code>Eclipse Platform
Version: 2019-03 (4.11)
Build id: I20190307-0500
OS: Linux, v.5.3.0-24-generic, x86_64 / gtk 3.24.12
Java version: 1.8.0_171
</code></pre><h2 id=eclipse项目配置及依赖管理>Eclipse项目配置及依赖管理</h2><h3 id=我的java项目管理方案>我的Java项目管理方案</h3><p>我不喜欢将IDE文件提交到git代码仓库，在我看来，IDE的作用就是一个文本编辑器，而且从协作角度来看，不同的开发者可能会选择不同的编辑器，所以不需要将IDE文件提交。 而Gradle脚本，不仅作为项目开发中一款重要的工具，而且包含了很多项目配置信息，因此需要提交到git仓库(有时候，如果开发人员和CI使用了统一的或兼容的gradle版本，甚至gradle wrapper都不需要提交)</p><ul><li>生成项目配置</li></ul><p>默认Gradle eclipse编译输出目录为bin, 但是gradle构建输出目录为build， 因此需要改配置。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-groovy data-lang=groovy><span style=display:flex><span>plugins <span style=color:#555>{</span>
</span></span><span style=display:flex><span>  id <span style=color:#c30>&#39;java&#39;</span>
</span></span><span style=display:flex><span>  id <span style=color:#c30>&#39;eclipse&#39;</span>
</span></span><span style=display:flex><span><span style=color:#555>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>eclipse <span style=color:#555>{</span>
</span></span><span style=display:flex><span>    project<span style=color:#555>.</span><span style=color:#309>natures</span> <span style=color:#c30>&#39;org.eclipse.buildship.core.gradleprojectnature&#39;</span>
</span></span><span style=display:flex><span>    classpath <span style=color:#555>{</span>
</span></span><span style=display:flex><span>        downloadJavadoc <span style=color:#555>=</span> <span style=color:#069;font-weight:700>true</span>
</span></span><span style=display:flex><span>        downloadSources <span style=color:#555>=</span> <span style=color:#069;font-weight:700>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        defaultOutputDir <span style=color:#555>=</span> file<span style=color:#555>(</span><span style=color:#c30>&#39;build/default&#39;</span><span style=color:#555>)</span>
</span></span><span style=display:flex><span>        file<span style=color:#555>.</span><span style=color:#309>whenMerged</span> <span style=color:#555>{</span>
</span></span><span style=display:flex><span>            entries<span style=color:#555>.</span><span style=color:#309>each</span> <span style=color:#555>{</span>
</span></span><span style=display:flex><span>                source <span style=color:#555>-&gt;</span>
</span></span><span style=display:flex><span>                    <span style=color:#09f;font-style:italic>// This seems kludgy.  If the second test is omitted, it fails processing a &#39;Project Dependency&#39; entry
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>                    <span style=color:#069;font-weight:700>if</span> <span style=color:#555>(</span>source<span style=color:#555>.</span><span style=color:#309>kind</span> <span style=color:#555>==</span> <span style=color:#c30>&#39;src&#39;</span> <span style=color:#555>&amp;&amp;</span> source<span style=color:#555>.</span><span style=color:#309>hasProperty</span><span style=color:#555>(</span><span style=color:#c30>&#39;output&#39;</span><span style=color:#555>))</span> <span style=color:#555>{</span>
</span></span><span style=display:flex><span>                        <span style=color:#078;font-weight:700>def</span> outputPath <span style=color:#555>=</span> source<span style=color:#555>.</span><span style=color:#309>output</span>
</span></span><span style=display:flex><span>                        <span style=color:#069;font-weight:700>switch</span><span style=color:#555>(</span>source<span style=color:#555>.</span><span style=color:#309>path</span><span style=color:#555>)</span> <span style=color:#555>{</span>
</span></span><span style=display:flex><span>                            <span style=color:#069;font-weight:700>case</span> <span style=color:#c30>&#39;src/main/java&#39;</span><span style=color:#555>:</span>
</span></span><span style=display:flex><span>                              source<span style=color:#555>.</span><span style=color:#309>output</span> <span style=color:#555>=</span> <span style=color:#c30>&#39;build/classes/java/main&#39;</span>
</span></span><span style=display:flex><span>                              <span style=color:#069;font-weight:700>break</span>
</span></span><span style=display:flex><span>                            <span style=color:#069;font-weight:700>case</span> <span style=color:#c30>&#39;src/main/resources&#39;</span><span style=color:#555>:</span>
</span></span><span style=display:flex><span>                              source<span style=color:#555>.</span><span style=color:#309>output</span> <span style=color:#555>=</span> <span style=color:#c30>&#39;build/resources/main&#39;</span>
</span></span><span style=display:flex><span>                              <span style=color:#069;font-weight:700>break</span>
</span></span><span style=display:flex><span>                            <span style=color:#069;font-weight:700>case</span> <span style=color:#c30>&#39;src/test/java&#39;</span><span style=color:#555>:</span>
</span></span><span style=display:flex><span>                              source<span style=color:#555>.</span><span style=color:#309>output</span> <span style=color:#555>=</span> <span style=color:#c30>&#39;build/classes/java/test&#39;</span>
</span></span><span style=display:flex><span>                              <span style=color:#069;font-weight:700>break</span>
</span></span><span style=display:flex><span>                            <span style=color:#069;font-weight:700>case</span> <span style=color:#c30>&#39;src/test/resources&#39;</span><span style=color:#555>:</span>
</span></span><span style=display:flex><span>                              source<span style=color:#555>.</span><span style=color:#309>output</span> <span style=color:#555>=</span> <span style=color:#c30>&#39;build/resources/test&#39;</span>
</span></span><span style=display:flex><span>                              <span style=color:#069;font-weight:700>break</span>
</span></span><span style=display:flex><span>                        <span style=color:#555>}</span>
</span></span><span style=display:flex><span>                    <span style=color:#555>}</span>
</span></span><span style=display:flex><span>            <span style=color:#555>}</span>
</span></span><span style=display:flex><span>        <span style=color:#555>}</span>
</span></span><span style=display:flex><span>    <span style=color:#555>}</span>
</span></span><span style=display:flex><span><span style=color:#555>}</span>
</span></span></code></pre></div><blockquote><p><a href=https://github.com/gradle/gradle/issues/3839>https://github.com/gradle/gradle/issues/3839</a></p></blockquote><h3 id=gradle-buildship插件>Gradle BuildShip插件</h3><ul><li>UT</li></ul><p><strong>命令方式</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>gradle <span style=color:#366>test</span> --tests a.b.c.d.ClassA.methodX
</span></span></code></pre></div><p><strong>IDE方式</strong></p><p><img src=make-gradle-work-with-eclipse.assets/gradle-eclipse-ut.png alt="Run as Gradle tests"></p><p>测试结果可以通过下图方式查看，具体错误信息点击show failure就可以看到。</p><p><img src=make-gradle-work-with-eclipse.assets/gradle-eclipse-ut-result.png alt=测试结果></p><ul><li>Debug</li></ul><p>命令方式， 需要远程debug。使用<code>--debug-jvm</code>命令监听socket端口，默认5005, 然后使用Eclipse attach上就可以了。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>gradle <span style=color:#366>test</span> --debug-jvm --tests a.b.c.d.ClassA.methodX
</span></span></code></pre></div><p>或者直接用IDE Debug As &ndash;> Gradle Test就可以了</p><h3 id=刷新依赖>刷新依赖</h3><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>gradle eclipse --refresh-dependencies
</span></span></code></pre></div><p>解决IDEA 无法刷新snapshot依赖</p><pre tabindex=0><code>configurations.all {
    resolutionStrategy.cacheDynamicVersionsFor 10, &#39;minutes&#39;
    resolutionStrategy.cacheChangingModulesFor 10, &#39;minutes&#39;
}
</code></pre><h3 id=自动刷新>自动刷新</h3><p><em>因为SringBoot的“hotreload”方案并不是真正的热部署（动态类加载机制），所以这里就称它为自动刷新。</em></p><p>这里主要需要改动的是，将eclipse默认输出目录<code>bin</code>改为<code>build</code>, 对应于gradle java插件默认构建输出目录。参考上面配置，然后勾选<code>Project -> Build automatically</code> 就可以了。</p><p>对于代码量比较大，但是机器性能不佳的情况，请酌情考虑，否则太卡影响开发工作。</p><h2 id=掌握必要的快捷键>掌握必要的快捷键</h2><p>熟悉常用快捷键能迅速提高开发效率，不用键盘和鼠标切来切去，影响敲代码。而且当Eclipse很卡时，快捷键相比鼠标移动能降低资源消耗。
参考 <a href=https://github.com/artificerpi/devbox/blob/master/ide/eclipse.md>https://github.com/artificerpi/devbox/blob/master/ide/eclipse.md</a></p><div id=react-single-actions data-post-id=1b121ac3ed4b7206c73ef7b7f80f2fd0></div></article><script type=module>

const toc = document.querySelector('#TableOfContents');
if (toc) {
  
  toc.addEventListener('click', (e) => {
    const a = e.target.closest('a');
    if (!a) return;
    const id = a.getAttribute('href')?.replace('#','');
    const target = id ? document.getElementById(id) : null;
    if (target) {
      e.preventDefault();
      target.scrollIntoView({ behavior: 'smooth', block: 'start' });
      history.replaceState(null, '', `#${id}`);
    }
  });

  
  const headings = Array.from(document.querySelectorAll('article h1, article h2, article h3, article h4'));
  const linkMap = new Map();
  for (const a of toc.querySelectorAll('a[href^="#"]')) {
    const id = a.getAttribute('href').slice(1);
    linkMap.set(id, a);
  }

  const setActive = (id) => {
    for (const a of linkMap.values()) a.classList.remove('is-active');
    const active = linkMap.get(id);
    if (active) active.classList.add('is-active');
  };

  const observer = new IntersectionObserver((entries) => {
    
    const visible = entries
      .filter(e => e.isIntersecting)
      .sort((a, b) => a.target.getBoundingClientRect().top - b.target.getBoundingClientRect().top);
    if (visible.length) {
      const id = visible[0].target.id;
      if (id) setActive(id);
    }
  }, {
    root: null,
    rootMargin: '-96px 0px -60% 0px', 
    threshold: [0, 1e-3, 0.25]
  });

  headings.forEach(h => {
    
    if (!h.id) {
      h.id = h.textContent.trim().toLowerCase().replace(/\s+/g, '-');
    }
    observer.observe(h);
  });

  
  if (location.hash) {
    const target = document.getElementById(location.hash.slice(1));
    if (target) {
      setTimeout(() => target.scrollIntoView({ behavior: 'smooth', block: 'start' }), 0);
    }
  }
}
</script><script type=module src=/react/page.bundle.js></script></main><footer><div class=copyright><small>Made with <span style=color:#e25555>&#9829;</span> in Guangzhou by
©<a href=https://github.com/qtopie>qtopie</a> 2025
</small><small>Posts licensed under <a href=https://creativecommons.org/licenses/by/4.0/legalcode>CC BY 4.0</small></div><div><script type=module src=/react/base.bundle.js></script></div></footer></body></html>