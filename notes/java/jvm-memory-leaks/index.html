<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>JVM内存泄漏排查 | 1001問</title><link rel=stylesheet href=/css/main.min.dcb41abaa5ea2698ebf89f814bc6b8060470b6414061437dac2ee0e3ef5d3b45.css integrity="sha256-3LQauqXqJpjr+J+BS8a4BgRwtkFAYUN9rC7g4+9dO0U=" crossorigin=anonymous><link rel=stylesheet href=/css/page.min.81d92e4ce9b8dc4e8a2018a7aee70f76bd7fb6884d929d5fd74e3f959f06e2f5.css integrity="sha256-gdkuTOm43E6KIBinrucPdr1/tohNkp1f104/lZ8G4vU=" crossorigin=anonymous><link rel=stylesheet href=/css/syntax.min.e114b8cc38f57d520f373580c935a518bc6afd6dec4f1d682365cdbcf5c8218a.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css crossorigin=anonymous referrerpolicy=no-referrer><script src=/js/toc.min.87636f25caf644980403a5c1ce8b0812cfd10d1e53c08f181547966799ceccdb.js integrity="sha256-h2NvJcr2RJgEA6XBzosIEs/RDR5TwI8YFUeWZ5nOzNs=" crossorigin=anonymous type=module defer></script><script src=/js/copy-code.min.3bea0de4cfe8670f94a5d75c177f07b58fc90178efdea7f2a21449798d75b2c9.js integrity="sha256-O+oN5M/oZw+UpddcF38HtY/JAXjv3qfyohRJeY11ssk=" crossorigin=anonymous defer></script><script defer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script defer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js crossorigin=anonymous referrerpolicy=no-referrer onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})'></script><script src=/js/katex-block.min.2cf531bbcc318aadf5661baa2d0987ab5cb4daef473e108b1da714a37cff0b25.js integrity="sha256-LPUxu8wxiq31ZhuqLQmHq1y02u9HPhCLHacUo3z/CyU=" crossorigin=anonymous defer></script></head><body><header><nav><a href=/><h1>1001問</h1></a><div id=react-search class=search-root aria-label="Site Search"></div></nav></header><main><div class=sidebar><section class=toc><nav id=TableOfContents><ul><li><a href=#堆内存泄漏>堆内存泄漏</a><ul><li><a href=#第一步准备工作避坑指南>第一步：准备工作（避坑指南）</a></li><li><a href=#第二步一键生成嫌疑人报告-小白快速模式>第二步：一键生成“嫌疑人报告” (小白/快速模式)</a></li><li><a href=#第三步手动深度分析-专家模式>第三步：手动深度分析 (专家模式)</a></li><li><a href=#-一个真实的分析案例-模拟>💡 一个真实的分析案例 (模拟)</a></li><li><a href=#高级必杀技oql-对象查询语言>高级必杀技：OQL (对象查询语言)</a></li></ul></li></ul></nav></section></div><article id=content><div class=metadata><h1>JVM内存泄漏排查</h1><time datetime=2024-11-23T00:00:00+00:00>November 23, 2024</time><div class=taxonomy></div></div><h2 id=堆内存泄漏>堆内存泄漏</h2><p>长生命周期的对象，持有短生命周期对象的引用，导致后者无法被 GC 回收。</p><p>我们先来简单造一个典型的错误案例。我们有一个内存cache, 然后key是object类型</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>java.util.HashSet</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>java.util.Set</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>java.util.concurrent.TimeUnit</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 模拟由“可变哈希值”导致的内存泄漏
</span></span></span><span class=line><span class=cl><span class=cm> * 场景：对象存入 HashSet/HashMap 后，修改了参与 hashCode 计算的字段，导致无法被删除。
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>MutableKeyLeakDemo</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 1. 静态容器，模拟全局缓存</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>Set</span><span class=o>&lt;</span><span class=n>KeyObject</span><span class=o>&gt;</span><span class=w> </span><span class=n>LEAK_SET</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashSet</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 定义一个“不守规矩”的 Key 对象
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>static</span><span class=w> </span><span class=kd>class</span> <span class=nc>KeyObject</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 为了让内存占用明显，每个对象携带 50KB 数据</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>private</span><span class=w> </span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>payload</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>byte</span><span class=o>[</span><span class=n>50</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>1024</span><span class=o>]</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>public</span><span class=w> </span><span class=nf>KeyObject</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>id</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>this</span><span class=p>.</span><span class=na>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 【致命操作】提供了一个 Setter 修改参与 Hash 计算的字段</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>setId</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>id</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>this</span><span class=p>.</span><span class=na>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// hashCode 依赖于 id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>hashCode</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// equals 也依赖于 id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>equals</span><span class=p>(</span><span class=n>Object</span><span class=w> </span><span class=n>o</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>o</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>o</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>getClass</span><span class=p>()</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>o</span><span class=p>.</span><span class=na>getClass</span><span class=p>())</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>KeyObject</span><span class=w> </span><span class=n>keyObject</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>KeyObject</span><span class=p>)</span><span class=w> </span><span class=n>o</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>keyObject</span><span class=p>.</span><span class=na>id</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>InterruptedException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;=== 应用程序启动 ===&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;请打开 VisualVM 连接... (等待 10 秒)&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>TimeUnit</span><span class=p>.</span><span class=na>SECONDS</span><span class=p>.</span><span class=na>sleep</span><span class=p>(</span><span class=n>10</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;=== 开始测试：存入 -&gt; 修改 -&gt; 尝试删除 ===&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>10000</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// A. 创建对象，此时 id = i (比如 0)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>KeyObject</span><span class=w> </span><span class=n>key</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>KeyObject</span><span class=p>(</span><span class=n>i</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// B. 放入 Set</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// Set 根据 hashCode(0) 把它放到了 &#34;桶A&#34; 里</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>LEAK_SET</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>key</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// C. 【关键泄漏点】修改 id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 此时对象的 id 变成了 99999+i，hashCode 也变了！</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>key</span><span class=p>.</span><span class=na>setId</span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>99999</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// D. 尝试删除这个对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// Set 调用 key.hashCode()，算出的是新 ID 对应的 &#34;桶B&#34;。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// Set 去 &#34;桶B&#34; 里找，当然找不到（因为对象其实还在 &#34;桶A&#34; 里躺着）。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>boolean</span><span class=w> </span><span class=n>success</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>LEAK_SET</span><span class=p>.</span><span class=na>remove</span><span class=p>(</span><span class=n>key</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 验证是否删除失败</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>success</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;删除成功 (这行代码永远不会执行)&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>            
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 每 500 个打印一次日志，避免刷屏</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>500</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;尝试删除第 &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; 个对象 | 删除结果: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=p>(</span><span class=n>success</span><span class=w> </span><span class=o>?</span><span class=w> </span><span class=s>&#34;成功&#34;</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=s>&#34;失败&#34;</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=o>+</span><span class=w> </span><span class=s>&#34; | 当前 Set 大小: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>LEAK_SET</span><span class=p>.</span><span class=na>size</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>TimeUnit</span><span class=p>.</span><span class=na>MILLISECONDS</span><span class=p>.</span><span class=na>sleep</span><span class=p>(</span><span class=n>20</span><span class=p>);</span><span class=w> </span><span class=c1>// 稍微停顿，观察内存曲线</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;=== 循环结束 ===&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 理论上我们执行了 10000 次 add 和 10000 次 remove，Set 应该是空的。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 但实际上...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;预期 Set 大小: 0&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;实际 Set 大小: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>LEAK_SET</span><span class=p>.</span><span class=na>size</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;内存未释放，因为这些对象在 Set 中迷失了。&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 保持运行以便 Dump</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>synchronized</span><span class=w> </span><span class=p>(</span><span class=n>MutableKeyLeakDemo</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>MutableKeyLeakDemo</span><span class=p>.</span><span class=na>class</span><span class=p>.</span><span class=na>wait</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>如何避免这种泄漏？
铁律： 放入 HashMap/HashSet 的 Key 类，其参与 hashCode 和 equals 计算的字段必须是不可变（Immutable）的（即用 final 修饰）。</p><p>最佳实践： 尽量使用 String、Integer 这种天然不可变的类作为 Key。如果必须用自定义对象，请确保不要提供 setXxx 方法修改关键字段。</p><p>使用 Eclipse MAT (Memory Analyzer Tool) 分析内存泄漏，通常遵循一套标准的**“侦探破案”流程**。</p><p>MAT 不像 VisualVM 那样直观（全是图表），它是<strong>基于数据和引用关系</strong>的。只要掌握了核心套路，任何泄漏都无所遁形。</p><p>这是我为你整理的<strong>MAT 标准分析三部曲</strong>：</p><hr><h3 id=第一步准备工作避坑指南>第一步：准备工作（避坑指南）</h3><p>在打开 <code>.hprof</code> 文件之前，有一个新手最容易遇到的“坑”需要避开：</p><ul><li><strong>调整 MAT 自身的内存：</strong>
MAT 解析 Dump 文件时，需要把文件索引加载到自己的内存中。如果你的 Dump 文件是 8GB，而 MAT 默认配置只有 1GB，它自己会先崩掉。<ul><li><strong>操作：</strong> 找到 MAT 安装目录下的 <code>MemoryAnalyzer.ini</code>。</li><li><strong>修改：</strong> 把 <code>-Xmx1024m</code> 改大，通常建议设置为 Dump 文件大小的 <strong>1.2 倍左右</strong>（例如 <code>-Xmx10g</code>）。</li></ul></li></ul><hr><h3 id=第二步一键生成嫌疑人报告-小白快速模式>第二步：一键生成“嫌疑人报告” (小白/快速模式)</h3><p>这是 MAT 最贴心的功能。当你打开文件时，它会弹出一个 Wizard 向导。</p><ol><li>选择 <strong>&ldquo;Leak Suspects Report&rdquo;</strong> (泄漏嫌疑报告)。</li><li><strong>看饼图：</strong> MAT 会自动计算支配树，并给你画一个饼图。如果饼图中有一块巨大的切片占据了 80%~90% 的面积，恭喜你，问题基本找到了。</li><li><strong>看描述：</strong> 点击饼图下方的 <code>Details</code>，MAT 会直接告诉你：“一个 <code>java.util.ArrayList</code> 实例占用了 90% 的内存，它是由 <code>com.example.CacheManager</code> 的静态变量引用的。”</li></ol><blockquote><p><strong>注意：</strong> 简单的泄漏（如静态大集合）这一步就能解决了。如果报告没看出来，或者你需要更深度的分析，进入第三步。</p></blockquote><hr><h3 id=第三步手动深度分析-专家模式>第三步：手动深度分析 (专家模式)</h3><p>如果没有明显的“嫌疑人”，或者你想知道细节，请按照以下顺序操作：</p><h4 id=1-宏观概览histogram-直方图>1. 宏观概览：Histogram (直方图)</h4><ul><li><strong>入口：</strong> 点击工具栏上的柱状图图标。</li><li><strong>作用：</strong> 查看<strong>哪种类型</strong>的对象数量最多，或者占用内存最大。</li><li><strong>关键概念：</strong><ul><li><strong>Shallow Heap (浅堆)：</strong> 对象本身占用的大小（不含它引用的对象）。</li><li><strong>Retained Heap (深堆)：</strong> 对象被回收后，能释放的总内存大小（即它“支配”的所有对象）。<strong>找内存泄漏主要看这个指标！</strong></li></ul></li><li><strong>操作技巧：</strong><ul><li>在第一行的 Filter 框里输入你的包名（例如 <code>com.mycompany</code>），过滤掉 JDK 自带的类，只看自己的业务对象。</li></ul></li></ul><h4 id=2-抓大鱼dominator-tree-支配树>2. 抓大鱼：Dominator Tree (支配树)</h4><ul><li><strong>入口：</strong> 点击工具栏上的皇冠图标（或树状图图标）。</li><li><strong>作用：</strong> 这是 MAT 最强大的视图。它直接把对象按 <strong>Retained Heap</strong> 降序排列。</li><li><strong>怎么看：</strong><ul><li>排在第一位的对象就是内存里的“霸主”。</li><li>展开这个对象，你可以看到它内部持有了哪些大对象。</li><li><em>例子：</em> 你可能会看到一个 <code>StandardSession</code> 对象排第一，展开发现里面塞满了 <code>User</code> 对象。</li></ul></li></ul><h4 id=3-寻根问底path-to-gc-roots-核心操作>3. 寻根问底：Path to GC Roots (核心操作)</h4><p>当你找到一个看着不顺眼的对象（比如一个不该存在的 <code>UserContext</code>）时，你需要知道**“是谁抓着它不放”**。</p><ul><li><strong>操作步骤：</strong><ol><li>在 Histogram 或 Dominator Tree 中，右键点击该对象。</li><li>选择 <code>Path to GC Roots</code> -> <code>exclude all phantom/weak/soft etc. references</code>。</li><li><strong>为什么要排除？</strong> 因为软/弱/虚引用不会阻止 GC 回收，排除它们后，剩下的就是<strong>导致泄漏的强引用链</strong>。</li></ol></li><li><strong>分析结果：</strong><ul><li>MAT 会展示一条从 GC Root（如 <code>Thread</code> 或 <code>System Class</code>）直到你选中对象的引用链。</li><li><em>例子：</em> <code>Thread-1</code> -> <code>ThreadLocalMap</code> -> <code>Entry</code> -> <code>YourLeakingObject</code>。</li><li><strong>结论：</strong> 这就是典型的 ThreadLocal 没清理导致的泄漏。</li></ul></li></ul><h4 id=4-查看具体数据list-objects---with-outgoing-references>4. 查看具体数据：List Objects -> with outgoing references</h4><p>如果你想知道这个泄漏的大 List 里面到底存了什么数据（比如存的是哪个用户的 ID）：</p><ol><li>右键点击该 List 对象。</li><li><code>List Objects</code> -> <code>with outgoing references</code>。</li><li>打开 Inspector 窗口，你可以看到字段的具体值（String 的内容、int 的数值等）。</li></ol><hr><h3 id=-一个真实的分析案例-模拟>💡 一个真实的分析案例 (模拟)</h3><p>假设你分析一个 Tomcat 服务 OOM 的 Dump：</p><ol><li><strong>打开 Histogram</strong>，按 Retained Heap 排序。</li><li>发现 <code>char[]</code> (字符数组) 占用极高。这通常是 String 太多，但 <code>char[]</code> 看不出业务含义。</li><li><strong>右键 <code>char[]</code></strong> -> <code>List Objects</code> -> <code>with incoming references</code> (查看谁引用了这些数组)。</li><li>发现全是 <code>java.lang.String</code> 引用了它们。</li><li><strong>回到 Histogram</strong>，直接看 <code>java.lang.String</code>，再次查找 Incoming References。</li><li>发现这些 String 大部分被一个 <code>java.util.HashMap</code> 的 <code>Node</code> 引用。</li><li><strong>查找 Path to GC Roots</strong>：发现这个 HashMap 被一个名为 <code>GlobalConfig</code> 的静态变量引用。</li><li><strong>破案：</strong> 开发者在 <code>GlobalConfig</code> 里做了一个无限增长的日志缓存。</li></ol><hr><h3 id=高级必杀技oql-对象查询语言>高级必杀技：OQL (对象查询语言)</h3><p>如果你知道你要找什么，MAT 支持类 SQL 的查询。</p><ul><li><strong>入口：</strong> 工具栏上的 <code>OQL</code> 按钮。</li><li><strong>场景：</strong> “帮我找出所有 email 包含 &rsquo;test&rsquo; 的 User 对象”。</li><li><strong>语句示例：</strong><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>com</span><span class=p>.</span><span class=n>example</span><span class=p>.</span><span class=k>User</span><span class=w> </span><span class=n>u</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>toString</span><span class=p>(</span><span class=n>u</span><span class=p>.</span><span class=n>email</span><span class=p>)</span><span class=w> </span><span class=k>LIKE</span><span class=w> </span><span class=s2>&#34;.*test.*&#34;</span><span class=w>
</span></span></span></code></pre></div></li></ul><p><strong>我可以为你做的是：</strong></p><p>如果你现在手头有 Dump 文件，或者你正在看某个具体的视图卡住了，<strong>你可以把 MAT 里的那一行截图描述给我（比如“我看到了一个 ArrayList 占了 500MB，它的 Incoming Ref 是&mldr;”）</strong>，我来帮你解读这代表什么代码逻辑。</p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream<div id=react-app-components data-post-id=a45f3666a73e54449c428482938d1181></div>=======
>>>>>>> Stashed changes</article><div id=react-single-actions data-post-id=a45f3666a73e54449c428482938d1181></div>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream
<button class=mobile-toc-trigger aria-controls=mobile-toc aria-expanded=false title=Index>☰</button><div class=mobile-toc-overlay hidden></div><div id=mobile-toc class=mobile-toc-drawer aria-hidden=true role=dialog aria-label=Index><div class=mobile-toc-header><button class=mobile-toc-close aria-label=close>×</button></div><nav class=mobile-toc-body><div class=mobile-toc-list></div></nav><div class=mobile-safe-area-spacer></div></div>=======
<link rel=stylesheet href=/react/alphatab/alphaTab.css>>>>>>>> Stashed changes
<script type=module src=/react/page.bundle.js></script></main><footer><div class=copyright><small>Made with <span style=color:#e25555>&#9829;</span> in Guangzhou by
©<a href=https://github.com/qtopie>qtopie</a> 2026
</small><small>Posts licensed under <a href=https://creativecommons.org/licenses/by/4.0/legalcode>CC BY 4.0</small></div><div><script type=module src=/react/base.bundle.js></script></div></footer></body></html>