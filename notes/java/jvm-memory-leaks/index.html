<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>JVM内存泄漏排查 | 1001問</title><link rel=stylesheet href=/css/main.min.62cae6038d6e603968789c1ad4892241dbe7709916726790d4f747b44676acb4.css integrity="sha256-YsrmA41uYDloeJwa1IkiQdvncJkWcmeQ1PdHtEZ2rLQ=" crossorigin=anonymous><link rel=stylesheet href=/css/page.min.04e6588a59b5cdf8e6830d05e505feda61acd4ff9befb3bdd33fe3e121fc9184.css integrity="sha256-BOZYilm1zfjmgw0F5QX+2mGs1P+b77O90z/j4SH8kYQ=" crossorigin=anonymous></head><body><header><nav><a href=/><h1>1001問</h1></a><div id=react-search class=search-root aria-label="Site Search"></div></nav></header><main><div class=sidebar><section class=toc><h2>Table Of Contents</h2><nav id=TableOfContents><ul><li><a href=#堆内存泄漏>堆内存泄漏</a><ul><li><a href=#第一步准备工作避坑指南>第一步：准备工作（避坑指南）</a></li><li><a href=#第二步一键生成嫌疑人报告-小白快速模式>第二步：一键生成“嫌疑人报告” (小白/快速模式)</a></li><li><a href=#第三步手动深度分析-专家模式>第三步：手动深度分析 (专家模式)</a></li><li><a href=#-一个真实的分析案例-模拟>💡 一个真实的分析案例 (模拟)</a></li><li><a href=#高级必杀技oql-对象查询语言>高级必杀技：OQL (对象查询语言)</a></li></ul></li></ul></nav></section></div><article><div class=metadata><h1>JVM内存泄漏排查</h1><time datetime=2024-11-23T00:00:00+00:00>November 23, 2024</time><div class=taxonomy></div></div><h2 id=堆内存泄漏>堆内存泄漏</h2><p>长生命周期的对象，持有短生命周期对象的引用，导致后者无法被 GC 回收。</p><p>我们先来简单造一个典型的错误案例。我们有一个内存cache, 然后key是object类型</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#069;font-weight:700>import</span><span style=color:#bbb> </span><span style=color:#0cf;font-weight:700>java.util.HashSet</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>import</span><span style=color:#bbb> </span><span style=color:#0cf;font-weight:700>java.util.Set</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>import</span><span style=color:#bbb> </span><span style=color:#0cf;font-weight:700>java.util.concurrent.TimeUnit</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#09f;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic> * 模拟由“可变哈希值”导致的内存泄漏
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic> * 场景：对象存入 HashSet/HashMap 后，修改了参与 hashCode 计算的字段，导致无法被删除。
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic> */</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>class</span> <span style=color:#0a8;font-weight:700>MutableKeyLeakDemo</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#09f;font-style:italic>// 1. 静态容器，模拟全局缓存</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>private</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>static</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>final</span><span style=color:#bbb> </span>Set<span style=color:#555>&lt;</span>KeyObject<span style=color:#555>&gt;</span><span style=color:#bbb> </span>LEAK_SET<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>new</span><span style=color:#bbb> </span>HashSet<span style=color:#555>&lt;&gt;</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#09f;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>     * 定义一个“不守规矩”的 Key 对象
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>     */</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>static</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>class</span> <span style=color:#0a8;font-weight:700>KeyObject</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#069;font-weight:700>private</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>int</span><span style=color:#bbb> </span>id;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#09f;font-style:italic>// 为了让内存占用明显，每个对象携带 50KB 数据</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#069;font-weight:700>private</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>byte</span><span style=color:#555>[]</span><span style=color:#bbb> </span>payload<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>new</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>byte</span><span style=color:#555>[</span>50<span style=color:#bbb> </span><span style=color:#555>*</span><span style=color:#bbb> </span>1024<span style=color:#555>]</span>;<span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#069;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#c0f>KeyObject</span>(<span style=color:#078;font-weight:700>int</span><span style=color:#bbb> </span>id)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#069;font-weight:700>this</span>.<span style=color:#309>id</span><span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span>id;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#09f;font-style:italic>// 【致命操作】提供了一个 Setter 修改参与 Hash 计算的字段</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#069;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>void</span><span style=color:#bbb> </span><span style=color:#c0f>setId</span>(<span style=color:#078;font-weight:700>int</span><span style=color:#bbb> </span>id)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#069;font-weight:700>this</span>.<span style=color:#309>id</span><span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span>id;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#09f;font-style:italic>// hashCode 依赖于 id</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#99f>@Override</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#069;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>int</span><span style=color:#bbb> </span><span style=color:#c0f>hashCode</span>()<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#069;font-weight:700>return</span><span style=color:#bbb> </span>id;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#09f;font-style:italic>// equals 也依赖于 id</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#99f>@Override</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#069;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>boolean</span><span style=color:#bbb> </span><span style=color:#c0f>equals</span>(Object<span style=color:#bbb> </span>o)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#069;font-weight:700>if</span><span style=color:#bbb> </span>(<span style=color:#069;font-weight:700>this</span><span style=color:#bbb> </span><span style=color:#555>==</span><span style=color:#bbb> </span>o)<span style=color:#bbb> </span><span style=color:#069;font-weight:700>return</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>true</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#069;font-weight:700>if</span><span style=color:#bbb> </span>(o<span style=color:#bbb> </span><span style=color:#555>==</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>null</span><span style=color:#bbb> </span><span style=color:#555>||</span><span style=color:#bbb> </span>getClass()<span style=color:#bbb> </span><span style=color:#555>!=</span><span style=color:#bbb> </span>o.<span style=color:#309>getClass</span>())<span style=color:#bbb> </span><span style=color:#069;font-weight:700>return</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>false</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>KeyObject<span style=color:#bbb> </span>keyObject<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span>(KeyObject)<span style=color:#bbb> </span>o;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#069;font-weight:700>return</span><span style=color:#bbb> </span>id<span style=color:#bbb> </span><span style=color:#555>==</span><span style=color:#bbb> </span>keyObject.<span style=color:#309>id</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#069;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>static</span><span style=color:#bbb> </span><span style=color:#078;font-weight:700>void</span><span style=color:#bbb> </span><span style=color:#c0f>main</span>(String<span style=color:#555>[]</span><span style=color:#bbb> </span>args)<span style=color:#bbb> </span><span style=color:#069;font-weight:700>throws</span><span style=color:#bbb> </span>InterruptedException<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>System.<span style=color:#309>out</span>.<span style=color:#309>println</span>(<span style=color:#c30>&#34;=== 应用程序启动 ===&#34;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>System.<span style=color:#309>out</span>.<span style=color:#309>println</span>(<span style=color:#c30>&#34;请打开 VisualVM 连接... (等待 10 秒)&#34;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>TimeUnit.<span style=color:#309>SECONDS</span>.<span style=color:#309>sleep</span>(10);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>System.<span style=color:#309>out</span>.<span style=color:#309>println</span>(<span style=color:#c30>&#34;=== 开始测试：存入 -&gt; 修改 -&gt; 尝试删除 ===&#34;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#069;font-weight:700>for</span><span style=color:#bbb> </span>(<span style=color:#078;font-weight:700>int</span><span style=color:#bbb> </span>i<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span>0;<span style=color:#bbb> </span>i<span style=color:#bbb> </span><span style=color:#555>&lt;</span><span style=color:#bbb> </span>10000;<span style=color:#bbb> </span>i<span style=color:#555>++</span>)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#09f;font-style:italic>// A. 创建对象，此时 id = i (比如 0)</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>KeyObject<span style=color:#bbb> </span>key<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>new</span><span style=color:#bbb> </span>KeyObject(i);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#09f;font-style:italic>// B. 放入 Set</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#09f;font-style:italic>// Set 根据 hashCode(0) 把它放到了 &#34;桶A&#34; 里</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>LEAK_SET.<span style=color:#309>add</span>(key);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#09f;font-style:italic>// C. 【关键泄漏点】修改 id</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#09f;font-style:italic>// 此时对象的 id 变成了 99999+i，hashCode 也变了！</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>key.<span style=color:#309>setId</span>(i<span style=color:#bbb> </span><span style=color:#555>+</span><span style=color:#bbb> </span>99999);<span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#09f;font-style:italic>// D. 尝试删除这个对象</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#09f;font-style:italic>// Set 调用 key.hashCode()，算出的是新 ID 对应的 &#34;桶B&#34;。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#09f;font-style:italic>// Set 去 &#34;桶B&#34; 里找，当然找不到（因为对象其实还在 &#34;桶A&#34; 里躺着）。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#078;font-weight:700>boolean</span><span style=color:#bbb> </span>success<span style=color:#bbb> </span><span style=color:#555>=</span><span style=color:#bbb> </span>LEAK_SET.<span style=color:#309>remove</span>(key);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#09f;font-style:italic>// 验证是否删除失败</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#069;font-weight:700>if</span><span style=color:#bbb> </span>(success)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span>System.<span style=color:#309>out</span>.<span style=color:#309>println</span>(<span style=color:#c30>&#34;删除成功 (这行代码永远不会执行)&#34;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>}<span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb>            
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#09f;font-style:italic>// 每 500 个打印一次日志，避免刷屏</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#069;font-weight:700>if</span><span style=color:#bbb> </span>(i<span style=color:#bbb> </span><span style=color:#555>%</span><span style=color:#bbb> </span>500<span style=color:#bbb> </span><span style=color:#555>==</span><span style=color:#bbb> </span>0)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span>System.<span style=color:#309>out</span>.<span style=color:#309>println</span>(<span style=color:#c30>&#34;尝试删除第 &#34;</span><span style=color:#bbb> </span><span style=color:#555>+</span><span style=color:#bbb> </span>i<span style=color:#bbb> </span><span style=color:#555>+</span><span style=color:#bbb> </span><span style=color:#c30>&#34; 个对象 | 删除结果: &#34;</span><span style=color:#bbb> </span><span style=color:#555>+</span><span style=color:#bbb> </span>(success<span style=color:#bbb> </span><span style=color:#555>?</span><span style=color:#bbb> </span><span style=color:#c30>&#34;成功&#34;</span><span style=color:#bbb> </span>:<span style=color:#bbb> </span><span style=color:#c30>&#34;失败&#34;</span>)<span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb>                        </span><span style=color:#555>+</span><span style=color:#bbb> </span><span style=color:#c30>&#34; | 当前 Set 大小: &#34;</span><span style=color:#bbb> </span><span style=color:#555>+</span><span style=color:#bbb> </span>LEAK_SET.<span style=color:#309>size</span>());<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span>TimeUnit.<span style=color:#309>MILLISECONDS</span>.<span style=color:#309>sleep</span>(20);<span style=color:#bbb> </span><span style=color:#09f;font-style:italic>// 稍微停顿，观察内存曲线</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>System.<span style=color:#309>out</span>.<span style=color:#309>println</span>(<span style=color:#c30>&#34;=== 循环结束 ===&#34;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#09f;font-style:italic>// 理论上我们执行了 10000 次 add 和 10000 次 remove，Set 应该是空的。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#09f;font-style:italic>// 但实际上...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>System.<span style=color:#309>out</span>.<span style=color:#309>println</span>(<span style=color:#c30>&#34;预期 Set 大小: 0&#34;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>System.<span style=color:#309>out</span>.<span style=color:#309>println</span>(<span style=color:#c30>&#34;实际 Set 大小: &#34;</span><span style=color:#bbb> </span><span style=color:#555>+</span><span style=color:#bbb> </span>LEAK_SET.<span style=color:#309>size</span>());<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>System.<span style=color:#309>out</span>.<span style=color:#309>println</span>(<span style=color:#c30>&#34;内存未释放，因为这些对象在 Set 中迷失了。&#34;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#09f;font-style:italic>// 保持运行以便 Dump</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#069;font-weight:700>synchronized</span><span style=color:#bbb> </span>(MutableKeyLeakDemo.<span style=color:#309>class</span>)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>MutableKeyLeakDemo.<span style=color:#309>class</span>.<span style=color:#309>wait</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>如何避免这种泄漏？
铁律： 放入 HashMap/HashSet 的 Key 类，其参与 hashCode 和 equals 计算的字段必须是不可变（Immutable）的（即用 final 修饰）。</p><p>最佳实践： 尽量使用 String、Integer 这种天然不可变的类作为 Key。如果必须用自定义对象，请确保不要提供 setXxx 方法修改关键字段。</p><p>使用 Eclipse MAT (Memory Analyzer Tool) 分析内存泄漏，通常遵循一套标准的**“侦探破案”流程**。</p><p>MAT 不像 VisualVM 那样直观（全是图表），它是<strong>基于数据和引用关系</strong>的。只要掌握了核心套路，任何泄漏都无所遁形。</p><p>这是我为你整理的<strong>MAT 标准分析三部曲</strong>：</p><hr><h3 id=第一步准备工作避坑指南>第一步：准备工作（避坑指南）</h3><p>在打开 <code>.hprof</code> 文件之前，有一个新手最容易遇到的“坑”需要避开：</p><ul><li><strong>调整 MAT 自身的内存：</strong>
MAT 解析 Dump 文件时，需要把文件索引加载到自己的内存中。如果你的 Dump 文件是 8GB，而 MAT 默认配置只有 1GB，它自己会先崩掉。<ul><li><strong>操作：</strong> 找到 MAT 安装目录下的 <code>MemoryAnalyzer.ini</code>。</li><li><strong>修改：</strong> 把 <code>-Xmx1024m</code> 改大，通常建议设置为 Dump 文件大小的 <strong>1.2 倍左右</strong>（例如 <code>-Xmx10g</code>）。</li></ul></li></ul><hr><h3 id=第二步一键生成嫌疑人报告-小白快速模式>第二步：一键生成“嫌疑人报告” (小白/快速模式)</h3><p>这是 MAT 最贴心的功能。当你打开文件时，它会弹出一个 Wizard 向导。</p><ol><li>选择 <strong>&ldquo;Leak Suspects Report&rdquo;</strong> (泄漏嫌疑报告)。</li><li><strong>看饼图：</strong> MAT 会自动计算支配树，并给你画一个饼图。如果饼图中有一块巨大的切片占据了 80%~90% 的面积，恭喜你，问题基本找到了。</li><li><strong>看描述：</strong> 点击饼图下方的 <code>Details</code>，MAT 会直接告诉你：“一个 <code>java.util.ArrayList</code> 实例占用了 90% 的内存，它是由 <code>com.example.CacheManager</code> 的静态变量引用的。”</li></ol><blockquote><p><strong>注意：</strong> 简单的泄漏（如静态大集合）这一步就能解决了。如果报告没看出来，或者你需要更深度的分析，进入第三步。</p></blockquote><hr><h3 id=第三步手动深度分析-专家模式>第三步：手动深度分析 (专家模式)</h3><p>如果没有明显的“嫌疑人”，或者你想知道细节，请按照以下顺序操作：</p><h4 id=1-宏观概览histogram-直方图>1. 宏观概览：Histogram (直方图)</h4><ul><li><strong>入口：</strong> 点击工具栏上的柱状图图标。</li><li><strong>作用：</strong> 查看<strong>哪种类型</strong>的对象数量最多，或者占用内存最大。</li><li><strong>关键概念：</strong><ul><li><strong>Shallow Heap (浅堆)：</strong> 对象本身占用的大小（不含它引用的对象）。</li><li><strong>Retained Heap (深堆)：</strong> 对象被回收后，能释放的总内存大小（即它“支配”的所有对象）。<strong>找内存泄漏主要看这个指标！</strong></li></ul></li><li><strong>操作技巧：</strong><ul><li>在第一行的 Filter 框里输入你的包名（例如 <code>com.mycompany</code>），过滤掉 JDK 自带的类，只看自己的业务对象。</li></ul></li></ul><h4 id=2-抓大鱼dominator-tree-支配树>2. 抓大鱼：Dominator Tree (支配树)</h4><ul><li><strong>入口：</strong> 点击工具栏上的皇冠图标（或树状图图标）。</li><li><strong>作用：</strong> 这是 MAT 最强大的视图。它直接把对象按 <strong>Retained Heap</strong> 降序排列。</li><li><strong>怎么看：</strong><ul><li>排在第一位的对象就是内存里的“霸主”。</li><li>展开这个对象，你可以看到它内部持有了哪些大对象。</li><li><em>例子：</em> 你可能会看到一个 <code>StandardSession</code> 对象排第一，展开发现里面塞满了 <code>User</code> 对象。</li></ul></li></ul><h4 id=3-寻根问底path-to-gc-roots-核心操作>3. 寻根问底：Path to GC Roots (核心操作)</h4><p>当你找到一个看着不顺眼的对象（比如一个不该存在的 <code>UserContext</code>）时，你需要知道**“是谁抓着它不放”**。</p><ul><li><strong>操作步骤：</strong><ol><li>在 Histogram 或 Dominator Tree 中，右键点击该对象。</li><li>选择 <code>Path to GC Roots</code> -> <code>exclude all phantom/weak/soft etc. references</code>。</li><li><strong>为什么要排除？</strong> 因为软/弱/虚引用不会阻止 GC 回收，排除它们后，剩下的就是<strong>导致泄漏的强引用链</strong>。</li></ol></li><li><strong>分析结果：</strong><ul><li>MAT 会展示一条从 GC Root（如 <code>Thread</code> 或 <code>System Class</code>）直到你选中对象的引用链。</li><li><em>例子：</em> <code>Thread-1</code> -> <code>ThreadLocalMap</code> -> <code>Entry</code> -> <code>YourLeakingObject</code>。</li><li><strong>结论：</strong> 这就是典型的 ThreadLocal 没清理导致的泄漏。</li></ul></li></ul><h4 id=4-查看具体数据list-objects---with-outgoing-references>4. 查看具体数据：List Objects -> with outgoing references</h4><p>如果你想知道这个泄漏的大 List 里面到底存了什么数据（比如存的是哪个用户的 ID）：</p><ol><li>右键点击该 List 对象。</li><li><code>List Objects</code> -> <code>with outgoing references</code>。</li><li>打开 Inspector 窗口，你可以看到字段的具体值（String 的内容、int 的数值等）。</li></ol><hr><h3 id=-一个真实的分析案例-模拟>💡 一个真实的分析案例 (模拟)</h3><p>假设你分析一个 Tomcat 服务 OOM 的 Dump：</p><ol><li><strong>打开 Histogram</strong>，按 Retained Heap 排序。</li><li>发现 <code>char[]</code> (字符数组) 占用极高。这通常是 String 太多，但 <code>char[]</code> 看不出业务含义。</li><li><strong>右键 <code>char[]</code></strong> -> <code>List Objects</code> -> <code>with incoming references</code> (查看谁引用了这些数组)。</li><li>发现全是 <code>java.lang.String</code> 引用了它们。</li><li><strong>回到 Histogram</strong>，直接看 <code>java.lang.String</code>，再次查找 Incoming References。</li><li>发现这些 String 大部分被一个 <code>java.util.HashMap</code> 的 <code>Node</code> 引用。</li><li><strong>查找 Path to GC Roots</strong>：发现这个 HashMap 被一个名为 <code>GlobalConfig</code> 的静态变量引用。</li><li><strong>破案：</strong> 开发者在 <code>GlobalConfig</code> 里做了一个无限增长的日志缓存。</li></ol><hr><h3 id=高级必杀技oql-对象查询语言>高级必杀技：OQL (对象查询语言)</h3><p>如果你知道你要找什么，MAT 支持类 SQL 的查询。</p><ul><li><strong>入口：</strong> 工具栏上的 <code>OQL</code> 按钮。</li><li><strong>场景：</strong> “帮我找出所有 email 包含 &rsquo;test&rsquo; 的 User 对象”。</li><li><strong>语句示例：</strong><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#069;font-weight:700>SELECT</span><span style=color:#bbb> </span><span style=color:#555>*</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>FROM</span><span style=color:#bbb> </span>com.example.<span style=color:#069;font-weight:700>User</span><span style=color:#bbb> </span>u<span style=color:#bbb> </span><span style=color:#069;font-weight:700>WHERE</span><span style=color:#bbb> </span>toString(u.email)<span style=color:#bbb> </span><span style=color:#069;font-weight:700>LIKE</span><span style=color:#bbb> </span><span style=color:#c30>&#34;.*test.*&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></li></ul><p><strong>我可以为你做的是：</strong></p><p>如果你现在手头有 Dump 文件，或者你正在看某个具体的视图卡住了，<strong>你可以把 MAT 里的那一行截图描述给我（比如“我看到了一个 ArrayList 占了 500MB，它的 Incoming Ref 是&mldr;”）</strong>，我来帮你解读这代表什么代码逻辑。</p><div id=react-single-actions data-post-id=a45f3666a73e54449c428482938d1181></div></article><script type=module>

const toc = document.querySelector('#TableOfContents');
if (toc) {
  
  toc.addEventListener('click', (e) => {
    const a = e.target.closest('a');
    if (!a) return;
    const id = a.getAttribute('href')?.replace('#','');
    const target = id ? document.getElementById(id) : null;
    if (target) {
      e.preventDefault();
      target.scrollIntoView({ behavior: 'smooth', block: 'start' });
      history.replaceState(null, '', `#${id}`);
    }
  });

  
  const headings = Array.from(document.querySelectorAll('article h1, article h2, article h3, article h4'));
  const linkMap = new Map();
  for (const a of toc.querySelectorAll('a[href^="#"]')) {
    const id = a.getAttribute('href').slice(1);
    linkMap.set(id, a);
  }

  const setActive = (id) => {
    for (const a of linkMap.values()) a.classList.remove('is-active');
    const active = linkMap.get(id);
    if (active) active.classList.add('is-active');
  };

  const observer = new IntersectionObserver((entries) => {
    
    const visible = entries
      .filter(e => e.isIntersecting)
      .sort((a, b) => a.target.getBoundingClientRect().top - b.target.getBoundingClientRect().top);
    if (visible.length) {
      const id = visible[0].target.id;
      if (id) setActive(id);
    }
  }, {
    root: null,
    rootMargin: '-96px 0px -60% 0px', 
    threshold: [0, 1e-3, 0.25]
  });

  headings.forEach(h => {
    
    if (!h.id) {
      h.id = h.textContent.trim().toLowerCase().replace(/\s+/g, '-');
    }
    observer.observe(h);
  });

  
  if (location.hash) {
    const target = document.getElementById(location.hash.slice(1));
    if (target) {
      setTimeout(() => target.scrollIntoView({ behavior: 'smooth', block: 'start' }), 0);
    }
  }
}
</script><script type=module src=/react/page.bundle.js></script></main><footer><div class=copyright><small>Made with <span style=color:#e25555>&#9829;</span> in Guangzhou by
©<a href=https://github.com/qtopie>qtopie</a> 2025
</small><small>Posts licensed under <a href=https://creativecommons.org/licenses/by/4.0/legalcode>CC BY 4.0</small></div><div><script type=module src=/react/base.bundle.js></script></div></footer></body></html>