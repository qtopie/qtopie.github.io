<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>G1 垃圾回收器（Garbage-First, G1 GC） | 1001問</title><link rel=stylesheet href=/css/main.min.194caa9c1bc917dfa8a85f5f1f9061c52cd72509dc9f189142b69308127558b3.css integrity="sha256-GUyqnBvJF9+oqF9fH5BhxSzXJQncnxiRQraTCBJ1WLM=" crossorigin=anonymous><link rel=stylesheet href=/css/page.min.81d92e4ce9b8dc4e8a2018a7aee70f76bd7fb6884d929d5fd74e3f959f06e2f5.css integrity="sha256-gdkuTOm43E6KIBinrucPdr1/tohNkp1f104/lZ8G4vU=" crossorigin=anonymous><link rel=stylesheet href=/css/syntax.min.e114b8cc38f57d520f373580c935a518bc6afd6dec4f1d682365cdbcf5c8218a.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css crossorigin=anonymous referrerpolicy=no-referrer><script src=/js/toc.min.87636f25caf644980403a5c1ce8b0812cfd10d1e53c08f181547966799ceccdb.js integrity="sha256-h2NvJcr2RJgEA6XBzosIEs/RDR5TwI8YFUeWZ5nOzNs=" crossorigin=anonymous type=module defer></script><script src=/js/copy-code.min.3bea0de4cfe8670f94a5d75c177f07b58fc90178efdea7f2a21449798d75b2c9.js integrity="sha256-O+oN5M/oZw+UpddcF38HtY/JAXjv3qfyohRJeY11ssk=" crossorigin=anonymous defer></script><script defer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script defer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js crossorigin=anonymous referrerpolicy=no-referrer onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})'></script><script src=/js/katex-block.min.2cf531bbcc318aadf5661baa2d0987ab5cb4daef473e108b1da714a37cff0b25.js integrity="sha256-LPUxu8wxiq31ZhuqLQmHq1y02u9HPhCLHacUo3z/CyU=" crossorigin=anonymous defer></script></head><body><header><nav><a href=/><h1>1001問</h1></a><div id=react-search class=search-root aria-label="Site Search"></div></nav></header><main><div class=sidebar><section class=toc><nav id=TableOfContents><ul><li><a href=#g1>G1</a></li><li><a href=#g1-的主要特点>G1 的主要特点</a></li><li><a href=#g1-垃圾回收过程>G1 垃圾回收过程</a><ul><li><a href=#触发条件>触发条件</a></li><li><a href=#回收阶段>回收阶段</a></li><li><a href=#young-only-gc-的过程>Young Only GC 的过程</a></li><li><a href=#mixed-gc-的过程>Mixed GC 的过程</a></li></ul></li><li><a href=#g1-的原理>G1 的原理</a><ul><li><a href=#g1-如何自适应-gc>G1 如何自适应 GC</a></li></ul></li><li><a href=#如何使用-g1>如何使用 G1</a></li><li><a href=#常见问题排查>常见问题排查</a><ul><li><a href=#oom内存溢出>OOM（内存溢出）</a></li><li><a href=#内存泄漏>内存泄漏</a></li><li><a href=#full-gc-频繁>Full GC 频繁</a></li></ul></li><li><a href=#g1-三色标记法>G1 三色标记法</a><ul><li><a href=#标记过程>标记过程</a></li><li><a href=#satbsnapshot-at-the-beginning算法>SATB（Snapshot-At-The-Beginning）算法</a></li><li><a href=#优势>优势</a></li><li><a href=#remembered-set>Remembered Set</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></section></div><article id=content><div class=metadata><h1>G1 垃圾回收器（Garbage-First, G1 GC）</h1><time datetime=2025-06-29T00:00:00+00:00>June 29, 2025</time><div class=taxonomy></div></div><h2 id=g1>G1</h2><p>G1垃圾回收的过程</p><p>如何实现maxPauseTime</p><p>G1的特点, 优点和缺点</p><p>G1 是 Java HotSpot 虚拟机自 JDK7u4 起提供的服务器端垃圾回收器，目标是替代 CMS，适用于大堆内存、低延迟场景。G1 通过分区、并发和自适应等机制，实现高吞吐量和可预测的停顿时间。</p><hr><h2 id=g1-的主要特点>G1 的主要特点</h2><ul><li><strong>分区管理（Region）</strong>：将堆划分为多个大小相等的 Region，每个 Region 可作为 Eden、Survivor 或 Old 区，灵活管理内存。</li><li><strong>分代收集</strong>：同时支持年轻代和老年代的垃圾收集。</li><li><strong>可预测停顿时间</strong>：允许用户设置最大停顿时间目标（如 <code>-XX:MaxGCPauseMillis</code>），G1 会自适应调整回收行为以尽量满足目标。</li><li><strong>并发与并行</strong>：支持多线程并发标记和回收，减少 Stop-The-World（STW）时间。</li><li><strong>垃圾优先</strong>：优先回收垃圾最多的 Region，提高回收效率。</li><li><strong>整体堆回收</strong>：可对整个堆进行回收，避免碎片化。</li></ul><hr><h2 id=g1-垃圾回收过程>G1 垃圾回收过程</h2><h3 id=触发条件>触发条件</h3><ul><li>年轻代空间不足时触发 Young GC。</li><li>老年代空间不足或达到阈值时触发 Mixed GC 或 Full GC。</li><li>显式调用 <code>System.gc()</code> 可能触发 Full GC。</li></ul><h3 id=回收阶段>回收阶段</h3><p>G1 的回收阶段分为两类：<strong>Young Only GC</strong> 和 <strong>Mixed GC</strong>。</p><ol><li><p><strong>Young Only GC 阶段</strong></p><ul><li>仅回收年轻代（Eden 和 Survivor 区）的 Region。</li><li>触发条件：年轻代空间不足。</li><li>过程：采用并行回收，通常伴随初始标记（Initial Mark），会发生短暂的 STW（Stop-The-World）暂停。</li><li>目标：快速回收短生命周期对象，腾出新生代空间。</li></ul><h3 id=young-only-gc-的过程>Young Only GC 的过程</h3><p>Young Only GC 主要针对年轻代（Eden 和 Survivor 区）的 Region 进行回收，流程如下：</p><ol><li><p><strong>触发条件</strong><br>当年轻代空间不足时（如 Eden 区分配失败），会触发 Young Only GC。</p></li><li><p><strong>初始标记（Initial Mark）</strong><br>该阶段会标记从 GC Roots 可达的对象，通常与 Young GC 一起发生，并伴随一次短暂的 Stop-The-World（STW）暂停。</p></li><li><p><strong>并行回收</strong><br>多个 GC 线程并行回收年轻代的 Region，将存活对象复制到 Survivor 区或晋升到老年代。</p></li><li><p><strong>释放空间</strong><br>回收后，Eden 区和部分 Survivor 区被清空，为新对象分配腾出空间。</p></li><li><p><strong>目标</strong><br>快速回收短生命周期对象，减少新生代内存压力，提高分配效率。</p></li></ol><blockquote><p>Young Only GC 不会回收老年代的 Region，主要目的是高效管理新生代对象，减少应用停顿时间。</p></blockquote></li><li><p><strong>Mixed GC 阶段</strong></p><ul><li>同时回收年轻代和部分老年代的 Region。</li><li>触发条件：老年代空间达到阈值或并发标记完成后。</li><li>过程：在多次 Mixed GC 中，优先选择垃圾比例高的老年代 Region 与年轻代一起回收，减少老年代垃圾堆积。</li><li>目标：逐步清理老年代，避免 Full GC，提升整体堆利用率。</li></ul><h3 id=mixed-gc-的过程>Mixed GC 的过程</h3><p>Mixed GC 主要同时回收年轻代（Eden 和 Survivor 区）以及部分老年代的 Region，流程如下：</p><ol><li><p><strong>触发条件</strong><br>当老年代空间达到一定阈值，或并发标记和最终标记（Remark）阶段完成后，会触发 Mixed GC。</p></li><li><p><strong>筛选回收 Region</strong><br>G1 根据并发标记结果，选择垃圾比例高的老年代 Region，与年轻代 Region 一起加入本次回收。</p></li><li><p><strong>STW 暂停</strong><br>Mixed GC 过程中会有多次短暂的 Stop-The-World（STW）暂停，用于对象标记和回收。</p></li><li><p><strong>并行回收</strong><br>多个 GC 线程并行回收被选中的年轻代和老年代 Region，将存活对象复制到 Survivor 区或晋升到老年代。</p></li><li><p><strong>多轮执行</strong><br>Mixed GC 通常不会一次性回收所有老年代垃圾 Region，而是分多轮进行，每轮优先回收垃圾比例最高的 Region，逐步清理老年代。</p></li><li><p><strong>目标</strong><br>逐步减少老年代的垃圾对象，避免 Full GC 的发生，提高堆空间利用率，保证应用的低延迟和高吞吐。</p></li></ol><blockquote><p>Mixed GC 是 G1 的核心创新之一，通过分阶段、分批次地回收老年代，提升了大堆场景下的垃圾回收效率和可预测性。</p></blockquote></li></ol><blockquote><p>G1 会根据堆的使用情况和停顿目标，动态决定执行 Young Only GC 还是 Mixed GC，从而实现高效且可预测的垃圾回收。</p></blockquote><hr><h2 id=g1-的原理>G1 的原理</h2><ul><li><strong>Region 划分</strong>：堆被划分为 2048 个左右的 Region，每个 Region 大小可配置（1MB~32MB）。</li><li><strong>Remembered Set</strong>：每个 Region 维护一个 Remembered Set，记录其他 Region 指向本 Region 的引用，支持跨 Region 并发回收。</li><li><strong>SATB 算法</strong>：并发标记阶段采用快照算法，保证标记准确性。</li><li><strong>自适应回收</strong>：根据停顿时间目标和 Region 垃圾比例，动态选择回收哪些 Region。</li></ul><hr><h3 id=g1-如何自适应-gc>G1 如何自适应 GC</h3><ul><li>用户可通过 <code>-XX:MaxGCPauseMillis</code> 设置期望的最大 GC 停顿时间。</li><li>G1 会根据应用分配速率、存活对象比例、Region 垃圾量等，动态调整每次回收的 Region 数量和类型，尽量满足停顿目标。</li></ul><hr><h2 id=如何使用-g1>如何使用 G1</h2><ul><li>启用参数：<code>-XX:+UseG1GC</code></li><li>设置堆大小：<code>-Xms</code>、<code>-Xmx</code></li><li>设置停顿目标：<code>-XX:MaxGCPauseMillis=200</code>（单位毫秒）</li><li>其他常用参数：<ul><li><code>-XX:InitiatingHeapOccupancyPercent</code>：触发并发标记的堆占用百分比（默认 45）</li><li><code>-XX:G1HeapRegionSize</code>：Region 大小</li><li><code>-XX:ParallelGCThreads</code>：GC 并行线程数</li></ul></li></ul><hr><h2 id=常见问题排查>常见问题排查</h2><h3 id=oom内存溢出>OOM（内存溢出）</h3><ul><li>检查堆大小、Region 配置、对象分配速率。</li><li>分析 GC 日志，定位内存泄漏或大对象分配。</li></ul><h3 id=内存泄漏>内存泄漏</h3><ul><li>使用 MAT、VisualVM 等工具分析堆转储文件。</li><li>检查长生命周期对象引用。</li></ul><h3 id=full-gc-频繁>Full GC 频繁</h3><ul><li>堆空间不足或碎片化严重。</li><li>老年代回收不及时，调整参数或优化代码。</li></ul><hr><h2 id=g1-三色标记法>G1 三色标记法</h2><p>G1 垃圾回收器在并发标记阶段采用<strong>三色标记法（Tri-color Marking）</strong>，用于高效、准确地识别存活对象。三色标记法将对象分为三类：</p><ul><li><strong>白色</strong>：未被访问过的对象，初始时所有对象都是白色。如果标记阶段结束后仍为白色，则认为是垃圾对象，可以回收。</li><li><strong>灰色</strong>：已被访问但其引用的对象还未全部扫描的对象。灰色对象需要进一步处理。</li><li><strong>黑色</strong>：自身已被访问且其引用的对象也都已扫描完毕的对象，表示存活对象。</li></ul><h3 id=标记过程>标记过程</h3><ol><li><p><strong>初始阶段</strong><br>所有对象为白色。GC Roots 直接引用的对象被标记为灰色，加入待处理队列。</p></li><li><p><strong>标记推进</strong><br>不断从灰色队列中取出对象，将其引用的白色对象标记为灰色，并将自身标记为黑色。如此循环，直到没有灰色对象。</p></li><li><p><strong>标记结束</strong><br>剩下的白色对象即为不可达对象，可以被回收。</p></li></ol><h3 id=satbsnapshot-at-the-beginning算法>SATB（Snapshot-At-The-Beginning）算法</h3><p>G1 在并发标记时采用 SATB 算法，确保在标记过程中对象引用的变化不会导致“漏标”或“误标”。SATB 通过记录并发标记开始时的对象引用快照，保证标记准确性。</p><h3 id=优势>优势</h3><ul><li>能高效并发地标记存活对象，减少 STW 停顿时间。</li><li>与 Remembered Set 配合，支持跨 Region 的引用追踪。</li></ul><blockquote><p>三色标记法是 G1 并发标记阶段的核心机制，保证了大堆场景下的高效和准确的垃圾回收。</p></blockquote><hr><p>除了三色标记法，垃圾回收器还有其他常见的对象可达性分析和标记方法，主要包括：</p><ul><li><p>引用计数法（Reference Counting）
每个对象维护一个引用计数，引用增加时计数加一，引用断开时计数减一，计数为零时对象可回收。
优点：实现简单，实时回收。
缺点：无法处理循环引用，现代主流 JVM 不采用。
根可达性分析（Root Set/Tracing GC）
从 GC Roots（如栈、静态变量、JNI 引用等）出发，遍历对象图，所有可达对象为存活对象。三色标记法其实是根可达性分析的并发优化实现。</p></li><li><p>分代收集（Generational Collection）
根据对象生命周期将堆划分为新生代和老年代，分别采用不同的回收策略（如复制算法、标记-清除、标记-整理等）。</p></li><li><p>标记-清除（Mark-Sweep）
先遍历对象图标记所有存活对象，然后清除未被标记的对象。</p></li><li><p>标记-整理（Mark-Compact）
标记存活对象后，将其移动到内存一端，整理内存碎片。</p></li><li><p>复制算法（Copying）
将存活对象从一块内存复制到另一块，回收整个原内存区域，常用于新生代。</p></li></ul><hr><h3 id=remembered-set>Remembered Set</h3><p>**Remembered Set（记忆集）**是 G1 垃圾回收器中用于支持跨 Region 引用追踪的重要数据结构。</p><p>在 G1 中，堆被划分为多个 Region。每个 Region 都维护一个自己的 Remembered Set，用于记录<strong>其他 Region 中的对象对本 Region 内对象的引用</strong>。这样，在进行并发和增量回收时，G1 不需要全堆扫描所有引用关系，只需关注相关的 Remembered Set，大大提升了回收效率。</p><h4 id=作用>作用</h4><ul><li>支持跨 Region 的引用追踪，保证垃圾回收时不会遗漏存活对象。</li><li>降低 GC 扫描范围，提升并发回收性能。</li><li>与写屏障（Write Barrier）配合，实时更新引用关系。</li></ul><h4 id=工作原理>工作原理</h4><ul><li>当某个 Region 外的对象引用了本 Region 的对象时，通过写屏障机制将该引用关系记录到本 Region 的 Remembered Set 中。</li><li>在回收本 Region 时，只需扫描其 Remembered Set，找到所有可能引用本 Region 的外部对象，确保标记完整性。</li></ul><blockquote><p>Remembered Set 是 G1 实现高效、可扩展垃圾回收的关键机制之一，尤其适用于大堆和高并发场景</p></blockquote><hr><h2 id=参考>参考</h2><ul><li><a href=https://docs.oracle.com/en/java/javase/17/gctuning/garbage-first-g1-garbage-collector1.html#GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573>Oracle 官方文档：G1 垃圾回收器</a></li></ul></article><div id=react-app-components data-post-id=450ddaee791acdbcaf605f91d163e287></div><button class=mobile-toc-trigger aria-controls=mobile-toc aria-expanded=false title=Index>☰</button><div class=mobile-toc-overlay hidden></div><div id=mobile-toc class=mobile-toc-drawer aria-hidden=true role=dialog aria-label=Index><div class=mobile-toc-header><button class=mobile-toc-close aria-label=close>×</button></div><nav class=mobile-toc-body><div class=mobile-toc-list></div></nav><div class=mobile-safe-area-spacer></div></div><script type=module src=/react/page.bundle.js></script></main><footer><div class=copyright><small>Made with <span style=color:#e25555>&#9829;</span> in Guangzhou by
©<a href=https://github.com/qtopie>qtopie</a> 2026
</small><small>Posts licensed under <a href=https://creativecommons.org/licenses/by/4.0/legalcode>CC BY 4.0</small></div><div><script type=module src=/react/base.bundle.js></script></div></footer></body></html>