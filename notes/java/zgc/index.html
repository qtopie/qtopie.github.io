<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>ZGC | 1001問</title><link rel=stylesheet href=/css/main.min.dcb41abaa5ea2698ebf89f814bc6b8060470b6414061437dac2ee0e3ef5d3b45.css integrity="sha256-3LQauqXqJpjr+J+BS8a4BgRwtkFAYUN9rC7g4+9dO0U=" crossorigin=anonymous><link rel=stylesheet href=/css/page.min.81d92e4ce9b8dc4e8a2018a7aee70f76bd7fb6884d929d5fd74e3f959f06e2f5.css integrity="sha256-gdkuTOm43E6KIBinrucPdr1/tohNkp1f104/lZ8G4vU=" crossorigin=anonymous><link rel=stylesheet href=/css/syntax.min.e114b8cc38f57d520f373580c935a518bc6afd6dec4f1d682365cdbcf5c8218a.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css crossorigin=anonymous referrerpolicy=no-referrer><script src=/js/toc.min.87636f25caf644980403a5c1ce8b0812cfd10d1e53c08f181547966799ceccdb.js integrity="sha256-h2NvJcr2RJgEA6XBzosIEs/RDR5TwI8YFUeWZ5nOzNs=" crossorigin=anonymous type=module defer></script><script src=/js/copy-code.min.3bea0de4cfe8670f94a5d75c177f07b58fc90178efdea7f2a21449798d75b2c9.js integrity="sha256-O+oN5M/oZw+UpddcF38HtY/JAXjv3qfyohRJeY11ssk=" crossorigin=anonymous defer></script><script defer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script defer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js crossorigin=anonymous referrerpolicy=no-referrer onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})'></script><script src=/js/katex-block.min.2cf531bbcc318aadf5661baa2d0987ab5cb4daef473e108b1da714a37cff0b25.js integrity="sha256-LPUxu8wxiq31ZhuqLQmHq1y02u9HPhCLHacUo3z/CyU=" crossorigin=anonymous defer></script></head><body><header><nav><a href=/><h1>1001問</h1></a><div id=react-search class=search-root aria-label="Site Search"></div></nav></header><main><div class=sidebar><section class=toc><nav id=TableOfContents><ul><li><a href=#zgc-简介>ZGC 简介</a><ul><li><a href=#主要特点>主要特点</a></li><li><a href=#工作原理>工作原理</a></li><li><a href=#启用方式>启用方式</a></li><li><a href=#适用场景>适用场景</a></li></ul></li><li><a href=#zgc-的垃圾回收过程>ZGC 的垃圾回收过程</a><ul><li><a href=#过程特点>过程特点</a></li></ul></li><li><a href=#zgc-的着色指针与读写屏障>ZGC 的着色指针与读写屏障</a><ul><li><a href=#着色指针colored-pointers>着色指针（Colored Pointers）</a></li><li><a href=#读写屏障readwrite-barrier>读写屏障（Read/Write Barrier）</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#zgc-中存活对象的迁移>ZGC 中存活对象的迁移</a><ul><li><a href=#总结-1>总结</a></li></ul></li><li><a href=#zgc-中-chunk-的管理方式>ZGC 中 Chunk 的管理方式</a><ul><li><a href=#1-chunk-类型>1. Chunk 类型</a></li><li><a href=#2-动态分配与回收>2. 动态分配与回收</a></li><li><a href=#3-空闲-chunk管理>3. 空闲 Chunk管理</a></li><li><a href=#4-chunk-内部结构>4. Chunk 内部结构</a></li><li><a href=#5-并发整理与碎片回收>5. 并发整理与碎片回收</a></li></ul></li><li><a href=#zgc-与-g1-的优缺点对比>ZGC 与 G1 的优缺点对比</a><ul><li><a href=#zgc-优势>ZGC 优势</a></li><li><a href=#zgc-劣势>ZGC 劣势</a></li><li><a href=#g1-优势>G1 优势</a></li><li><a href=#g1-劣势>G1 劣势</a></li><li><a href=#总结-2>总结</a></li></ul></li></ul></nav></section></div><article id=content><div class=metadata><h1>ZGC</h1><time datetime=2025-06-29T00:00:00+00:00>June 29, 2025</time><div class=taxonomy></div></div><h2 id=zgc-简介>ZGC 简介</h2><p>**ZGC（Z Garbage Collector）**是 Java HotSpot 虚拟机自 JDK 11 引入的一款可扩展、低延迟的垃圾回收器，专为大堆内存和对延迟极为敏感的应用场景设计。</p><h3 id=主要特点>主要特点</h3><ul><li><strong>超低延迟</strong>：GC 停顿时间通常不超过 1~2 毫秒，与堆大小几乎无关（即使 TB 级堆）。</li><li><strong>并发回收</strong>：大部分垃圾回收工作与应用线程并发进行，极大减少 Stop-The-World（STW）时间。</li><li><strong>可扩展性强</strong>：支持超大堆（数 TB 级别），适合大数据、在线服务等场景。</li><li><strong>Regionless 设计</strong>：不像 G1 那样分 Region，ZGC 采用按需分配的内存块（Chunk），简化内存管理。</li><li><strong>着色指针（Colored Pointers）</strong>：利用对象引用的高位存储元数据，实现高效的并发标记和转移。</li></ul><h3 id=工作原理>工作原理</h3><ol><li><strong>并发标记</strong>：与应用线程并发，标记所有可达对象。</li><li><strong>并发重定位</strong>：对象在后台被迁移到新内存，引用通过着色指针和读屏障自动修正。</li><li><strong>并发清理</strong>：回收不可达对象占用的内存。</li><li><strong>极短暂停</strong>：只有少量阶段（如初始标记、重新标记）会有极短的 STW 停顿。</li></ol><h3 id=启用方式>启用方式</h3><ul><li>JDK 11+：<code>-XX:+UseZGC</code></li><li>JDK 15+ 支持 Windows/macOS</li><li>常用参数：<ul><li><code>-Xmx</code>、<code>-Xms</code> 设置堆大小</li><li><code>-XX:ConcGCThreads</code> 并发 GC 线程数</li><li><code>-XX:MaxGCPauseMillis</code> 期望最大停顿时间</li></ul></li></ul><h3 id=适用场景>适用场景</h3><ul><li>需要极低 GC 停顿的在线服务</li><li>大内存、大对象、大吞吐量应用</li><li>金融、电商、广告、实时分析等领域</li></ul><h2 id=zgc-的垃圾回收过程>ZGC 的垃圾回收过程</h2><p>ZGC 的回收过程高度并发，主要分为以下几个阶段：</p><ol><li><p><strong>初始标记（Initial Mark）</strong></p><ul><li>标记从 GC Roots 直接可达的对象。</li><li>该阶段会有一次极短的 Stop-The-World（STW）暂停。</li></ul></li><li><p><strong>并发标记（Concurrent Mark）</strong></p><ul><li>与应用线程并发执行，遍历对象图，标记所有可达对象。</li><li>利用着色指针和读屏障，保证标记期间对象引用变更的正确性。</li></ul></li><li><p><strong>重新标记（Relocate/Remark）</strong></p><ul><li>修正并发标记期间发生变动的对象引用。</li><li>该阶段也会有一次极短的 STW 暂停。</li></ul></li><li><p><strong>并发重定位（Concurrent Relocate/Move）</strong></p><ul><li>并发地将存活对象迁移到新的内存位置。</li><li>通过着色指针和读屏障，确保引用始终指向最新位置。</li></ul></li><li><p><strong>并发清理（Concurrent Cleanup）</strong></p><ul><li>回收不可达对象占用的内存块（Chunk），释放空间。</li></ul></li></ol><h3 id=过程特点>过程特点</h3><ul><li>绝大部分工作与应用线程并发进行，只有初始标记和重新标记阶段会有极短的 STW。</li><li>对象移动和引用修正通过硬件支持的着色指针和读屏障实现，极大降低了停顿时间。</li><li>整个回收过程对应用影响极小，适合对延迟极为敏感的场景。</li></ul><h2 id=zgc-的着色指针与读写屏障>ZGC 的着色指针与读写屏障</h2><h3 id=着色指针colored-pointers>着色指针（Colored Pointers）</h3><p>ZGC 利用 64 位系统对象引用的高位（未被实际寻址使用的位）来存储元数据，这些高位被称为“着色位”。通过这些着色位，ZGC 可以为每个对象引用打上不同的“颜色”，用来表示对象在 GC 各阶段的状态（如是否已被标记、是否已被转移等）。</p><ul><li><strong>作用</strong>：<ul><li>跟踪对象的生命周期和迁移状态。</li><li>支持并发标记和并发重定位时的高效引用修正。</li></ul></li><li><strong>优势</strong>：<ul><li>不需要为每个对象单独维护额外的元数据，节省内存和提升效率。</li><li>允许对象在被移动时，引用可以自动感知并指向新地址。</li></ul></li></ul><h3 id=读写屏障readwrite-barrier>读写屏障（Read/Write Barrier）</h3><p>ZGC 在对象访问时引入了读屏障和写屏障，用于配合着色指针实现并发标记和并发重定位：</p><ul><li><p><strong>读屏障（Read Barrier）</strong></p><ul><li>每次读取对象引用时，都会检查引用的着色位。</li><li>如果对象已被迁移，读屏障会自动将引用修正为新地址，保证应用始终访问到最新的对象位置。</li><li>读屏障还用于并发标记，确保对象状态正确。</li></ul></li><li><p><strong>写屏障（Write Barrier）</strong></p><ul><li>在对象引用发生变更时，写屏障会记录引用变动，协助 GC 跟踪对象间的引用关系变化。</li><li>保证并发标记和重定位期间的引用不会丢失。</li></ul></li></ul><h3 id=总结>总结</h3><ul><li>着色指针和读写屏障是 ZGC 实现极低延迟和高并发垃圾回收的核心机制。</li><li>它们让对象可以在 GC 过程中被安全地移动和标记，且对应用线程的影响极小。</li></ul><blockquote><p>通过这两项技术，ZGC 能在 TB 级堆下实现毫秒级停顿，极大提升了 Java 应用的可扩展性和实时性。</p></blockquote><hr><blockquote><p>ZGC 是目前 Java 平台上延迟最低、可扩展性最强的垃圾回收器之一，适合对响应时间要求极高的业务场景。</p></blockquote><h2 id=zgc-中存活对象的迁移>ZGC 中存活对象的迁移</h2><p>在 ZGC 中，是否迁移存活对象主要由以下因素决定：</p><ol><li><p><strong>内存碎片整理</strong><br>当堆内出现较多碎片时，ZGC 会选择迁移存活对象，将它们移动到新的连续内存块（Chunk），以整理和回收碎片空间，提高大对象分配的成功率。</p></li><li><p><strong>内存回收策略</strong><br>ZGC 会根据当前堆的使用情况、空闲空间分布和回收效率，动态决定哪些 Chunk 需要被清理和整理。被选中的 Chunk 内的存活对象会被迁移到其他 Chunk。</p></li><li><p><strong>并发重定位阶段</strong><br>在并发重定位（Concurrent Relocate/Move）阶段，ZGC 会将需要整理的 Chunk 内的所有存活对象迁移到新位置，并更新所有相关引用（通过着色指针和读屏障实现）。</p></li><li><p><strong>分配需求</strong><br>当需要为新对象分配大块连续空间时，如果当前没有足够的连续空闲 Chunk，ZGC 也会主动迁移存活对象，释放出大块空间。</p></li></ol><h3 id=总结-1>总结</h3><ul><li>存活对象是否迁移，取决于内存碎片状况、堆空间利用率和分配需求。</li><li>迁移过程完全并发进行，对应用线程影响极小。</li><li>迁移后，所有引用会自动指向新位置，保证对象访问的正确性和一致性。</li></ul><h2 id=zgc-中-chunk-的管理方式>ZGC 中 Chunk 的管理方式</h2><p>ZGC 采用“Chunk”作为内存分配和管理的基本单位，整个堆空间被动态划分为多个大小不等的 Chunk。Chunk 的管理方式如下：</p><h3 id=1-chunk-类型>1. Chunk 类型</h3><ul><li><strong>小块（Small Chunk）</strong>：用于分配小对象。</li><li><strong>中块（Medium Chunk）</strong>：用于分配中等大小对象。</li><li><strong>大块（Large Chunk）</strong>：用于分配大对象或特殊用途。</li></ul><h3 id=2-动态分配与回收>2. 动态分配与回收</h3><ul><li>ZGC 会根据对象分配需求动态从操作系统申请新的 Chunk，也会在对象回收后将空闲 Chunk 归还或复用。</li><li>Chunk 的分配和回收完全并发进行，不影响应用线程。</li></ul><h3 id=3-空闲-chunk管理>3. 空闲 Chunk管理</h3><ul><li>ZGC 维护空闲 Chunk 的列表或池，分配新对象时优先复用空闲 Chunk，减少内存碎片和系统调用。</li><li>当空闲 Chunk 累积过多或堆压力较大时，ZGC 会主动整理和回收碎片空间。</li></ul><h3 id=4-chunk-内部结构>4. Chunk 内部结构</h3><ul><li>每个 Chunk 内部有自己的元数据区，用于记录对象分配、存活、迁移等信息。</li><li>Chunk 内部对象的分配、标记、迁移等操作均可并发完成。</li></ul><h3 id=5-并发整理与碎片回收>5. 并发整理与碎片回收</h3><ul><li>ZGC 在并发重定位阶段，会将存活对象从碎片较多的 Chunk 迁移到新的 Chunk，释放出连续空间并回收碎片。</li><li>迁移后，空闲的 Chunk 会被加入空闲池，等待后续分配或归还操作系统。</li></ul><hr><p><strong>总结</strong>：<br>ZGC 通过 Chunk 的动态分配、并发管理和主动整理，有效提升了大堆场景下的内存利用率和分配效率，极大降低了碎片化风险</p><h2 id=zgc-与-g1-的优缺点对比>ZGC 与 G1 的优缺点对比</h2><h3 id=zgc-优势>ZGC 优势</h3><ul><li><strong>超低延迟</strong>：ZGC 的 GC 停顿时间通常在 1~2 毫秒，几乎与堆大小无关，非常适合对延迟极为敏感的应用。</li><li><strong>极强可扩展性</strong>：支持数 TB 级堆，适合大数据、大内存场景。</li><li><strong>高度并发</strong>：绝大部分回收工作与应用线程并发进行，对吞吐和响应影响极小。</li><li><strong>自动整理碎片</strong>：通过并发重定位，有效缓解和整理内存碎片。</li><li><strong>Regionless 设计</strong>：内存管理更灵活，无需手动分区。</li></ul><h3 id=zgc-劣势>ZGC 劣势</h3><ul><li><strong>成熟度和兼容性</strong>：ZGC 是较新的 GC，部分老版本 JDK、平台或第三方工具支持有限。</li><li><strong>吞吐量略低</strong>：极端低延迟设计下，极高吞吐场景下可能不如 G1。</li><li><strong>诊断工具较少</strong>：生态和调优经验不如 G1 丰富。</li><li><strong>不支持 32 位 JVM</strong>：仅支持 64 位系统。</li></ul><hr><h3 id=g1-优势>G1 优势</h3><ul><li><strong>成熟稳定</strong>：G1 已成为 JDK 默认 GC，生产环境应用广泛，生态完善。</li><li><strong>可预测停顿</strong>：支持 <code>-XX:MaxGCPauseMillis</code>，可根据业务需求调整停顿目标。</li><li><strong>分代管理</strong>：新生代、老年代分区管理，适合大多数通用场景。</li><li><strong>分区（Region）机制</strong>：便于内存管理和回收策略优化。</li></ul><h3 id=g1-劣势>G1 劣势</h3><ul><li><strong>停顿时间随堆增大而增加</strong>：虽然可控，但大堆下停顿时间仍明显高于 ZGC。</li><li><strong>碎片整理能力有限</strong>：老年代碎片多时，可能导致 Full GC，影响延迟。</li><li><strong>并发能力有限</strong>：部分阶段仍需较长 STW，极端低延迟场景下不如 ZGC。</li></ul><hr><h3 id=总结-2>总结</h3><ul><li><strong>ZGC</strong> 适合对延迟极为敏感、超大堆、实时性要求高的场景。</li><li><strong>G1</strong> 适合大多数对延迟有要求但不极端、需要成熟生态和调优经验的通用场景。</li></ul><div id=react-single-actions data-post-id=b9f83167d95e0b2ac411837bd668ca54></div></article><button class=mobile-toc-trigger aria-controls=mobile-toc aria-expanded=false title=Index>☰</button><div class=mobile-toc-overlay hidden></div><div id=mobile-toc class=mobile-toc-drawer aria-hidden=true role=dialog aria-label=Index><div class=mobile-toc-header><button class=mobile-toc-close aria-label=close>×</button></div><nav class=mobile-toc-body><div class=mobile-toc-list></div></nav><div class=mobile-safe-area-spacer></div></div><script type=module src=/react/page.bundle.js></script></main><footer><div class=copyright><small>Made with <span style=color:#e25555>&#9829;</span> in Guangzhou by
©<a href=https://github.com/qtopie>qtopie</a> 2026
</small><small>Posts licensed under <a href=https://creativecommons.org/licenses/by/4.0/legalcode>CC BY 4.0</small></div><div><script type=module src=/react/base.bundle.js></script></div></footer></body></html>