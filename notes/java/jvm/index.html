<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>JVM总结 | 1001問</title><link rel=stylesheet href=/css/main.min.dcb41abaa5ea2698ebf89f814bc6b8060470b6414061437dac2ee0e3ef5d3b45.css integrity="sha256-3LQauqXqJpjr+J+BS8a4BgRwtkFAYUN9rC7g4+9dO0U=" crossorigin=anonymous><link rel=stylesheet href=/css/page.min.81d92e4ce9b8dc4e8a2018a7aee70f76bd7fb6884d929d5fd74e3f959f06e2f5.css integrity="sha256-gdkuTOm43E6KIBinrucPdr1/tohNkp1f104/lZ8G4vU=" crossorigin=anonymous><link rel=stylesheet href=/css/syntax.min.e114b8cc38f57d520f373580c935a518bc6afd6dec4f1d682365cdbcf5c8218a.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css crossorigin=anonymous referrerpolicy=no-referrer><script src=/js/toc.min.87636f25caf644980403a5c1ce8b0812cfd10d1e53c08f181547966799ceccdb.js integrity="sha256-h2NvJcr2RJgEA6XBzosIEs/RDR5TwI8YFUeWZ5nOzNs=" crossorigin=anonymous type=module defer></script><script src=/js/copy-code.min.3bea0de4cfe8670f94a5d75c177f07b58fc90178efdea7f2a21449798d75b2c9.js integrity="sha256-O+oN5M/oZw+UpddcF38HtY/JAXjv3qfyohRJeY11ssk=" crossorigin=anonymous defer></script><script defer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script defer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js crossorigin=anonymous referrerpolicy=no-referrer onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})'></script><script src=/js/katex-block.min.2cf531bbcc318aadf5661baa2d0987ab5cb4daef473e108b1da714a37cff0b25.js integrity="sha256-LPUxu8wxiq31ZhuqLQmHq1y02u9HPhCLHacUo3z/CyU=" crossorigin=anonymous defer></script></head><body><header><nav><a href=/><h1>1001問</h1></a><div id=react-search class=search-root aria-label="Site Search"></div></nav></header><main><div class=sidebar><section class=toc><nav id=TableOfContents><ul><li><a href=#总览>总览</a></li><li><a href=#主流程>主流程</a><ul><li><a href=#1-源码编译javac>1. 源码编译（javac）</a></li><li><a href=#2-类加载class-loading>2. 类加载（Class Loading）</a></li><li><a href=#3-解释执行与jit编译>3. 解释执行与JIT编译</a></li><li><a href=#4-运行期优化jit优化>4. 运行期优化（JIT优化）</a></li><li><a href=#5-执行时内存与gc>5. 执行时内存与GC</a></li></ul></li><li><a href=#关键细节>关键细节</a><ul><li><a href=#类加载触发条件主动使用>类加载触发条件（主动使用）</a></li><li><a href=#字节码验证与链接细节>字节码验证与链接细节</a></li></ul></li><li><a href=#执行与优化>执行与优化</a><ul><li><a href=#c1c2与分层编译>C1/C2与分层编译</a></li><li><a href=#常见jit优化案例>常见JIT优化案例</a></li><li><a href=#反优化deoptimization>反优化（Deoptimization）</a></li></ul></li><li><a href=#cpu与调度视角>CPU与调度视角</a><ul><li><a href=#从cpu视角理解执行流程>从CPU视角理解执行流程</a></li><li><a href=#jvm层面的cpu调度视角>JVM层面的CPU调度视角</a></li></ul></li><li><a href=#运行期监控与排查建议>运行期监控与排查建议</a></li></ul></nav></section></div><article id=content><div class=metadata><h1>JVM总结</h1><time datetime=2026-02-08T00:00:00+00:00>February 8, 2026</time><div class=taxonomy></div></div><div class=mermaid>flowchart TD
A[Java Source .java] --> B[javac Compile]
B --> C[Bytecode .class]
subgraph L[Class Loading]
D[Loading]
E[Verification]
F[Preparation]
G[Resolution]
H[Initialization]
D --> E --> F --> G --> H
end
subgraph R[Runtime Execution]
I[Interpreter Execute]
J{Hot Method?}
K[JIT Compile]
L2[Machine Code]
M[Runtime Optimization]
N[GC + Deoptimization]
I --> J
J -- No --> I
J -- Yes --> K --> L2 --> M --> N
end
C --> D
H --> I</div><h2 id=总览>总览</h2><p>从Java源码到JVM执行，大致分为“编译 -> 类加载 -> 字节码验证与链接 -> 解释/编译执行 -> 运行期优化”几个阶段。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>.java -&gt; javac -&gt; .class -&gt; 类加载/验证/链接/初始化 -&gt; 解释执行 + JIT -&gt; 运行期优化 + GC
</span></span></code></pre></div><h2 id=主流程>主流程</h2><h3 id=1-源码编译javac>1. 源码编译（javac）</h3><ul><li>输入：<code>.java</code>源码文件</li><li>输出：<code>.class</code>字节码文件</li><li>编译内容：语法/类型检查、常量折叠、语法糖解 desugar、生成字节码与调试信息（如行号表）</li></ul><blockquote><p>这一步只是把源码转换为平台无关的字节码，不生成机器码。</p></blockquote><h3 id=2-类加载class-loading>2. 类加载（Class Loading）</h3><p>当类第一次被“主动使用”时，类加载器会把<code>.class</code>读取进JVM，并生成<code>java.lang.Class</code>对象。主要步骤：</p><ul><li>加载（Loading）：从类路径、模块、网络等位置读取字节码</li><li>验证（Verification）：校验字节码格式、类型安全、栈映射等</li><li>准备（Preparation）：为静态变量分配内存并设置默认值</li><li>解析（Resolution）：将符号引用解析为直接引用</li><li>初始化（Initialization）：执行<code>&lt;clinit></code>（静态变量赋值与静态代码块）</li></ul><p>类加载器模型：Bootstrap -> Platform -> Application（自定义类加载器可打破双亲委派）。</p><blockquote><p>解析（Resolution）就是把常量池里的“符号引用”（名字+描述信息）转换成“直接引用”（JVM能直接定位到的运行时结构指针/句柄）。</p><p>符号引用：比如类名、接口名、字段名、方法名、描述符等，和具体内存地址无关。
直接引用：指向已加载类的运行时数据结构，或可直接定位方法入口的引用（例如方法表中的索引或指针）。
解析发生时机可能是链接阶段（类加载时）或首次使用（惰性解析）。解析完成后，后续调用就不必再通过名字查找，性能更高，也确保访问合法性（权限检查、存在性检查等）。</p></blockquote><h3 id=3-解释执行与jit编译>3. 解释执行与JIT编译</h3><p>JVM最初会通过解释器执行字节码；当方法被频繁调用（热点方法）时，JIT会把字节码编译成本地机器码，提升性能。</p><ul><li>解释器：启动快，执行慢</li><li>JIT（C1/C2）：启动慢，执行快</li><li>分层编译：先用C1快速编译，再用C2做更深度优化</li></ul><h3 id=4-运行期优化jit优化>4. 运行期优化（JIT优化）</h3><p>JIT会基于运行时数据做优化，例如：</p><ul><li>方法内联</li><li>逃逸分析与标量替换</li><li>去虚拟化（单态调用）</li><li>循环展开、消除范围检查</li></ul><p>这些优化是“有条件”的，如果运行时假设不成立，JVM会触发反优化并回退到解释执行。</p><h3 id=5-执行时内存与gc>5. 执行时内存与GC</h3><p>程序运行时主要在堆和方法区（元空间）分配对象和类元数据，GC负责回收无用对象。常见阶段：</p><ul><li>新生代（Minor GC）</li><li>老年代（Major/Full GC）</li><li>元空间回收（类卸载）</li></ul><h2 id=关键细节>关键细节</h2><h3 id=类加载触发条件主动使用>类加载触发条件（主动使用）</h3><p>JVM只会在类被“主动使用”时初始化，常见触发场景：</p><ul><li><code>new</code>一个类实例</li><li>访问类的静态字段（非<code>final</code>编译期常量）</li><li>调用类的静态方法</li><li>反射调用</li><li>初始化子类时先初始化父类</li><li>作为程序入口（包含<code>main</code>方法的类）</li></ul><p>被动引用不会触发初始化，如：</p><ul><li>通过数组引用类（<code>SomeClass[]</code>）</li><li>访问<code>static final</code>编译期常量</li><li>仅获取<code>Class</code>对象但不触发初始化（某些反射路径）</li></ul><h3 id=字节码验证与链接细节>字节码验证与链接细节</h3><p>验证主要为了安全和类型一致性，分为四类检查：</p><ul><li>文件格式验证：魔数、版本、常量池结构</li><li>元数据验证：类继承、接口实现、字段方法描述符</li><li>字节码验证：操作数栈/局部变量表类型匹配、控制流合法</li><li>符号引用验证：访问权限、引用目标存在</li></ul><p>链接阶段包括：</p><ul><li>准备：为静态变量分配内存并设置默认值（非显式赋值）</li><li>解析：把常量池符号引用解析为直接引用</li></ul><h2 id=执行与优化>执行与优化</h2><h3 id=c1c2与分层编译>C1/C2与分层编译</h3><ul><li>C1（Client Compiler）：编译速度快，优化较保守</li><li>C2（Server Compiler）：编译慢，优化深入</li><li>分层编译：先C1快速编译，再用C2替换热点机器码</li></ul><p>常用参数（仅示意）：</p><ul><li><code>-XX:+TieredCompilation</code></li><li><code>-XX:TieredStopAtLevel=1</code>（只用C1）</li><li><code>-XX:-TieredCompilation</code>（只用C2）</li></ul><h3 id=常见jit优化案例>常见JIT优化案例</h3><ul><li>方法内联：把小方法内联到调用点，减少调用开销</li><li>去虚拟化：单态调用点变成直接调用</li><li>逃逸分析：对象不逃逸线程时做栈上分配或标量替换</li><li>锁消除/锁粗化：删除无竞争锁或合并锁</li><li>循环优化：展开、范围检查消除</li></ul><h3 id=反优化deoptimization>反优化（Deoptimization）</h3><p>JIT依赖运行时假设（比如类型单态）。当假设失效：</p><ul><li>触发反优化，已编译代码回退到解释器</li><li>重新收集运行时信息后再编译</li></ul><h2 id=cpu与调度视角>CPU与调度视角</h2><h3 id=从cpu视角理解执行流程>从CPU视角理解执行流程</h3><p>从CPU的角度看，核心是“取指 -> 译码 -> 执行”，JVM做的是把字节码尽快变成CPU能执行的本地指令，并利用硬件特性提升吞吐。</p><ul><li>解释执行：解释器每次读取字节码并分发到对应处理逻辑，本质上是“字节码解释器在CPU上运行”。CPU执行的是解释器的机器码，不是Java逻辑的机器码。</li><li>JIT编译：热点方法被编译为本地机器码后，CPU就直接执行这些指令，省掉了解释分发的开销。</li><li>指令缓存与分支预测：JIT生成的紧凑、内联后的机器码更利于I-Cache命中与分支预测，减少流水线停顿。</li><li>反优化切换：当运行时假设失效，CPU重新回到解释器或新的机器码版本，类似“代码路径切换”。</li></ul><p>一句话理解：JVM在运行时把高层字节码不断“降级/升级”为CPU更容易高效执行的指令序列。</p><h3 id=jvm层面的cpu调度视角>JVM层面的CPU调度视角</h3><p>需要区分两类线程模型：</p><ul><li>传统Java线程（平台线程）：HotSpot采用1:1映射，每个Java线程对应一个OS线程，CPU时间片主要由操作系统调度器分配。JVM能做的主要是创建/销毁线程、设置优先级（只是调度提示，效果依赖OS）。</li><li>虚拟线程（JDK 21+）：JVM内部做M:N调度，虚拟线程由JVM调度到少量“载体线程”上运行，遇到阻塞点可自动让出载体线程，提高CPU利用率。</li></ul><p>JVM内部还有一些“系统线程”，它们也会参与CPU竞争：</p><ul><li>GC线程：并行/并发回收时占用CPU</li><li>编译线程：JIT后台编译热点方法</li><li>信号、采样、监控等辅助线程</li></ul><p>关键调度时刻：</p><ul><li>安全点（Safepoint）：JVM需要让所有线程到达安全点后再进行某些全局操作（如STW GC），此时会短暂停止应用线程</li><li>反优化切换：编译代码回退解释器或切换新版本机器码，线程会在安全点或调用边界完成切换</li></ul><p>一句话理解：JVM自身不“直接调度CPU”，更多是通过线程模型与安全点机制协调执行，真正的CPU时间片分配主要由OS完成；虚拟线程是JVM层“主动调度”的典型例外。</p><h2 id=运行期监控与排查建议>运行期监控与排查建议</h2><ul><li>观察类加载：<code>-XX:+TraceClassLoading</code></li><li>观察JIT：<code>-XX:+PrintCompilation</code></li><li>查看GC：<code>-Xlog:gc*</code>（JDK9+）</li></ul>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream<div id=react-app-components data-post-id=25d33955e9b6f63ee81c3c6c29557672></div>=======
>>>>>>> Stashed changes</article><div id=react-single-actions data-post-id=25d33955e9b6f63ee81c3c6c29557672></div>&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream
<button class=mobile-toc-trigger aria-controls=mobile-toc aria-expanded=false title=Index>☰</button><div class=mobile-toc-overlay hidden></div><div id=mobile-toc class=mobile-toc-drawer aria-hidden=true role=dialog aria-label=Index><div class=mobile-toc-header><button class=mobile-toc-close aria-label=close>×</button></div><nav class=mobile-toc-body><div class=mobile-toc-list></div></nav><div class=mobile-safe-area-spacer></div></div>=======
<link rel=stylesheet href=/react/alphatab/alphaTab.css>>>>>>>> Stashed changes
<script type=module src=/react/page.bundle.js></script></main><footer><div class=copyright><small>Made with <span style=color:#e25555>&#9829;</span> in Guangzhou by
©<a href=https://github.com/qtopie>qtopie</a> 2026
</small><small>Posts licensed under <a href=https://creativecommons.org/licenses/by/4.0/legalcode>CC BY 4.0</small></div><div><script type=module src=/react/base.bundle.js></script><script type=module>
      (async ()=>{
        try {
          const mod = await import('https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.mjs');
          const mermaid = mod.default || mod;
          const prefersDark = document.body.classList.contains('dark') || window.matchMedia('(prefers-color-scheme: dark)').matches;
          mermaid.initialize({ startOnLoad: false, theme: prefersDark ? 'dark' : 'default' });
          mermaid.init && mermaid.init(undefined, document.querySelectorAll('.mermaid'));
        } catch (e) { console.error('mermaid load error', e); }
      })();
    </script></div></footer></body></html>