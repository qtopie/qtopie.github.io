<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Kubernetes使用入门 | 1001問</title><link rel=stylesheet href=/css/main.min.dcb41abaa5ea2698ebf89f814bc6b8060470b6414061437dac2ee0e3ef5d3b45.css integrity="sha256-3LQauqXqJpjr+J+BS8a4BgRwtkFAYUN9rC7g4+9dO0U=" crossorigin=anonymous><link rel=stylesheet href=/css/page.min.81d92e4ce9b8dc4e8a2018a7aee70f76bd7fb6884d929d5fd74e3f959f06e2f5.css integrity="sha256-gdkuTOm43E6KIBinrucPdr1/tohNkp1f104/lZ8G4vU=" crossorigin=anonymous><link rel=stylesheet href=/css/syntax.min.e114b8cc38f57d520f373580c935a518bc6afd6dec4f1d682365cdbcf5c8218a.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css crossorigin=anonymous referrerpolicy=no-referrer><script src=/js/toc.min.87636f25caf644980403a5c1ce8b0812cfd10d1e53c08f181547966799ceccdb.js integrity="sha256-h2NvJcr2RJgEA6XBzosIEs/RDR5TwI8YFUeWZ5nOzNs=" crossorigin=anonymous type=module defer></script><script src=/js/copy-code.min.3bea0de4cfe8670f94a5d75c177f07b58fc90178efdea7f2a21449798d75b2c9.js integrity="sha256-O+oN5M/oZw+UpddcF38HtY/JAXjv3qfyohRJeY11ssk=" crossorigin=anonymous defer></script><script defer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js crossorigin=anonymous referrerpolicy=no-referrer></script><script defer src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js crossorigin=anonymous referrerpolicy=no-referrer onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})'></script><script src=/js/katex-block.min.2cf531bbcc318aadf5661baa2d0987ab5cb4daef473e108b1da714a37cff0b25.js integrity="sha256-LPUxu8wxiq31ZhuqLQmHq1y02u9HPhCLHacUo3z/CyU=" crossorigin=anonymous defer></script></head><body><header><nav><a href=/><h1>1001問</h1></a><div id=react-search class=search-root aria-label="Site Search"></div></nav></header><main><div class=sidebar><section class=toc><nav id=TableOfContents><ul><li><a href=#容器化-containerization>容器化 Containerization</a><ul><li><a href=#容器与虚拟机的对比>容器与虚拟机的对比</a></li><li><a href=#容器编排>容器编排</a></li><li><a href=#参考>参考</a></li></ul></li><li><a href=#安装>安装</a><ul><li><a href=#docker-安装>docker 安装</a></li><li><a href=#kubernetes-安装>Kubernetes 安装</a></li><li><a href=#代理设置>代理设置</a></li><li><a href=#containerd>containerd</a></li></ul></li><li><a href=#kubernetes相关概念>kubernetes相关概念</a><ul><li><a href=#试一试>试一试</a></li><li><a href=#简单地介绍k8s>简单地介绍k8s</a></li><li><a href=#namespace-命名空间>Namespace 命名空间</a></li></ul></li><li><a href=#参考-1>参考</a></li></ul></nav></section></div><article id=content><div class=metadata><h1>Kubernetes使用入门</h1><time datetime=2020-01-04T00:03:52+08:00>January 4, 2020</time><div class=taxonomy></div></div><h2 id=容器化-containerization>容器化 Containerization</h2><p>容器是标准化的软件单元。容器化将软件打包成标准化的单元，从而能够以此进行开发，装载和部署。简单地说，通过底层虚拟化，容器化实现应用Write once, run anywhere， 而且是快速地run anywhere，就像docker图标里被鲸鱼背着的集装箱一样。</p><h3 id=容器与虚拟机的对比>容器与虚拟机的对比</h3><p><img src=https://www.docker.com/sites/default/files/d8/2018-11/docker-containerized-appliction-blue-border_2.png alt=container>
<img src=https://www.docker.com/sites/default/files/d8/2018-11/container-vm-whatcontainer_2.png alt=vm></p><p>容器实现的是操作系统层面的虚拟化，而虚拟机是实现硬件层面的虚拟化。所以对于应用来说，选择容器会更加轻量级，这意味着它将占用更少的资源，能更快的启动和停止，更灵活地分配资源等等。</p><p>PS: 这里并不是说容器一定总比虚拟机好，一般来说，不同的技术方案都有它适应的场景。比如我们需要模拟完整的硬件环境，虚拟机方案显然就更合适了。例如，在办公电脑上，我常常在windows笔记本上使用hyper-v安装一个ubuntu做开发，容器化方案在这里就相形见绌了。</p><p>很多时候，容器和虚拟机被一起使用。比如，你买了一台性能很好的高可用服务器，1TB RAM, 64 core CPU，那么为了更合理的分配和管理资源，你可能首先在这台服务器上建立数个virtualbox虚拟机，然后再在虚拟机操作系统里安装docker。</p><h3 id=容器编排>容器编排</h3><p>容器化是我们能更方便地打包和运行应用，但当需要运行成百上千或者更多容器的时候，容器的自动化管理就十分重要了。对于习惯于实现应用自动化的程序员来说，甚至只管理两三个容器就巴不得有一个工具来完成自动化。容器编排就是来解决这个问题的，比较流行的有Google开发并开源的kubernetes, 及docker官方推的docker swarm。前者几乎已经成为业界规范，不过docker swarm对docker集成的更好，如果熟悉docker的话，docker swarm也会更加容易上手。</p><p>容器编排常见的功能 （不想翻译)</p><ul><li>Expose containers by DNS name or IP address.</li><li>Handle load balancing and traffic distribution for containers.</li><li>Automatically mount local and cloud-based storage.</li><li>Allocate specific CPU and RAM resources to containers and then fit them onto nodes.</li><li>Replace or kill problematic containers without jeopardizing application performance and uptime.</li><li>Manage sensitive information like password and tokens without rebuilding containers.</li><li>Change the state of containers and roll back old containers to replace them with new ones.</li></ul><h3 id=参考>参考</h3><ul><li><a href=https://www.citrix.com/glossary/what-is-containerization.html>什么是容器化</a></li><li><a href=https://www.ibm.com/cloud/blog/the-benefits-of-containerization-and-what-it-means-for-you>容器化的优点</a></li><li><a href=https://www.docker.com/resources/what-container>什么是container</a></li></ul><h2 id=安装>安装</h2><h3 id=docker-安装>docker 安装</h3><p>不推荐使用系统源或者snap包方式安装docker, 使用的时候会遇到环境或者兼容性的问题。</p><p>推荐使用docker官方源进行安装 <a href=https://docs.docker.com/install/>https://docs.docker.com/install/</a></p><h3 id=kubernetes-安装>Kubernetes 安装</h3><p>这里我们在本地学习使用kubernetes, 可以选择<a href=https://microk8s.io/>microk8s</a></p><p>如果没有安装snapd，可以参考以下内容安装</p><p><a href=https://snapcraft.io/docs/installing-snapd>https://snapcraft.io/docs/installing-snapd</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo snap install microk8s --classic
</span></span></code></pre></div><h4 id=配置>配置</h4><ul><li>网络设置</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo ufw allow in on cni0 <span class=o>&amp;&amp;</span> sudo ufw allow out on cni0
</span></span><span class=line><span class=cl>sudo ufw default allow routed
</span></span></code></pre></div><p>PS: 这里如果漏了先执行这一步，可能会导致容器之间网络访问不通
常见错误为<code>dial tcp 10.152.183.1:443: i/o timeout</code>
其实执行<code>ufw default allow routed</code>的时候已经提示了已生成的iptables规则需要手动更新</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Default routed policy changed to &#39;allow&#39;
</span></span><span class=line><span class=cl>(be sure to update your rules accordingly)
</span></span></code></pre></div><p>这里我直接采用简单暴力的方式解决（全部刷新重建）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo microk8s.stop
</span></span><span class=line><span class=cl>sudo ufw disable
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>sudo iptables -F
</span></span><span class=line><span class=cl>sudo iptables -X
</span></span><span class=line><span class=cl>sudo iptables -P INPUT ACCEPT
</span></span><span class=line><span class=cl>sudo iptables -P FORWARD ACCEPT
</span></span><span class=line><span class=cl>sudo iptables -P OUTPUT ACCEPT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>sudo ufw <span class=nb>enable</span>
</span></span><span class=line><span class=cl>sudo microk8s.start
</span></span></code></pre></div><ul><li>用户环境配置</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo usermod -a -G microk8s <span class=nv>$USER</span>
</span></span><span class=line><span class=cl>sudo chown -f -R <span class=nv>$USER</span> ~/.kube
</span></span><span class=line><span class=cl>sudo snap <span class=nb>alias</span> microk8s.kubectl kubectl
</span></span></code></pre></div><ul><li>启动</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo microk8s.start
</span></span><span class=line><span class=cl>sudo microk8s status --wait-ready
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 检查是否成功</span>
</span></span><span class=line><span class=cl>sudo microk8s.inspect
</span></span></code></pre></div><p>配置kubeconfig，默认情况下helm等工具使用<code>$HOME/.kube/config</code>作为KUBECONFIG文件访问k8s api, microk8s在把它存放在<code>$SNAP_DATA</code>目录下</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl config view --raw &gt;~/.kube/config
</span></span></code></pre></div><h3 id=代理设置>代理设置</h3><h4 id=docker服务代理设置>Docker服务代理设置</h4><p>我们可以通过给docker daemon设定http代理环境变量来使用代理。</p><p>例如如果使用的是http代理（https类似）,可以创建<code>/etc/systemd/system/docker.service.d/http-proxy.conf </code>文件，并添加以下内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[Service]
</span></span><span class=line><span class=cl>Environment=&#34;HTTP_PROXY=http://127.0.0.1:8118/&#34; &#34;NO_PROXY=localhost,127.0.0.1,docker-registry.somecorporation.com&#34;
</span></span></code></pre></div><p>参考https://docs.docker.com/config/daemon/systemd/</p><h4 id=microk8s-代理>microk8s 代理</h4><p>编辑<code>/var/snap/microk8s/current/args/containerd-env</code>文件，按照文件里的向导，设置好HTTPS_PROXY环境变量，使用命令<code>sudo systemctl restart snap.microk8s.daemon-containerd.service</code>重启生效。</p><p>参考https://microk8s.io/docs/install-proxy</p><h3 id=containerd>containerd</h3><p>microk8s 使用containerd替换了原来使用的docker，参考https://github.com/ubuntu/microk8s/commit/7c3311a6d24a0eae482dc09e86471ead41aaa19e PS: docker engine现在也是使用containerd。</p><p>不过microk8s使用的containerd为microk8s.containerd 服务，不与apt方式安装的共用sock文件，因此docker pull下来的images microk8s不能直接使用。</p><p>我们可以使用containerd手动导入镜像解决该问题（microk8s下载docker镜像比较慢，我们也可以先使用docker下载，然后用microk8s.ctr倒入）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># save image as tar file</span>
</span></span><span class=line><span class=cl><span class=c1># docker save k8s.gcr.io/pause:3.1 &gt; pause.tar</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>https_proxy</span><span class=o>=</span>socks5://192.168.50.1:1080 microk8s.ctr image pull docker.io/calico/cni:v3.23.5
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># the cri plugin is using the k8s.io namespace</span>
</span></span><span class=line><span class=cl>microk8s.ctr --namespace k8s.io image import pause.tar
</span></span></code></pre></div><h2 id=kubernetes相关概念>kubernetes相关概念</h2><h3 id=试一试>试一试</h3><p>安装好kubernetes后，类似于<code>docker run</code>命令，我们可以使用简单的命令立即启动一个pod。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run --name whoami containous/whoami:latest
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl run --image<span class=o>=</span>containous/whoami:latest whoami
</span></span></code></pre></div><h3 id=简单地介绍k8s>简单地介绍k8s</h3><p>这里我们仅以应用开发者的角度简单地介绍kubernetes。</p><h4 id=pod>Pod</h4><p>Pod为描述应用程序的"逻辑主机"进行建模，一个pod可以包含一个或多个相对耦合的容器。在同一个Pod里的容器，他们的许多资源是共享的，甚至可以使用标准IPC通信。</p><p>一个Pod永远只运行在一个节点上。</p><p><img src=https://d33wubrfki0l68.cloudfront.net/aecab1f649bc640ebef1f05581bfcc91a48038c4/728d6/images/docs/pod.svg alt=包含一个文件拉取应用和为web服务应用的Pod，文件存储volume是共享的></p><p>kubernetes定义了一系列的Controllers (控制器）来的定义和管理Pod.</p><ul><li>ReplicaSet</li><li>ReplicationController</li><li>Deployments</li><li>StatefulSets</li><li>DaemonSet</li><li>Garbage Collection</li><li>TTL Controller for Finished Resources</li><li>Jobs - Run to Completion</li><li>CronJob</li></ul><p>我们比较（直接）常用到的是Deployment。根据其名字可以看到它的使用场景和应用部署密切相关，比如创建部署、回滚、更新状态、暂停部署等。</p><p>以下是一个nginx应用示例 （kubernetes的服务编排一般可以通过yaml声明定义）</p><ul><li>nginx-deployment.yaml</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx-deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>replicas</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>matchLabels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx:stable</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span></code></pre></div><p>部署</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl apply -f nginx-deployment.yaml
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看</span>
</span></span><span class=line><span class=cl><span class=c1># kubectl get deployments</span>
</span></span></code></pre></div><p>参考</p><ul><li><a href=https://kubernetes.io/docs/concepts/workloads/pods/pod/>https://kubernetes.io/docs/concepts/workloads/pods/pod/</a></li><li><a href=https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/>https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/</a></li><li><a href=https://kubernetes.io/docs/concepts/workloads/controllers/deployment/>https://kubernetes.io/docs/concepts/workloads/controllers/deployment/</a></li></ul><h4 id=service>Service</h4><p>Service将运行在一组Pods上的某个应用抽象为一个服务。kubernetes还集成了服务发现和服务代理来保证服务的高可用性。</p><ul><li>nginx-service.yaml</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>protocol</span><span class=p>:</span><span class=w> </span><span class=l>http</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span></code></pre></div><p>使用<code>kubectl apply</code>后，可以得到以下服务</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>artificerpi@ky-laptop:~/build/nginx$ kubectl get services
</span></span><span class=line><span class=cl>NAME            TYPE        CLUSTER-IP      EXTERNAL-IP   PORT<span class=o>(</span>S<span class=o>)</span>    AGE
</span></span><span class=line><span class=cl>kubernetes      ClusterIP   10.152.183.1    &lt;none&gt;        443/TCP    104m
</span></span><span class=line><span class=cl>nginx-service   ClusterIP   10.152.183.39   &lt;none&gt;        8080/TCP   2m37s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># curl http://10.152.183.39:8080</span>
</span></span></code></pre></div><h4 id=ingress>Ingress</h4><p>Ingress是一个管理外部如何对服务进行访问的API对象，将外部请求路由到kubernetes集群里的服务。也可以理解为内部服务向外暴露。
internet
|</p><table><thead><tr><th>[ Ingress ]</th><th></th><th></th></tr></thead><tbody><tr><td>[ Services ]</td><td></td><td></td></tr></tbody></table><p>一般由Ingress Controller来实现各种Ingress需求，通常Ingress controller也是一个负载均衡器(Load banlancer)，比如Kong，Traefik，ingress-nginx等。</p><p>Kubernetes组建库本身没有集成安装Ingress Controller，但一般的云供应商会提供该产品，当然也可以选择上面提到的几个开源方案。
一般云供应商提供的Ingress Controller会集成ISP网络服务给service分配外部IP，这里本地开发测试的话，我们可以使用traefik 或者metalb <a href=https://metallb.universe.tf/>https://metallb.universe.tf/</a></p><h3 id=namespace-命名空间>Namespace 命名空间</h3><p>通过namespace定义，Kubernetes支持多租户模式使用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>ServiceAccount</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=l>traefik</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>traefik-ingress-controller</span><span class=w>
</span></span></span></code></pre></div><p>参考</p><ul><li><a href=https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/>https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/</a></li></ul><h4 id=serviceaccount-服务帐号>ServiceAccount 服务帐号</h4><p>服务账户为 Pod 中运行的进程提供了一个标识。通过服务帐号和权限配置（如RBAC）, 我们可以保证应用在集群的安全性。
结合namespace的作用, 就算不同的用户(或应用）在同一个kubernetes集群中，也能做好应用隔离和保证服务安全性。</p><p>如果要进一步学习请参考官方文档 <a href=https://kubernetes.io/docs/concepts/>https://kubernetes.io/docs/concepts/</a></p><p><img src=https://d33wubrfki0l68.cloudfront.net/7016517375d10c702489167e704dcb99e570df85/7bb53/images/docs/components-of-kubernetes.png alt=Kubernetes组件></p><h2 id=参考-1>参考</h2><ul><li><a href=https://kubernetes.io/zh/blog/2019/11/26/%E4%BD%BF%E7%94%A8-microk8s-%E5%9C%A8-linux-%E4%B8%8A%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C-kubernetes/>https://kubernetes.io/zh/blog/2019/11/26/%E4%BD%BF%E7%94%A8-microk8s-%E5%9C%A8-linux-%E4%B8%8A%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C-kubernetes/</a></li><li><a href=https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/>https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/</a></li><li><a href=https://help.aliyun.com/document_detail/60750.html>pull</a></li></ul><div id=react-single-actions data-post-id=c59346684dbab1708c7e61763bfbaeb8></div></article><button class=mobile-toc-trigger aria-controls=mobile-toc aria-expanded=false title=Index>☰</button><div class=mobile-toc-overlay hidden></div><div id=mobile-toc class=mobile-toc-drawer aria-hidden=true role=dialog aria-label=Index><div class=mobile-toc-header><button class=mobile-toc-close aria-label=close>×</button></div><nav class=mobile-toc-body><div class=mobile-toc-list></div></nav><div class=mobile-safe-area-spacer></div></div><script type=module src=/react/page.bundle.js></script></main><footer><div class=copyright><small>Made with <span style=color:#e25555>&#9829;</span> in Guangzhou by
©<a href=https://github.com/qtopie>qtopie</a> 2026
</small><small>Posts licensed under <a href=https://creativecommons.org/licenses/by/4.0/legalcode>CC BY 4.0</small></div><div><script type=module src=/react/base.bundle.js></script></div></footer></body></html>