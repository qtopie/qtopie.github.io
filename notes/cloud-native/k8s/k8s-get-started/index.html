<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Kubernetes使用入门"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://qtopie.github.io/notes/cloud-native/k8s/k8s-get-started/"><meta property="og:site_name" content="Blog | qtopierw"><meta property="og:title" content="Kubernetes使用入门"><meta property="og:description" content="Kubernetes使用入门"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2020-01-04T00:03:52+08:00"><meta property="article:modified_time" content="2020-01-04T00:03:52+08:00"><title>Kubernetes使用入门 | Blog | qtopierw</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://qtopie.github.io/notes/cloud-native/k8s/k8s-get-started/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.6b0a5247a29534ab597c09c6ba111855ef60594896512109921af15ed6e3e547.js integrity="sha256-awpSR6KVNKtZfAnGuhEYVe9gWUiWUSEJkhrxXtbj5Uc=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Blog | qtopierw</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Kubernetes使用入门</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#容器化-containerization>容器化 Containerization</a><ul><li><a href=#容器与虚拟机的对比>容器与虚拟机的对比</a></li><li><a href=#容器编排>容器编排</a></li><li><a href=#参考>参考</a></li></ul></li><li><a href=#安装>安装</a><ul><li><a href=#docker-安装>docker 安装</a></li><li><a href=#kubernetes-安装>Kubernetes 安装</a></li><li><a href=#代理设置>代理设置</a></li><li><a href=#containerd>containerd</a></li></ul></li><li><a href=#kubernetes相关概念>kubernetes相关概念</a><ul><li><a href=#试一试>试一试</a></li><li><a href=#简单地介绍k8s>简单地介绍k8s</a></li><li><a href=#namespace-命名空间>Namespace 命名空间</a></li></ul></li><li><a href=#参考-1>参考</a></li></ul></nav></aside></header><article class="markdown book-article"><h2 id=容器化-containerization>容器化 Containerization
<a class=anchor href=#%e5%ae%b9%e5%99%a8%e5%8c%96-containerization>#</a></h2><p>容器是标准化的软件单元。容器化将软件打包成标准化的单元，从而能够以此进行开发，装载和部署。简单地说，通过底层虚拟化，容器化实现应用Write once, run anywhere， 而且是快速地run anywhere，就像docker图标里被鲸鱼背着的集装箱一样。</p><h3 id=容器与虚拟机的对比>容器与虚拟机的对比
<a class=anchor href=#%e5%ae%b9%e5%99%a8%e4%b8%8e%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%9a%84%e5%af%b9%e6%af%94>#</a></h3><p><img src=https://www.docker.com/sites/default/files/d8/2018-11/docker-containerized-appliction-blue-border_2.png alt=container>
<img src=https://www.docker.com/sites/default/files/d8/2018-11/container-vm-whatcontainer_2.png alt=vm></p><p>容器实现的是操作系统层面的虚拟化，而虚拟机是实现硬件层面的虚拟化。所以对于应用来说，选择容器会更加轻量级，这意味着它将占用更少的资源，能更快的启动和停止，更灵活地分配资源等等。</p><p>PS: 这里并不是说容器一定总比虚拟机好，一般来说，不同的技术方案都有它适应的场景。比如我们需要模拟完整的硬件环境，虚拟机方案显然就更合适了。例如，在办公电脑上，我常常在windows笔记本上使用hyper-v安装一个ubuntu做开发，容器化方案在这里就相形见绌了。</p><p>很多时候，容器和虚拟机被一起使用。比如，你买了一台性能很好的高可用服务器，1TB RAM, 64 core CPU，那么为了更合理的分配和管理资源，你可能首先在这台服务器上建立数个virtualbox虚拟机，然后再在虚拟机操作系统里安装docker。</p><h3 id=容器编排>容器编排
<a class=anchor href=#%e5%ae%b9%e5%99%a8%e7%bc%96%e6%8e%92>#</a></h3><p>容器化是我们能更方便地打包和运行应用，但当需要运行成百上千或者更多容器的时候，容器的自动化管理就十分重要了。对于习惯于实现应用自动化的程序员来说，甚至只管理两三个容器就巴不得有一个工具来完成自动化。容器编排就是来解决这个问题的，比较流行的有Google开发并开源的kubernetes, 及docker官方推的docker swarm。前者几乎已经成为业界规范，不过docker swarm对docker集成的更好，如果熟悉docker的话，docker swarm也会更加容易上手。</p><p>容器编排常见的功能 （不想翻译)</p><ul><li>Expose containers by DNS name or IP address.</li><li>Handle load balancing and traffic distribution for containers.</li><li>Automatically mount local and cloud-based storage.</li><li>Allocate specific CPU and RAM resources to containers and then fit them onto nodes.</li><li>Replace or kill problematic containers without jeopardizing application performance and uptime.</li><li>Manage sensitive information like password and tokens without rebuilding containers.</li><li>Change the state of containers and roll back old containers to replace them with new ones.</li></ul><h3 id=参考>参考
<a class=anchor href=#%e5%8f%82%e8%80%83>#</a></h3><ul><li><a href=https://www.citrix.com/glossary/what-is-containerization.html>什么是容器化</a></li><li><a href=https://www.ibm.com/cloud/blog/the-benefits-of-containerization-and-what-it-means-for-you>容器化的优点</a></li><li><a href=https://www.docker.com/resources/what-container>什么是container</a></li></ul><h2 id=安装>安装
<a class=anchor href=#%e5%ae%89%e8%a3%85>#</a></h2><h3 id=docker-安装>docker 安装
<a class=anchor href=#docker-%e5%ae%89%e8%a3%85>#</a></h3><p>不推荐使用系统源或者snap包方式安装docker, 使用的时候会遇到环境或者兼容性的问题。</p><p>推荐使用docker官方源进行安装 <a href=https://docs.docker.com/install/>https://docs.docker.com/install/</a></p><h3 id=kubernetes-安装>Kubernetes 安装
<a class=anchor href=#kubernetes-%e5%ae%89%e8%a3%85>#</a></h3><p>这里我们在本地学习使用kubernetes, 可以选择<a href=https://microk8s.io/>microk8s</a></p><p>如果没有安装snapd，可以参考以下内容安装</p><p><a href=https://snapcraft.io/docs/installing-snapd>https://snapcraft.io/docs/installing-snapd</a></p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>sudo snap install microk8s --classic
</span></span></code></pre></div><h4 id=配置>配置
<a class=anchor href=#%e9%85%8d%e7%bd%ae>#</a></h4><ul><li>网络设置</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>sudo ufw allow in on cni0 <span style=color:#555>&amp;&amp;</span> sudo ufw allow out on cni0
</span></span><span style=display:flex><span>sudo ufw default allow routed
</span></span></code></pre></div><p>PS: 这里如果漏了先执行这一步，可能会导致容器之间网络访问不通
常见错误为<code>dial tcp 10.152.183.1:443: i/o timeout</code>
其实执行<code>ufw default allow routed</code>的时候已经提示了已生成的iptables规则需要手动更新</p><pre tabindex=0><code>Default routed policy changed to &#39;allow&#39;
(be sure to update your rules accordingly)
</code></pre><p>这里我直接采用简单暴力的方式解决（全部刷新重建）</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>sudo microk8s.stop
</span></span><span style=display:flex><span>sudo ufw disable
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sudo iptables -F
</span></span><span style=display:flex><span>sudo iptables -X
</span></span><span style=display:flex><span>sudo iptables -P INPUT ACCEPT
</span></span><span style=display:flex><span>sudo iptables -P FORWARD ACCEPT
</span></span><span style=display:flex><span>sudo iptables -P OUTPUT ACCEPT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sudo ufw <span style=color:#366>enable</span>
</span></span><span style=display:flex><span>sudo microk8s.start
</span></span></code></pre></div><ul><li>用户环境配置</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>sudo usermod -a -G microk8s <span style=color:#033>$USER</span>
</span></span><span style=display:flex><span>sudo chown -f -R <span style=color:#033>$USER</span> ~/.kube
</span></span><span style=display:flex><span>sudo snap <span style=color:#366>alias</span> microk8s.kubectl kubectl
</span></span></code></pre></div><ul><li>启动</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>sudo microk8s.start
</span></span><span style=display:flex><span>sudo microk8s status --wait-ready
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># 检查是否成功</span>
</span></span><span style=display:flex><span>sudo microk8s.inspect
</span></span></code></pre></div><p>配置kubeconfig，默认情况下helm等工具使用<code>$HOME/.kube/config</code>作为KUBECONFIG文件访问k8s api, microk8s在把它存放在<code>$SNAP_DATA</code>目录下</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl config view --raw &gt;~/.kube/config
</span></span></code></pre></div><h3 id=代理设置>代理设置
<a class=anchor href=#%e4%bb%a3%e7%90%86%e8%ae%be%e7%bd%ae>#</a></h3><h4 id=docker服务代理设置>Docker服务代理设置
<a class=anchor href=#docker%e6%9c%8d%e5%8a%a1%e4%bb%a3%e7%90%86%e8%ae%be%e7%bd%ae>#</a></h4><p>我们可以通过给docker daemon设定http代理环境变量来使用代理。</p><p>例如如果使用的是http代理（https类似）,可以创建<code>/etc/systemd/system/docker.service.d/http-proxy.conf </code>文件，并添加以下内容：</p><pre tabindex=0><code>[Service]
Environment=&#34;HTTP_PROXY=http://127.0.0.1:8118/&#34; &#34;NO_PROXY=localhost,127.0.0.1,docker-registry.somecorporation.com&#34;
</code></pre><p>参考https://docs.docker.com/config/daemon/systemd/</p><h4 id=microk8s-代理>microk8s 代理
<a class=anchor href=#microk8s-%e4%bb%a3%e7%90%86>#</a></h4><p>编辑<code>/var/snap/microk8s/current/args/containerd-env</code>文件，按照文件里的向导，设置好HTTPS_PROXY环境变量，使用命令<code>sudo systemctl restart snap.microk8s.daemon-containerd.service</code>重启生效。</p><p>参考https://microk8s.io/docs/install-proxy</p><h3 id=containerd>containerd
<a class=anchor href=#containerd>#</a></h3><p>microk8s 使用containerd替换了原来使用的docker，参考https://github.com/ubuntu/microk8s/commit/7c3311a6d24a0eae482dc09e86471ead41aaa19e PS: docker engine现在也是使用containerd。</p><p>不过microk8s使用的containerd为microk8s.containerd 服务，不与apt方式安装的共用sock文件，因此docker pull下来的images microk8s不能直接使用。</p><p>我们可以使用containerd手动导入镜像解决该问题（microk8s下载docker镜像比较慢，我们也可以先使用docker下载，然后用microk8s.ctr倒入）</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#09f;font-style:italic># save image as tar file</span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># docker save k8s.gcr.io/pause:3.1 &gt; pause.tar</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#033>https_proxy</span><span style=color:#555>=</span>socks5://192.168.50.1:1080 microk8s.ctr image pull docker.io/calico/cni:v3.23.5
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># the cri plugin is using the k8s.io namespace</span>
</span></span><span style=display:flex><span>microk8s.ctr --namespace k8s.io image import pause.tar
</span></span></code></pre></div><h2 id=kubernetes相关概念>kubernetes相关概念
<a class=anchor href=#kubernetes%e7%9b%b8%e5%85%b3%e6%a6%82%e5%bf%b5>#</a></h2><h3 id=试一试>试一试
<a class=anchor href=#%e8%af%95%e4%b8%80%e8%af%95>#</a></h3><p>安装好kubernetes后，类似于<code>docker run</code>命令，我们可以使用简单的命令立即启动一个pod。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>docker run --name whoami containous/whoami:latest
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl run --image<span style=color:#555>=</span>containous/whoami:latest whoami
</span></span></code></pre></div><h3 id=简单地介绍k8s>简单地介绍k8s
<a class=anchor href=#%e7%ae%80%e5%8d%95%e5%9c%b0%e4%bb%8b%e7%bb%8dk8s>#</a></h3><p>这里我们仅以应用开发者的角度简单地介绍kubernetes。</p><h4 id=pod>Pod
<a class=anchor href=#pod>#</a></h4><p>Pod为描述应用程序的"逻辑主机"进行建模，一个pod可以包含一个或多个相对耦合的容器。在同一个Pod里的容器，他们的许多资源是共享的，甚至可以使用标准IPC通信。</p><p>一个Pod永远只运行在一个节点上。</p><p><img src=https://d33wubrfki0l68.cloudfront.net/aecab1f649bc640ebef1f05581bfcc91a48038c4/728d6/images/docs/pod.svg alt=包含一个文件拉取应用和为web服务应用的Pod，文件存储volume是共享的></p><p>kubernetes定义了一系列的Controllers (控制器）来的定义和管理Pod.</p><ul><li>ReplicaSet</li><li>ReplicationController</li><li>Deployments</li><li>StatefulSets</li><li>DaemonSet</li><li>Garbage Collection</li><li>TTL Controller for Finished Resources</li><li>Jobs - Run to Completion</li><li>CronJob</li></ul><p>我们比较（直接）常用到的是Deployment。根据其名字可以看到它的使用场景和应用部署密切相关，比如创建部署、回滚、更新状态、暂停部署等。</p><p>以下是一个nginx应用示例 （kubernetes的服务编排一般可以通过yaml声明定义）</p><ul><li>nginx-deployment.yaml</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#309;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#309;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#309;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#309;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#309;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#309;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#309;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#309;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#f60>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#309;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#309;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#309;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#309;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#309;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#309;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#309;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#309;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#309;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#309;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#309;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:stable<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#309;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#309;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#f60>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>部署</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f nginx-deployment.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># 查看</span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># kubectl get deployments</span>
</span></span></code></pre></div><p>参考</p><ul><li><a href=https://kubernetes.io/docs/concepts/workloads/pods/pod/>https://kubernetes.io/docs/concepts/workloads/pods/pod/</a></li><li><a href=https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/>https://kubernetes.io/docs/tutorials/kubernetes-basics/explore/explore-intro/</a></li><li><a href=https://kubernetes.io/docs/concepts/workloads/controllers/deployment/>https://kubernetes.io/docs/concepts/workloads/controllers/deployment/</a></li></ul><h4 id=service>Service
<a class=anchor href=#service>#</a></h4><p>Service将运行在一组Pods上的某个应用抽象为一个服务。kubernetes还集成了服务发现和服务代理来保证服务的高可用性。</p><ul><li>nginx-service.yaml</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#309;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#309;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#309;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#309;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#309;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#309;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#309;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#309;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#309;font-weight:700>protocol</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#309;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#f60>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#309;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#f60>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>使用<code>kubectl apply</code>后，可以得到以下服务</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bash data-lang=bash><span style=display:flex><span>artificerpi@ky-laptop:~/build/nginx$ kubectl get services
</span></span><span style=display:flex><span>NAME            TYPE        CLUSTER-IP      EXTERNAL-IP   PORT<span style=color:#555>(</span>S<span style=color:#555>)</span>    AGE
</span></span><span style=display:flex><span>kubernetes      ClusterIP   10.152.183.1    &lt;none&gt;        443/TCP    104m
</span></span><span style=display:flex><span>nginx-service   ClusterIP   10.152.183.39   &lt;none&gt;        8080/TCP   2m37s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># curl http://10.152.183.39:8080</span>
</span></span></code></pre></div><h4 id=ingress>Ingress
<a class=anchor href=#ingress>#</a></h4><p>Ingress是一个管理外部如何对服务进行访问的API对象，将外部请求路由到kubernetes集群里的服务。也可以理解为内部服务向外暴露。
internet
|</p><table><thead><tr><th>[ Ingress ]</th><th></th><th></th></tr></thead><tbody><tr><td>[ Services ]</td><td></td><td></td></tr></tbody></table><p>一般由Ingress Controller来实现各种Ingress需求，通常Ingress controller也是一个负载均衡器(Load banlancer)，比如Kong，Traefik，ingress-nginx等。</p><p>Kubernetes组建库本身没有集成安装Ingress Controller，但一般的云供应商会提供该产品，当然也可以选择上面提到的几个开源方案。
一般云供应商提供的Ingress Controller会集成ISP网络服务给service分配外部IP，这里本地开发测试的话，我们可以使用traefik 或者metalb <a href=https://metallb.universe.tf/>https://metallb.universe.tf/</a></p><h3 id=namespace-命名空间>Namespace 命名空间
<a class=anchor href=#namespace-%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4>#</a></h3><p>通过namespace定义，Kubernetes支持多租户模式使用。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#309;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#309;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#309;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#309;font-weight:700>namespace</span>:<span style=color:#bbb> </span>traefik<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#309;font-weight:700>name</span>:<span style=color:#bbb> </span>traefik-ingress-controller<span style=color:#bbb>
</span></span></span></code></pre></div><p>参考</p><ul><li><a href=https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/>https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/</a></li></ul><h4 id=serviceaccount-服务帐号>ServiceAccount 服务帐号
<a class=anchor href=#serviceaccount-%e6%9c%8d%e5%8a%a1%e5%b8%90%e5%8f%b7>#</a></h4><p>服务账户为 Pod 中运行的进程提供了一个标识。通过服务帐号和权限配置（如RBAC）, 我们可以保证应用在集群的安全性。
结合namespace的作用, 就算不同的用户(或应用）在同一个kubernetes集群中，也能做好应用隔离和保证服务安全性。</p><p>如果要进一步学习请参考官方文档 <a href=https://kubernetes.io/docs/concepts/>https://kubernetes.io/docs/concepts/</a></p><p><img src=https://d33wubrfki0l68.cloudfront.net/7016517375d10c702489167e704dcb99e570df85/7bb53/images/docs/components-of-kubernetes.png alt=Kubernetes组件></p><h2 id=参考-1>参考
<a class=anchor href=#%e5%8f%82%e8%80%83-1>#</a></h2><ul><li><a href=https://kubernetes.io/zh/blog/2019/11/26/%E4%BD%BF%E7%94%A8-microk8s-%E5%9C%A8-linux-%E4%B8%8A%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C-kubernetes/>https://kubernetes.io/zh/blog/2019/11/26/%E4%BD%BF%E7%94%A8-microk8s-%E5%9C%A8-linux-%E4%B8%8A%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C-kubernetes/</a></li><li><a href=https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/>https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/</a></li><li><a href=https://help.aliyun.com/document_detail/60750.html>pull</a></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#容器化-containerization>容器化 Containerization</a><ul><li><a href=#容器与虚拟机的对比>容器与虚拟机的对比</a></li><li><a href=#容器编排>容器编排</a></li><li><a href=#参考>参考</a></li></ul></li><li><a href=#安装>安装</a><ul><li><a href=#docker-安装>docker 安装</a></li><li><a href=#kubernetes-安装>Kubernetes 安装</a></li><li><a href=#代理设置>代理设置</a></li><li><a href=#containerd>containerd</a></li></ul></li><li><a href=#kubernetes相关概念>kubernetes相关概念</a><ul><li><a href=#试一试>试一试</a></li><li><a href=#简单地介绍k8s>简单地介绍k8s</a></li><li><a href=#namespace-命名空间>Namespace 命名空间</a></li></ul></li><li><a href=#参考-1>参考</a></li></ul></nav></div></aside></main></body></html>