<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>EBPF on 1001問</title><link>https://qtopie.github.io/tags/ebpf/</link><description>Recent content in EBPF on 1001問</description><generator>Hugo</generator><language>en-us</language><copyright>Posts licensed under &lt;a href="https://creativecommons.org/licenses/by/4.0/legalcode"&gt;CC BY 4.0</copyright><lastBuildDate>Sun, 25 Jan 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://qtopie.github.io/tags/ebpf/index.xml" rel="self" type="application/rss+xml"/><item><title>eBPF</title><link>https://qtopie.github.io/notes/linux/ebpf/</link><pubDate>Sun, 25 Jan 2026 00:00:00 +0000</pubDate><guid>https://qtopie.github.io/notes/linux/ebpf/</guid><description>&lt;h2 id="ebpf介绍"&gt;eBPF介绍&lt;/h2&gt;
&lt;p&gt;eBPF（Extended Berkeley Packet Filter）是一种革命性的内核技术，允许开发者在不修改内核源代码、不加载内核模块的情况下，在操作系统内核中安全、高效地运行自定义程序。
它通过在内核中运行一个沙盒虚拟机，使内核变得可编程，广泛应用于网络、安全、可观测性等领域。&lt;/p&gt;
&lt;p&gt;&lt;img src="ebpf.png" alt="What is eBPF"&gt;&lt;/p&gt;
&lt;h3 id="核心工作原理"&gt;核心工作原理&lt;/h3&gt;
&lt;p&gt;事件驱动：eBPF 程序通常挂载在特定的“钩子”（Hook）上，如系统调用、网络包收发、内核跟踪点（Tracepoint）或动态探测点（kprobes/uprobes）。
安全验证：程序加载前会经过内核验证器（Verifier）的严格检查，确保程序不会崩溃、不会陷入死循环，也不会非法访问内核内存。
JIT 编译：经过验证的字节码通过即时编译（JIT）转换为原生的机器指令，其执行效率接近原生内核代码。
数据交互：eBPF 程序通过 Maps（键值对存储）与用户空间进行数据共享，实现监控结果的实时传输或配置的动态更新。&lt;/p&gt;
&lt;p&gt;主要应用场景
网络加速与负载均衡：例如 Cilium 利用 eBPF 实现高性能的容器网络和安全路由。
可观测性：在无需修改应用代码的情况下，实现极低开销的系统调用跟踪、性能剖析和链路监控。
运行时安全：实时拦截异常的系统调用，实施细粒度的防火墙规则或安全策略。&lt;/p&gt;
&lt;p&gt;优势对比
特性 	eBPF 程序	内核模块 (Kernel Module)	修改内核源码
安全性	内核验证器保证不崩溃	错误可能导致系统蓝屏/死机	风险最高
灵活性	动态加载/卸载，无需重启	加载复杂，易引入依赖问题	需要编译并重启内核
性能	高（JIT 编译后接近原生）	高	高
如需开始开发，可以参考 ebpf.io 提供的文档，或使用 BCC (BPF Compiler Collection) 和 libbpf 等工具链&lt;/p&gt;
&lt;h3 id="ebpf动态扩展了哪些内核能力"&gt;eBPF动态扩展了哪些内核能力&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;深度可观测性与性能剖析 (Observability &amp;amp; Profiling)
eBPF 可以无死角地观察内核和应用的运行状态，且几乎没有性能损耗。
函数与系统调用跟踪：通过挂载到 kprobes（内核函数）、uprobes（用户空间函数）或 tracepoints（静态跟踪点），实时监控每一次系统调用或函数执行。
零侵入性能监控：无需修改应用代码（无须重新编译或注入代理），即可采集 CPU 指令周期、内存使用率及函数调用热点图。
低开销数据聚合：在内核态直接对数据进行过滤和统计，只将最终结果传给用户态，避免了大量原始数据拷贝带来的开销。&lt;/li&gt;
&lt;li&gt;高性能网络处理 (Networking)
通过接管内核协议栈的关键路径，eBPF 极大地提升了网络吞吐量并降低了延迟。
绕过标准协议栈 (XDP)：在网卡驱动层（XDP）直接处理数据包，实现极速的 DDoS 防护、负载均衡和防火墙过滤。
容器网络与服务网格：在 Kubernetes 等云原生场景中，eBPF 可实现 Pod 间的高效路由，甚至直接绕过传统的 iptables 规则以优化网络路径。
自定义协议解析：支持在内核态直接解析非标准或自定义的网络协议，无需将包传回用户空间处理。&lt;/li&gt;
&lt;li&gt;动态安全控制 (Security)
eBPF 充当了内核级的“安全警卫”，能够实时识别并拦截恶意行为。
运行时行为审计：监控异常的进程行为（如异常读取 /etc/shadow 文件），并触发警报或直接终止该操作。
细粒度权限管控：不仅能看（审计），还能干预。例如限制特定进程仅能访问特定的 IP 或文件目录。
加密与脱敏：实时监控敏感数据流，在内核态自动执行 TLS 卸载或对传输中的敏感数据进行脱敏处理。&lt;/li&gt;
&lt;li&gt;现代内核调度与扩展 (Kernel Evolution)
到 2026 年，eBPF 的能力已进一步深入到内核的核心调度逻辑。
自定义 CPU 调度：通过 sched_ext 等框架，开发者可以编写自定义的 CPU 调度策略，针对特定工作负载（如 AI 训练或实时音视频）优化计算资源的分配。
热补丁与功能修复：在不重启系统的情况下，通过挂载 eBPF 程序动态修复已知的内核逻辑缺陷或漏洞。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="如何使用"&gt;如何使用&lt;/h2&gt;
&lt;h3 id="ebpf工作流程"&gt;eBPF工作流程&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;graph TD
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; subgraph User_Space [&amp;#34;用户态 (User Space)&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; A[&amp;#34;编写 eBPF 源代码&amp;lt;br/&amp;gt;(C / Rust)&amp;#34;] -- &amp;#34;LLVM / Clang&amp;#34; --&amp;gt; B[&amp;#34;eBPF 字节码&amp;lt;br/&amp;gt;(Bytecode)&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; B -- &amp;#34;bpf 系统调用&amp;#34; --&amp;gt; C[&amp;#34;加载并注入内核&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; L[&amp;#34;eBPF Maps&amp;lt;br/&amp;gt;共享存储/键值对&amp;#34;] --- M[&amp;#34;用户态控制程序&amp;lt;br/&amp;gt;Go / C++ / Rust&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; M -- &amp;#34;分析数据&amp;#34; --&amp;gt; N[&amp;#34;可视化 / 控制面板&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; end
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; subgraph Kernel_Space [&amp;#34;内核态 (Kernel Space)&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; C --&amp;gt; D{&amp;#34;验证器 Verifier&amp;lt;br/&amp;gt;安全/权限检查&amp;#34;}
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; D -- &amp;#34;拒绝&amp;#34; --&amp;gt; E[&amp;#34;报错并停止加载&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; D -- &amp;#34;通过&amp;#34; --&amp;gt; F[&amp;#34;JIT 即时编译器&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; F --&amp;gt; G[&amp;#34;原生机器码&amp;lt;br/&amp;gt;Native Machine Code&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; subgraph Hooks [&amp;#34;事件钩子 (Event Hooks)&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; H[&amp;#34;网络包 XDP/TC&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; I[&amp;#34;系统调用 Syscalls&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; J[&amp;#34;内核函数 Kprobes&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; K[&amp;#34;用户函数 Uprobes&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; end
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; G -- &amp;#34;挂载执行&amp;#34; --&amp;gt; H
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; G -- &amp;#34;挂载执行&amp;#34; --&amp;gt; I
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; G -- &amp;#34;挂载执行&amp;#34; --&amp;gt; J
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; G -- &amp;#34;挂载执行&amp;#34; --&amp;gt; K
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; H &amp;amp; I &amp;amp; J &amp;amp; K -- &amp;#34;数据交互&amp;#34; --&amp;gt; L
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; end
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; style D fill:#f96,stroke:#333,stroke-width:2px
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; style G fill:#00d2ff,stroke:#333,stroke-width:2px
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; style L fill:#fff4dd,stroke:#d4a017,stroke-width:2px
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="一个加速小例子"&gt;一个加速小例子&lt;/h3&gt;
&lt;p&gt;现在假定一个业务场景，比如我们想实现给局域网里的部分设备如平板/手机游戏加速，其工作流程为
当手机流量到达网关时，根据手机MAC地址和请求的域名/IP对应指定游戏的服务时，就转发到加速端口进行加速，否则就走直连。&lt;/p&gt;</description></item></channel></rss>